---
title: Juju Client Facade/OpenAPI Generation v1.0
language_tabs:
  - shell: Shell
  - http: HTTP
  - javascript: JavaScript
  - ruby: Ruby
  - python: Python
  - php: PHP
  - java: Java
  - go: Go
toc_footers: []
includes: []
search: true
highlight_theme: darkula
headingLevel: 2

---

<!-- Generator: Widdershins v4.0.1 -->

<h1 id="juju-client-facade-openapi-generation">Juju Client Facade/OpenAPI Generation v1.0</h1>

> Scroll down for code samples, example requests and responses. Select a language for code samples from the tabs above or the mobile navigation menu.

Naive conversion from Juju's schema.json to an OpenAPI spec.

<h1 id="juju-client-facade-openapi-generation-action">action</h1>

## actions

<a id="opIdactions"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /action/actions \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /action/actions HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/action/actions',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/action/actions',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/action/actions', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/action/actions', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/action/actions");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/action/actions", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /action/actions`

Takes a list of ActionTags, and returns the full Action for each ID.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="actions-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "action": {
        "execution-group": "string",
        "name": "string",
        "parallel": true,
        "parameters": {},
        "receiver": "string",
        "tag": "string"
      },
      "completed": "2019-08-24T14:15:22Z",
      "enqueued": "2019-08-24T14:15:22Z",
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "log": [
        {
          "message": "string",
          "timestamp": "2019-08-24T14:15:22Z"
        }
      ],
      "message": "string",
      "output": {},
      "started": "2019-08-24T14:15:22Z",
      "status": "string"
    }
  ]
}
```

<h3 id="actions-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ActionResults](#schemaactionresults)|

<aside class="success">
This operation does not require authentication
</aside>

## applicationsCharmsActions

<a id="opIdapplicationsCharmsActions"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /action/applicationsCharmsActions \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /action/applicationsCharmsActions HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/action/applicationsCharmsActions',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/action/applicationsCharmsActions',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/action/applicationsCharmsActions', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/action/applicationsCharmsActions', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/action/applicationsCharmsActions");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/action/applicationsCharmsActions", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /action/applicationsCharmsActions`

Returns a slice of charm Actions for a slice of services.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="applicationscharmsactions-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "actions": {},
      "application-tag": "string",
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="applicationscharmsactions-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ApplicationsCharmActionsResults](#schemaapplicationscharmactionsresults)|

<aside class="success">
This operation does not require authentication
</aside>

## cancel

<a id="opIdcancel"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /action/cancel \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /action/cancel HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/action/cancel',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/action/cancel',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/action/cancel', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/action/cancel', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/action/cancel");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/action/cancel", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /action/cancel`

Attempts to cancel enqueued Actions from running.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="cancel-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "action": {
        "execution-group": "string",
        "name": "string",
        "parallel": true,
        "parameters": {},
        "receiver": "string",
        "tag": "string"
      },
      "completed": "2019-08-24T14:15:22Z",
      "enqueued": "2019-08-24T14:15:22Z",
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "log": [
        {
          "message": "string",
          "timestamp": "2019-08-24T14:15:22Z"
        }
      ],
      "message": "string",
      "output": {},
      "started": "2019-08-24T14:15:22Z",
      "status": "string"
    }
  ]
}
```

<h3 id="cancel-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ActionResults](#schemaactionresults)|

<aside class="success">
This operation does not require authentication
</aside>

## enqueueOperation

<a id="opIdenqueueOperation"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /action/enqueueOperation \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /action/enqueueOperation HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "actions": [
    {
      "execution-group": "string",
      "name": "string",
      "parallel": true,
      "parameters": {},
      "receiver": "string",
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/action/enqueueOperation',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/action/enqueueOperation',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/action/enqueueOperation', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/action/enqueueOperation', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/action/enqueueOperation");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/action/enqueueOperation", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /action/enqueueOperation`

Takes a list of Actions and queues them up to be executed as an operation, each action running as a task on the designated ActionReceiver. We return the ID of the overall operation and each individual task.

> Body parameter

```json
{
  "actions": [
    {
      "execution-group": "string",
      "name": "string",
      "parallel": true,
      "parameters": {},
      "receiver": "string",
      "tag": "string"
    }
  ]
}
```

<h3 id="enqueueoperation-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Actions](#schemaactions)|true|none|

> Example responses

> 200 Response

```json
{
  "actions": [
    {
      "action": {
        "execution-group": "string",
        "name": "string",
        "parallel": true,
        "parameters": {},
        "receiver": "string",
        "tag": "string"
      },
      "completed": "2019-08-24T14:15:22Z",
      "enqueued": "2019-08-24T14:15:22Z",
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "log": [
        {
          "message": "string",
          "timestamp": "2019-08-24T14:15:22Z"
        }
      ],
      "message": "string",
      "output": {},
      "started": "2019-08-24T14:15:22Z",
      "status": "string"
    }
  ],
  "operation": "string"
}
```

<h3 id="enqueueoperation-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[EnqueuedActions](#schemaenqueuedactions)|

<aside class="success">
This operation does not require authentication
</aside>

## listOperations

<a id="opIdlistOperations"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /action/listOperations \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /action/listOperations HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "actions": [
    "string"
  ],
  "applications": [
    "string"
  ],
  "limit": 0,
  "machines": [
    "string"
  ],
  "offset": 0,
  "status": [
    "string"
  ],
  "units": [
    "string"
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/action/listOperations',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/action/listOperations',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/action/listOperations', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/action/listOperations', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/action/listOperations");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/action/listOperations", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /action/listOperations`

Fetches the called actions for specified apps/units.

> Body parameter

```json
{
  "actions": [
    "string"
  ],
  "applications": [
    "string"
  ],
  "limit": 0,
  "machines": [
    "string"
  ],
  "offset": 0,
  "status": [
    "string"
  ],
  "units": [
    "string"
  ]
}
```

<h3 id="listoperations-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[OperationQueryArgs](#schemaoperationqueryargs)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "actions": [
        {
          "action": {
            "execution-group": "string",
            "name": "string",
            "parallel": true,
            "parameters": {},
            "receiver": "string",
            "tag": "string"
          },
          "completed": "2019-08-24T14:15:22Z",
          "enqueued": "2019-08-24T14:15:22Z",
          "error": {
            "code": "string",
            "info": {},
            "message": "string"
          },
          "log": [
            {
              "message": "string",
              "timestamp": "2019-08-24T14:15:22Z"
            }
          ],
          "message": "string",
          "output": {},
          "started": "2019-08-24T14:15:22Z",
          "status": "string"
        }
      ],
      "completed": "2019-08-24T14:15:22Z",
      "enqueued": "2019-08-24T14:15:22Z",
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "fail": "string",
      "operation": "string",
      "started": "2019-08-24T14:15:22Z",
      "status": "string",
      "summary": "string"
    }
  ],
  "truncated": true
}
```

<h3 id="listoperations-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[OperationResults](#schemaoperationresults)|

<aside class="success">
This operation does not require authentication
</aside>

## operations

<a id="opIdoperations"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /action/operations \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /action/operations HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/action/operations',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/action/operations',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/action/operations', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/action/operations', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/action/operations");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/action/operations", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /action/operations`

Fetches the specified operation ids.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="operations-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "actions": [
        {
          "action": {
            "execution-group": "string",
            "name": "string",
            "parallel": true,
            "parameters": {},
            "receiver": "string",
            "tag": "string"
          },
          "completed": "2019-08-24T14:15:22Z",
          "enqueued": "2019-08-24T14:15:22Z",
          "error": {
            "code": "string",
            "info": {},
            "message": "string"
          },
          "log": [
            {
              "message": "string",
              "timestamp": "2019-08-24T14:15:22Z"
            }
          ],
          "message": "string",
          "output": {},
          "started": "2019-08-24T14:15:22Z",
          "status": "string"
        }
      ],
      "completed": "2019-08-24T14:15:22Z",
      "enqueued": "2019-08-24T14:15:22Z",
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "fail": "string",
      "operation": "string",
      "started": "2019-08-24T14:15:22Z",
      "status": "string",
      "summary": "string"
    }
  ],
  "truncated": true
}
```

<h3 id="operations-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[OperationResults](#schemaoperationresults)|

<aside class="success">
This operation does not require authentication
</aside>

## run

<a id="opIdrun"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /action/run \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /action/run HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "applications": [
    "string"
  ],
  "commands": "string",
  "execution-group": "string",
  "machines": [
    "string"
  ],
  "parallel": true,
  "timeout": 0,
  "units": [
    "string"
  ],
  "workload-context": true
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/action/run',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/action/run',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/action/run', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/action/run', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/action/run");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/action/run", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /action/run`

The commands specified on the machines identified through the list of machines, units and services.

> Body parameter

```json
{
  "applications": [
    "string"
  ],
  "commands": "string",
  "execution-group": "string",
  "machines": [
    "string"
  ],
  "parallel": true,
  "timeout": 0,
  "units": [
    "string"
  ],
  "workload-context": true
}
```

<h3 id="run-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[RunParams](#schemarunparams)|true|none|

> Example responses

> 200 Response

```json
{
  "actions": [
    {
      "action": {
        "execution-group": "string",
        "name": "string",
        "parallel": true,
        "parameters": {},
        "receiver": "string",
        "tag": "string"
      },
      "completed": "2019-08-24T14:15:22Z",
      "enqueued": "2019-08-24T14:15:22Z",
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "log": [
        {
          "message": "string",
          "timestamp": "2019-08-24T14:15:22Z"
        }
      ],
      "message": "string",
      "output": {},
      "started": "2019-08-24T14:15:22Z",
      "status": "string"
    }
  ],
  "operation": "string"
}
```

<h3 id="run-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[EnqueuedActions](#schemaenqueuedactions)|

<aside class="success">
This operation does not require authentication
</aside>

## runOnAllMachines

<a id="opIdrunOnAllMachines"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /action/runOnAllMachines \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /action/runOnAllMachines HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "applications": [
    "string"
  ],
  "commands": "string",
  "execution-group": "string",
  "machines": [
    "string"
  ],
  "parallel": true,
  "timeout": 0,
  "units": [
    "string"
  ],
  "workload-context": true
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/action/runOnAllMachines',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/action/runOnAllMachines',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/action/runOnAllMachines', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/action/runOnAllMachines', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/action/runOnAllMachines");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/action/runOnAllMachines", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /action/runOnAllMachines`

Attempts to run the specified command on all the machines.

> Body parameter

```json
{
  "applications": [
    "string"
  ],
  "commands": "string",
  "execution-group": "string",
  "machines": [
    "string"
  ],
  "parallel": true,
  "timeout": 0,
  "units": [
    "string"
  ],
  "workload-context": true
}
```

<h3 id="runonallmachines-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[RunParams](#schemarunparams)|true|none|

> Example responses

> 200 Response

```json
{
  "actions": [
    {
      "action": {
        "execution-group": "string",
        "name": "string",
        "parallel": true,
        "parameters": {},
        "receiver": "string",
        "tag": "string"
      },
      "completed": "2019-08-24T14:15:22Z",
      "enqueued": "2019-08-24T14:15:22Z",
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "log": [
        {
          "message": "string",
          "timestamp": "2019-08-24T14:15:22Z"
        }
      ],
      "message": "string",
      "output": {},
      "started": "2019-08-24T14:15:22Z",
      "status": "string"
    }
  ],
  "operation": "string"
}
```

<h3 id="runonallmachines-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[EnqueuedActions](#schemaenqueuedactions)|

<aside class="success">
This operation does not require authentication
</aside>

## watchActionsProgress

<a id="opIdwatchActionsProgress"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /action/watchActionsProgress \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /action/watchActionsProgress HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/action/watchActionsProgress',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/action/watchActionsProgress',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/action/watchActionsProgress', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/action/watchActionsProgress', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/action/watchActionsProgress");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/action/watchActionsProgress", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /action/watchActionsProgress`

Creates a watcher that reports on action log messages.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="watchactionsprogress-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "changes": [
        "string"
      ],
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "watcher-id": "string"
    }
  ]
}
```

<h3 id="watchactionsprogress-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[StringsWatchResults](#schemastringswatchresults)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-admin">admin</h1>

## login

<a id="opIdlogin"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /admin/login \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /admin/login HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "auth-tag": "string",
  "bakery-version": 0,
  "cli-args": "string",
  "client-version": "string",
  "credentials": "string",
  "macaroons": [
    [
      {}
    ]
  ],
  "nonce": "string",
  "user-data": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/admin/login',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/admin/login',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/admin/login', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/admin/login', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/admin/login");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/admin/login", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /admin/login`

Logs in with the provided credentials.  All subsequent requests on the connection will act as the authenticated user.

> Body parameter

```json
{
  "auth-tag": "string",
  "bakery-version": 0,
  "cli-args": "string",
  "client-version": "string",
  "credentials": "string",
  "macaroons": [
    [
      {}
    ]
  ],
  "nonce": "string",
  "user-data": "string"
}
```

<h3 id="login-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[LoginRequest](#schemaloginrequest)|true|none|

> Example responses

> 200 Response

```json
{
  "bakery-discharge-required": {},
  "controller-tag": "string",
  "discharge-required": {},
  "discharge-required-error": "string",
  "facades": [
    {
      "name": "string",
      "versions": [
        0
      ]
    }
  ],
  "model-tag": "string",
  "public-dns-name": "string",
  "server-version": "string",
  "servers": [
    [
      {
        "Address": {
          "cidr": "string",
          "config-type": "string",
          "is-secondary": true,
          "scope": "string",
          "space-id": "string",
          "space-name": "string",
          "type": "string",
          "value": "string"
        },
        "cidr": "string",
        "config-type": "string",
        "is-secondary": true,
        "port": 0,
        "scope": "string",
        "space-id": "string",
        "space-name": "string",
        "type": "string",
        "value": "string"
      }
    ]
  ],
  "user-info": {
    "controller-access": "string",
    "credentials": "string",
    "display-name": "string",
    "identity": "string",
    "last-connection": "2019-08-24T14:15:22Z",
    "model-access": "string"
  }
}
```

<h3 id="login-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[LoginResult](#schemaloginresult)|

<aside class="success">
This operation does not require authentication
</aside>

## redirectInfo

<a id="opIdredirectInfo"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /admin/redirectInfo \
  -H 'Accept: application/json'

```

```http
GET /admin/redirectInfo HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/admin/redirectInfo',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/admin/redirectInfo',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/admin/redirectInfo', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/admin/redirectInfo', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/admin/redirectInfo");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/admin/redirectInfo", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /admin/redirectInfo`

Returns redirected host information for the model. In Juju it always returns an error because the Juju controller does not multiplex controllers.

> Example responses

> 200 Response

```json
{
  "ca-cert": "string",
  "servers": [
    [
      {
        "Address": {
          "cidr": "string",
          "config-type": "string",
          "is-secondary": true,
          "scope": "string",
          "space-id": "string",
          "space-name": "string",
          "type": "string",
          "value": "string"
        },
        "cidr": "string",
        "config-type": "string",
        "is-secondary": true,
        "port": 0,
        "scope": "string",
        "space-id": "string",
        "space-name": "string",
        "type": "string",
        "value": "string"
      }
    ]
  ]
}
```

<h3 id="redirectinfo-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[RedirectInfoResult](#schemaredirectinforesult)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-allmodelwatcher">allmodelwatcher</h1>

## next

<a id="opIdnext"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /allmodelwatcher/next \
  -H 'Accept: application/json'

```

```http
GET /allmodelwatcher/next HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/allmodelwatcher/next',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/allmodelwatcher/next',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/allmodelwatcher/next', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/allmodelwatcher/next', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/allmodelwatcher/next");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/allmodelwatcher/next", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /allmodelwatcher/next`

Will return the current state of everything on the first call and subsequent calls will

> Example responses

> 200 Response

```json
{
  "deltas": [
    {
      "entity": {},
      "removed": true
    }
  ]
}
```

<h3 id="next-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[AllWatcherNextResults](#schemaallwatchernextresults)|

<aside class="success">
This operation does not require authentication
</aside>

## stop

<a id="opIdstop"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /allmodelwatcher/stop

```

```http
GET /allmodelwatcher/stop HTTP/1.1

```

```javascript

fetch('/allmodelwatcher/stop',
{
  method: 'GET'

})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

result = RestClient.get '/allmodelwatcher/stop',
  params: {
  }

p JSON.parse(result)

```

```python
import requests

r = requests.get('/allmodelwatcher/stop')

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/allmodelwatcher/stop', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/allmodelwatcher/stop");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/allmodelwatcher/stop", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /allmodelwatcher/stop`

Stops the watcher.

<h3 id="stop-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-allwatcher">allwatcher</h1>

## next

<a id="opIdnext"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /allwatcher/next \
  -H 'Accept: application/json'

```

```http
GET /allwatcher/next HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/allwatcher/next',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/allwatcher/next',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/allwatcher/next', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/allwatcher/next', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/allwatcher/next");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/allwatcher/next", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /allwatcher/next`

Will return the current state of everything on the first call and subsequent calls will

> Example responses

> 200 Response

```json
{
  "deltas": [
    {
      "entity": {},
      "removed": true
    }
  ]
}
```

<h3 id="next-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[AllWatcherNextResults](#schemaallwatchernextresults)|

<aside class="success">
This operation does not require authentication
</aside>

## stop

<a id="opIdstop"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /allwatcher/stop

```

```http
GET /allwatcher/stop HTTP/1.1

```

```javascript

fetch('/allwatcher/stop',
{
  method: 'GET'

})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

result = RestClient.get '/allwatcher/stop',
  params: {
  }

p JSON.parse(result)

```

```python
import requests

r = requests.get('/allwatcher/stop')

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/allwatcher/stop', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/allwatcher/stop");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/allwatcher/stop", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /allwatcher/stop`

Stops the watcher.

<h3 id="stop-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-annotations">annotations</h1>

## get

<a id="opIdget"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /annotations/get \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /annotations/get HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/annotations/get',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/annotations/get',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/annotations/get', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/annotations/get', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/annotations/get");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/annotations/get", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /annotations/get`

Returns annotations for given entities. If annotations cannot be retrieved for a given entity, an error is returned. Each entity is treated independently and, hence, will fail or succeed independently.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="get-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "annotations": {},
      "entity": "string",
      "error": {
        "error": {
          "code": "string",
          "info": {},
          "message": "string"
        }
      }
    }
  ]
}
```

<h3 id="get-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[AnnotationsGetResults](#schemaannotationsgetresults)|

<aside class="success">
This operation does not require authentication
</aside>

## set

<a id="opIdset"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /annotations/set \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /annotations/set HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "annotations": [
    {
      "annotations": {},
      "entity": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/annotations/set',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/annotations/set',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/annotations/set', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/annotations/set', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/annotations/set");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/annotations/set", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /annotations/set`

Stores annotations for given entities

> Body parameter

```json
{
  "annotations": [
    {
      "annotations": {},
      "entity": "string"
    }
  ]
}
```

<h3 id="set-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[AnnotationsSet](#schemaannotationsset)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="set-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-application">application</h1>

## addRelation

<a id="opIdaddRelation"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/addRelation \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /application/addRelation HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "endpoints": [
    "string"
  ],
  "via-cidrs": [
    "string"
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/application/addRelation',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/application/addRelation',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/application/addRelation', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/addRelation', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/addRelation");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/addRelation", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/addRelation`

Adds a relation between the specified endpoints and returns the relation info.

> Body parameter

```json
{
  "endpoints": [
    "string"
  ],
  "via-cidrs": [
    "string"
  ]
}
```

<h3 id="addrelation-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[AddRelation](#schemaaddrelation)|true|none|

> Example responses

> 200 Response

```json
{
  "endpoints": {}
}
```

<h3 id="addrelation-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[AddRelationResults](#schemaaddrelationresults)|

<aside class="success">
This operation does not require authentication
</aside>

## addUnits

<a id="opIdaddUnits"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/addUnits \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /application/addUnits HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "application": "string",
  "attach-storage": [
    "string"
  ],
  "num-units": 0,
  "placement": [
    {
      "directive": "string",
      "scope": "string"
    }
  ],
  "policy": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/application/addUnits',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/application/addUnits',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/application/addUnits', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/addUnits', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/addUnits");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/addUnits", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/addUnits`

Adds a given number of units to an application.

> Body parameter

```json
{
  "application": "string",
  "attach-storage": [
    "string"
  ],
  "num-units": 0,
  "placement": [
    {
      "directive": "string",
      "scope": "string"
    }
  ],
  "policy": "string"
}
```

<h3 id="addunits-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[AddApplicationUnits](#schemaaddapplicationunits)|true|none|

> Example responses

> 200 Response

```json
{
  "units": [
    "string"
  ]
}
```

<h3 id="addunits-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[AddApplicationUnitsResults](#schemaaddapplicationunitsresults)|

<aside class="success">
This operation does not require authentication
</aside>

## applicationsInfo

<a id="opIdapplicationsInfo"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/applicationsInfo \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /application/applicationsInfo HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/application/applicationsInfo',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/application/applicationsInfo',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/application/applicationsInfo', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/applicationsInfo', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/applicationsInfo");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/applicationsInfo", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/applicationsInfo`

Returns applications information.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="applicationsinfo-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "base": {
          "channel": "string",
          "name": "string"
        },
        "channel": "string",
        "charm": "string",
        "constraints": {
          "allocate-public-ip": true,
          "arch": "string",
          "container": "string",
          "cores": 0,
          "cpu-power": 0,
          "image-id": "string",
          "instance-role": "string",
          "instance-type": "string",
          "mem": 0,
          "root-disk": 0,
          "root-disk-source": "string",
          "spaces": [
            "string"
          ],
          "tags": [
            "string"
          ],
          "virt-type": "string",
          "zones": [
            "string"
          ]
        },
        "endpoint-bindings": {},
        "exposed": true,
        "exposed-endpoints": {},
        "life": "string",
        "principal": true,
        "remote": true,
        "tag": "string"
      }
    }
  ]
}
```

<h3 id="applicationsinfo-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ApplicationInfoResults](#schemaapplicationinforesults)|

<aside class="success">
This operation does not require authentication
</aside>

## charmConfig

<a id="opIdcharmConfig"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/charmConfig \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /application/charmConfig HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "args": [
    {
      "application": "string",
      "branch": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/application/charmConfig',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/application/charmConfig',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/application/charmConfig', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/charmConfig', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/charmConfig");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/charmConfig", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/charmConfig`

Returns charm config for the input list of applications and model generations.

> Body parameter

```json
{
  "args": [
    {
      "application": "string",
      "branch": "string"
    }
  ]
}
```

<h3 id="charmconfig-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ApplicationGetArgs](#schemaapplicationgetargs)|true|none|

> Example responses

> 200 Response

```json
{
  "Results": [
    {
      "config": {},
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="charmconfig-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ApplicationGetConfigResults](#schemaapplicationgetconfigresults)|

<aside class="success">
This operation does not require authentication
</aside>

## charmRelations

<a id="opIdcharmRelations"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/charmRelations \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /application/charmRelations HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "application": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/application/charmRelations',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/application/charmRelations',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/application/charmRelations', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/charmRelations', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/charmRelations");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/charmRelations", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/charmRelations`

Implements the server side of Application.CharmRelations.

> Body parameter

```json
{
  "application": "string"
}
```

<h3 id="charmrelations-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ApplicationCharmRelations](#schemaapplicationcharmrelations)|true|none|

> Example responses

> 200 Response

```json
{
  "charm-relations": [
    "string"
  ]
}
```

<h3 id="charmrelations-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ApplicationCharmRelationsResults](#schemaapplicationcharmrelationsresults)|

<aside class="success">
This operation does not require authentication
</aside>

## consume

<a id="opIdconsume"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/consume \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /application/consume HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "args": [
    {
      "ApplicationOfferDetails": {
        "application-description": "string",
        "bindings": {},
        "endpoints": [
          {
            "interface": "string",
            "limit": 0,
            "name": "string",
            "role": "string"
          }
        ],
        "offer-name": "string",
        "offer-url": "string",
        "offer-uuid": "string",
        "source-model-tag": "string",
        "spaces": [
          {
            "cloud-type": "string",
            "name": "string",
            "provider-attributes": {},
            "provider-id": "string",
            "subnets": [
              {
                "cidr": "string",
                "life": "string",
                "provider-id": "string",
                "provider-network-id": "string",
                "provider-space-id": "string",
                "space-tag": "string",
                "status": "string",
                "vlan-tag": 0,
                "zones": [
                  "string"
                ]
              }
            ]
          }
        ],
        "users": [
          {
            "access": "string",
            "display-name": "string",
            "user": "string"
          }
        ]
      },
      "application-alias": "string",
      "application-description": "string",
      "bindings": {},
      "endpoints": [
        {
          "interface": "string",
          "limit": 0,
          "name": "string",
          "role": "string"
        }
      ],
      "external-controller": {
        "addrs": [
          "string"
        ],
        "ca-cert": "string",
        "controller-alias": "string",
        "controller-tag": "string"
      },
      "macaroon": {},
      "offer-name": "string",
      "offer-url": "string",
      "offer-uuid": "string",
      "source-model-tag": "string",
      "spaces": [
        {
          "cloud-type": "string",
          "name": "string",
          "provider-attributes": {},
          "provider-id": "string",
          "subnets": [
            {
              "cidr": "string",
              "life": "string",
              "provider-id": "string",
              "provider-network-id": "string",
              "provider-space-id": "string",
              "space-tag": "string",
              "status": "string",
              "vlan-tag": 0,
              "zones": [
                "string"
              ]
            }
          ]
        }
      ],
      "users": [
        {
          "access": "string",
          "display-name": "string",
          "user": "string"
        }
      ]
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/application/consume',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/application/consume',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/application/consume', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/consume', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/consume");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/consume", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/consume`

Adds remote applications to the model without creating any relations.

> Body parameter

```json
{
  "args": [
    {
      "ApplicationOfferDetails": {
        "application-description": "string",
        "bindings": {},
        "endpoints": [
          {
            "interface": "string",
            "limit": 0,
            "name": "string",
            "role": "string"
          }
        ],
        "offer-name": "string",
        "offer-url": "string",
        "offer-uuid": "string",
        "source-model-tag": "string",
        "spaces": [
          {
            "cloud-type": "string",
            "name": "string",
            "provider-attributes": {},
            "provider-id": "string",
            "subnets": [
              {
                "cidr": "string",
                "life": "string",
                "provider-id": "string",
                "provider-network-id": "string",
                "provider-space-id": "string",
                "space-tag": "string",
                "status": "string",
                "vlan-tag": 0,
                "zones": [
                  "string"
                ]
              }
            ]
          }
        ],
        "users": [
          {
            "access": "string",
            "display-name": "string",
            "user": "string"
          }
        ]
      },
      "application-alias": "string",
      "application-description": "string",
      "bindings": {},
      "endpoints": [
        {
          "interface": "string",
          "limit": 0,
          "name": "string",
          "role": "string"
        }
      ],
      "external-controller": {
        "addrs": [
          "string"
        ],
        "ca-cert": "string",
        "controller-alias": "string",
        "controller-tag": "string"
      },
      "macaroon": {},
      "offer-name": "string",
      "offer-url": "string",
      "offer-uuid": "string",
      "source-model-tag": "string",
      "spaces": [
        {
          "cloud-type": "string",
          "name": "string",
          "provider-attributes": {},
          "provider-id": "string",
          "subnets": [
            {
              "cidr": "string",
              "life": "string",
              "provider-id": "string",
              "provider-network-id": "string",
              "provider-space-id": "string",
              "space-tag": "string",
              "status": "string",
              "vlan-tag": 0,
              "zones": [
                "string"
              ]
            }
          ]
        }
      ],
      "users": [
        {
          "access": "string",
          "display-name": "string",
          "user": "string"
        }
      ]
    }
  ]
}
```

<h3 id="consume-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ConsumeApplicationArgs](#schemaconsumeapplicationargs)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="consume-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## deploy

<a id="opIddeploy"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/deploy \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /application/deploy HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "applications": [
    {
      "Force": true,
      "application": "string",
      "attach-storage": [
        "string"
      ],
      "channel": "string",
      "charm-origin": {
        "architecture": "string",
        "base": {
          "channel": "string",
          "name": "string"
        },
        "branch": "string",
        "hash": "string",
        "id": "string",
        "instance-key": "string",
        "revision": 0,
        "risk": "string",
        "source": "string",
        "track": "string",
        "type": "string"
      },
      "charm-url": "string",
      "config": {},
      "config-yaml": "string",
      "constraints": {
        "allocate-public-ip": true,
        "arch": "string",
        "container": "string",
        "cores": 0,
        "cpu-power": 0,
        "image-id": "string",
        "instance-role": "string",
        "instance-type": "string",
        "mem": 0,
        "root-disk": 0,
        "root-disk-source": "string",
        "spaces": [
          "string"
        ],
        "tags": [
          "string"
        ],
        "virt-type": "string",
        "zones": [
          "string"
        ]
      },
      "devices": {},
      "endpoint-bindings": {},
      "num-units": 0,
      "placement": [
        {
          "directive": "string",
          "scope": "string"
        }
      ],
      "policy": "string",
      "resources": {},
      "storage": {}
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/application/deploy',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/application/deploy',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/application/deploy', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/deploy', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/deploy");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/deploy", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/deploy`

Fetches the charms from the charm store and deploys them using the specified placement directives.

> Body parameter

```json
{
  "applications": [
    {
      "Force": true,
      "application": "string",
      "attach-storage": [
        "string"
      ],
      "channel": "string",
      "charm-origin": {
        "architecture": "string",
        "base": {
          "channel": "string",
          "name": "string"
        },
        "branch": "string",
        "hash": "string",
        "id": "string",
        "instance-key": "string",
        "revision": 0,
        "risk": "string",
        "source": "string",
        "track": "string",
        "type": "string"
      },
      "charm-url": "string",
      "config": {},
      "config-yaml": "string",
      "constraints": {
        "allocate-public-ip": true,
        "arch": "string",
        "container": "string",
        "cores": 0,
        "cpu-power": 0,
        "image-id": "string",
        "instance-role": "string",
        "instance-type": "string",
        "mem": 0,
        "root-disk": 0,
        "root-disk-source": "string",
        "spaces": [
          "string"
        ],
        "tags": [
          "string"
        ],
        "virt-type": "string",
        "zones": [
          "string"
        ]
      },
      "devices": {},
      "endpoint-bindings": {},
      "num-units": 0,
      "placement": [
        {
          "directive": "string",
          "scope": "string"
        }
      ],
      "policy": "string",
      "resources": {},
      "storage": {}
    }
  ]
}
```

<h3 id="deploy-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ApplicationsDeploy](#schemaapplicationsdeploy)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="deploy-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## deployFromRepository

<a id="opIddeployFromRepository"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/deployFromRepository \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /application/deployFromRepository HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "Args": [
    {
      "ApplicationName": "string",
      "AttachStorage": [
        "string"
      ],
      "CharmName": "string",
      "ConfigYAML": "string",
      "Cons": {
        "allocate-public-ip": true,
        "arch": "string",
        "container": "string",
        "cores": 0,
        "cpu-power": 0,
        "image-id": "string",
        "instance-role": "string",
        "instance-type": "string",
        "mem": 0,
        "root-disk": 0,
        "root-disk-source": "string",
        "spaces": [
          "string"
        ],
        "tags": [
          "string"
        ],
        "virt-type": "string",
        "zones": [
          "string"
        ]
      },
      "Devices": {},
      "DryRun": true,
      "Placement": [
        {
          "directive": "string",
          "scope": "string"
        }
      ],
      "Storage": {},
      "Trust": true,
      "base": {
        "channel": "string",
        "name": "string"
      },
      "channel": "string",
      "endpoint-bindings": {},
      "force": true,
      "num-units": 0,
      "resources": {},
      "revision": 0
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/application/deployFromRepository',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/application/deployFromRepository',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/application/deployFromRepository', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/deployFromRepository', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/deployFromRepository");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/deployFromRepository", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/deployFromRepository`

Is a one-stop deployment method for repository charms. Only a charm name is required to deploy. If argument validation fails, a list of all errors found in validation will be returned. If a local resource is provided, details required for uploading the validated resource will be returned.

> Body parameter

```json
{
  "Args": [
    {
      "ApplicationName": "string",
      "AttachStorage": [
        "string"
      ],
      "CharmName": "string",
      "ConfigYAML": "string",
      "Cons": {
        "allocate-public-ip": true,
        "arch": "string",
        "container": "string",
        "cores": 0,
        "cpu-power": 0,
        "image-id": "string",
        "instance-role": "string",
        "instance-type": "string",
        "mem": 0,
        "root-disk": 0,
        "root-disk-source": "string",
        "spaces": [
          "string"
        ],
        "tags": [
          "string"
        ],
        "virt-type": "string",
        "zones": [
          "string"
        ]
      },
      "Devices": {},
      "DryRun": true,
      "Placement": [
        {
          "directive": "string",
          "scope": "string"
        }
      ],
      "Storage": {},
      "Trust": true,
      "base": {
        "channel": "string",
        "name": "string"
      },
      "channel": "string",
      "endpoint-bindings": {},
      "force": true,
      "num-units": 0,
      "resources": {},
      "revision": 0
    }
  ]
}
```

<h3 id="deployfromrepository-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[DeployFromRepositoryArgs](#schemadeployfromrepositoryargs)|true|none|

> Example responses

> 200 Response

```json
{
  "Results": [
    {
      "Errors": [
        {
          "code": "string",
          "info": {},
          "message": "string"
        }
      ],
      "Info": {
        "architecture": "string",
        "base": {
          "channel": "string",
          "name": "string"
        },
        "channel": "string",
        "charm-url": "string",
        "effective-channel": "string"
      },
      "PendingResourceUploads": [
        {
          "Filename": "string",
          "Name": "string",
          "Type": "string",
          "pending-id": "string"
        }
      ]
    }
  ]
}
```

<h3 id="deployfromrepository-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[DeployFromRepositoryResults](#schemadeployfromrepositoryresults)|

<aside class="success">
This operation does not require authentication
</aside>

## destroyApplication

<a id="opIddestroyApplication"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/destroyApplication \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /application/destroyApplication HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "applications": [
    {
      "application-tag": "string",
      "destroy-storage": true,
      "dry-run": true,
      "force": true,
      "max-wait": 0
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/application/destroyApplication',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/application/destroyApplication',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/application/destroyApplication', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/destroyApplication', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/destroyApplication");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/destroyApplication", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/destroyApplication`

Removes a given set of applications.

> Body parameter

```json
{
  "applications": [
    {
      "application-tag": "string",
      "destroy-storage": true,
      "dry-run": true,
      "force": true,
      "max-wait": 0
    }
  ]
}
```

<h3 id="destroyapplication-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[DestroyApplicationsParams](#schemadestroyapplicationsparams)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "info": {
        "destroyed-storage": [
          {
            "tag": "string"
          }
        ],
        "destroyed-units": [
          {
            "tag": "string"
          }
        ],
        "detached-storage": [
          {
            "tag": "string"
          }
        ]
      }
    }
  ]
}
```

<h3 id="destroyapplication-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[DestroyApplicationResults](#schemadestroyapplicationresults)|

<aside class="success">
This operation does not require authentication
</aside>

## destroyConsumedApplications

<a id="opIddestroyConsumedApplications"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/destroyConsumedApplications \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /application/destroyConsumedApplications HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "applications": [
    {
      "application-tag": "string",
      "force": true,
      "max-wait": 0
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/application/destroyConsumedApplications',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/application/destroyConsumedApplications',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/application/destroyConsumedApplications', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/destroyConsumedApplications', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/destroyConsumedApplications");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/destroyConsumedApplications", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/destroyConsumedApplications`

Removes a given set of consumed (remote) applications.

> Body parameter

```json
{
  "applications": [
    {
      "application-tag": "string",
      "force": true,
      "max-wait": 0
    }
  ]
}
```

<h3 id="destroyconsumedapplications-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[DestroyConsumedApplicationsParams](#schemadestroyconsumedapplicationsparams)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="destroyconsumedapplications-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## destroyRelation

<a id="opIddestroyRelation"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/destroyRelation \
  -H 'Content-Type: application/json'

```

```http
GET /application/destroyRelation HTTP/1.1

Content-Type: application/json

```

```javascript
const inputBody = '{
  "endpoints": [
    "string"
  ],
  "force": true,
  "max-wait": 0,
  "relation-id": 0
}';
const headers = {
  'Content-Type':'application/json'
};

fetch('/application/destroyRelation',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json'
}

result = RestClient.get '/application/destroyRelation',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json'
}

r = requests.get('/application/destroyRelation', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/destroyRelation', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/destroyRelation");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/destroyRelation", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/destroyRelation`

Removes the relation between the specified endpoints or an id.

> Body parameter

```json
{
  "endpoints": [
    "string"
  ],
  "force": true,
  "max-wait": 0,
  "relation-id": 0
}
```

<h3 id="destroyrelation-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[DestroyRelation](#schemadestroyrelation)|true|none|

<h3 id="destroyrelation-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|

<aside class="success">
This operation does not require authentication
</aside>

## destroyUnit

<a id="opIddestroyUnit"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/destroyUnit \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /application/destroyUnit HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "units": [
    {
      "destroy-storage": true,
      "dry-run": true,
      "force": true,
      "max-wait": 0,
      "unit-tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/application/destroyUnit',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/application/destroyUnit',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/application/destroyUnit', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/destroyUnit', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/destroyUnit");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/destroyUnit", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/destroyUnit`

Removes a given set of application units.

> Body parameter

```json
{
  "units": [
    {
      "destroy-storage": true,
      "dry-run": true,
      "force": true,
      "max-wait": 0,
      "unit-tag": "string"
    }
  ]
}
```

<h3 id="destroyunit-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[DestroyUnitsParams](#schemadestroyunitsparams)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "info": {
        "destroyed-storage": [
          {
            "tag": "string"
          }
        ],
        "detached-storage": [
          {
            "tag": "string"
          }
        ]
      }
    }
  ]
}
```

<h3 id="destroyunit-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[DestroyUnitResults](#schemadestroyunitresults)|

<aside class="success">
This operation does not require authentication
</aside>

## expose

<a id="opIdexpose"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/expose \
  -H 'Content-Type: application/json'

```

```http
GET /application/expose HTTP/1.1

Content-Type: application/json

```

```javascript
const inputBody = '{
  "application": "string",
  "exposed-endpoints": {}
}';
const headers = {
  'Content-Type':'application/json'
};

fetch('/application/expose',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json'
}

result = RestClient.get '/application/expose',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json'
}

r = requests.get('/application/expose', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/expose', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/expose");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/expose", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/expose`

Changes the juju-managed firewall to expose any ports that were also explicitly marked by units as open.

> Body parameter

```json
{
  "application": "string",
  "exposed-endpoints": {}
}
```

<h3 id="expose-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ApplicationExpose](#schemaapplicationexpose)|true|none|

<h3 id="expose-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|

<aside class="success">
This operation does not require authentication
</aside>

## get

<a id="opIdget"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/get \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /application/get HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "application": "string",
  "branch": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/application/get',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/application/get',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/application/get', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/get', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/get");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/get", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/get`

Returns the charm configuration for an application.

> Body parameter

```json
{
  "application": "string",
  "branch": "string"
}
```

<h3 id="get-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ApplicationGet](#schemaapplicationget)|true|none|

> Example responses

> 200 Response

```json
{
  "application": "string",
  "application-config": {},
  "base": {
    "channel": "string",
    "name": "string"
  },
  "channel": "string",
  "charm": "string",
  "config": {},
  "constraints": {
    "allocate-public-ip": true,
    "arch": "string",
    "container": "string",
    "cores": 0,
    "cpu-power": 0,
    "image-id": "string",
    "instance-role": "string",
    "instance-type": "string",
    "mem": 0,
    "root-disk": 0,
    "root-disk-source": "string",
    "spaces": [
      "string"
    ],
    "tags": [
      "string"
    ],
    "virt-type": "string",
    "zones": [
      "string"
    ]
  },
  "endpoint-bindings": {}
}
```

<h3 id="get-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ApplicationGetResults](#schemaapplicationgetresults)|

<aside class="success">
This operation does not require authentication
</aside>

## getCharmURLOrigin

<a id="opIdgetCharmURLOrigin"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/getCharmURLOrigin \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /application/getCharmURLOrigin HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "application": "string",
  "branch": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/application/getCharmURLOrigin',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/application/getCharmURLOrigin',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/application/getCharmURLOrigin', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/getCharmURLOrigin', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/getCharmURLOrigin");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/getCharmURLOrigin", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/getCharmURLOrigin`

Returns the charm URL and charm origin the given application is running at present.

> Body parameter

```json
{
  "application": "string",
  "branch": "string"
}
```

<h3 id="getcharmurlorigin-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ApplicationGet](#schemaapplicationget)|true|none|

> Example responses

> 200 Response

```json
{
  "charm-origin": {
    "architecture": "string",
    "base": {
      "channel": "string",
      "name": "string"
    },
    "branch": "string",
    "hash": "string",
    "id": "string",
    "instance-key": "string",
    "revision": 0,
    "risk": "string",
    "source": "string",
    "track": "string",
    "type": "string"
  },
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "url": "string"
}
```

<h3 id="getcharmurlorigin-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[CharmURLOriginResult](#schemacharmurloriginresult)|

<aside class="success">
This operation does not require authentication
</aside>

## getConfig

<a id="opIdgetConfig"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/getConfig \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /application/getConfig HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/application/getConfig',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/application/getConfig',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/application/getConfig', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/getConfig', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/getConfig");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/getConfig", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/getConfig`

Returns the charm config for each of the input applications.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="getconfig-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "Results": [
    {
      "config": {},
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="getconfig-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ApplicationGetConfigResults](#schemaapplicationgetconfigresults)|

<aside class="success">
This operation does not require authentication
</aside>

## getConstraints

<a id="opIdgetConstraints"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/getConstraints \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /application/getConstraints HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/application/getConstraints',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/application/getConstraints',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/application/getConstraints', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/getConstraints', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/getConstraints");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/getConstraints", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/getConstraints`

Returns the constraints for a given application.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="getconstraints-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "constraints": {
        "allocate-public-ip": true,
        "arch": "string",
        "container": "string",
        "cores": 0,
        "cpu-power": 0,
        "image-id": "string",
        "instance-role": "string",
        "instance-type": "string",
        "mem": 0,
        "root-disk": 0,
        "root-disk-source": "string",
        "spaces": [
          "string"
        ],
        "tags": [
          "string"
        ],
        "virt-type": "string",
        "zones": [
          "string"
        ]
      },
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="getconstraints-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ApplicationGetConstraintsResults](#schemaapplicationgetconstraintsresults)|

<aside class="success">
This operation does not require authentication
</aside>

## leader

<a id="opIdleader"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/leader \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /application/leader HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "tag": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/application/leader',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/application/leader',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/application/leader', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/leader', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/leader");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/leader", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/leader`

Returns the unit name of the leader for the given application.

> Body parameter

```json
{
  "tag": "string"
}
```

<h3 id="leader-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entity](#schemaentity)|true|none|

> Example responses

> 200 Response

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": "string"
}
```

<h3 id="leader-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[StringResult](#schemastringresult)|

<aside class="success">
This operation does not require authentication
</aside>

## mergeBindings

<a id="opIdmergeBindings"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/mergeBindings \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /application/mergeBindings HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "args": [
    {
      "application-tag": "string",
      "bindings": {},
      "force": true
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/application/mergeBindings',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/application/mergeBindings',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/application/mergeBindings', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/mergeBindings', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/mergeBindings");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/mergeBindings", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/mergeBindings`

Merges operator-defined bindings with the current bindings for one or more applications.

> Body parameter

```json
{
  "args": [
    {
      "application-tag": "string",
      "bindings": {},
      "force": true
    }
  ]
}
```

<h3 id="mergebindings-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ApplicationMergeBindingsArgs](#schemaapplicationmergebindingsargs)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="mergebindings-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## resolveUnitErrors

<a id="opIdresolveUnitErrors"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/resolveUnitErrors \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /application/resolveUnitErrors HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "all": true,
  "retry": true,
  "tags": {
    "entities": [
      {
        "tag": "string"
      }
    ]
  }
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/application/resolveUnitErrors',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/application/resolveUnitErrors',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/application/resolveUnitErrors', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/resolveUnitErrors', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/resolveUnitErrors");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/resolveUnitErrors", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/resolveUnitErrors`

Marks errors on the specified units as resolved.

> Body parameter

```json
{
  "all": true,
  "retry": true,
  "tags": {
    "entities": [
      {
        "tag": "string"
      }
    ]
  }
}
```

<h3 id="resolveuniterrors-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[UnitsResolved](#schemaunitsresolved)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="resolveuniterrors-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## scaleApplications

<a id="opIdscaleApplications"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/scaleApplications \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /application/scaleApplications HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "applications": [
    {
      "application-tag": "string",
      "force": true,
      "scale": 0,
      "scale-change": 0
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/application/scaleApplications',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/application/scaleApplications',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/application/scaleApplications', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/scaleApplications', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/scaleApplications");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/scaleApplications", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/scaleApplications`

Scales the specified application to the requested number of units.

> Body parameter

```json
{
  "applications": [
    {
      "application-tag": "string",
      "force": true,
      "scale": 0,
      "scale-change": 0
    }
  ]
}
```

<h3 id="scaleapplications-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ScaleApplicationsParams](#schemascaleapplicationsparams)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "info": {
        "num-units": 0
      }
    }
  ]
}
```

<h3 id="scaleapplications-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ScaleApplicationResults](#schemascaleapplicationresults)|

<aside class="success">
This operation does not require authentication
</aside>

## setCharm

<a id="opIdsetCharm"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/setCharm \
  -H 'Content-Type: application/json'

```

```http
GET /application/setCharm HTTP/1.1

Content-Type: application/json

```

```javascript
const inputBody = '{
  "application": "string",
  "channel": "string",
  "charm-origin": {
    "architecture": "string",
    "base": {
      "channel": "string",
      "name": "string"
    },
    "branch": "string",
    "hash": "string",
    "id": "string",
    "instance-key": "string",
    "revision": 0,
    "risk": "string",
    "source": "string",
    "track": "string",
    "type": "string"
  },
  "charm-url": "string",
  "config-settings": {},
  "config-settings-yaml": "string",
  "endpoint-bindings": {},
  "force": true,
  "force-base": true,
  "force-units": true,
  "generation": "string",
  "resource-ids": {},
  "storage-constraints": {}
}';
const headers = {
  'Content-Type':'application/json'
};

fetch('/application/setCharm',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json'
}

result = RestClient.get '/application/setCharm',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json'
}

r = requests.get('/application/setCharm', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/setCharm', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/setCharm");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/setCharm", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/setCharm`

Sets the charm for a given for the application.

> Body parameter

```json
{
  "application": "string",
  "channel": "string",
  "charm-origin": {
    "architecture": "string",
    "base": {
      "channel": "string",
      "name": "string"
    },
    "branch": "string",
    "hash": "string",
    "id": "string",
    "instance-key": "string",
    "revision": 0,
    "risk": "string",
    "source": "string",
    "track": "string",
    "type": "string"
  },
  "charm-url": "string",
  "config-settings": {},
  "config-settings-yaml": "string",
  "endpoint-bindings": {},
  "force": true,
  "force-base": true,
  "force-units": true,
  "generation": "string",
  "resource-ids": {},
  "storage-constraints": {}
}
```

<h3 id="setcharm-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ApplicationSetCharm](#schemaapplicationsetcharm)|true|none|

<h3 id="setcharm-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|

<aside class="success">
This operation does not require authentication
</aside>

## setConfigs

<a id="opIdsetConfigs"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/setConfigs \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /application/setConfigs HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "Args": [
    {
      "application": "string",
      "config": {},
      "config-yaml": "string",
      "generation": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/application/setConfigs',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/application/setConfigs',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/application/setConfigs', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/setConfigs', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/setConfigs");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/setConfigs", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/setConfigs`

Implements the server side of Application.SetConfig.  Both application and charm config are set. It does not unset values in Config map that are set to an empty string. Unset should be used for that.

> Body parameter

```json
{
  "Args": [
    {
      "application": "string",
      "config": {},
      "config-yaml": "string",
      "generation": "string"
    }
  ]
}
```

<h3 id="setconfigs-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ConfigSetArgs](#schemaconfigsetargs)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="setconfigs-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## setConstraints

<a id="opIdsetConstraints"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/setConstraints \
  -H 'Content-Type: application/json'

```

```http
GET /application/setConstraints HTTP/1.1

Content-Type: application/json

```

```javascript
const inputBody = '{
  "application": "string",
  "constraints": {
    "allocate-public-ip": true,
    "arch": "string",
    "container": "string",
    "cores": 0,
    "cpu-power": 0,
    "image-id": "string",
    "instance-role": "string",
    "instance-type": "string",
    "mem": 0,
    "root-disk": 0,
    "root-disk-source": "string",
    "spaces": [
      "string"
    ],
    "tags": [
      "string"
    ],
    "virt-type": "string",
    "zones": [
      "string"
    ]
  }
}';
const headers = {
  'Content-Type':'application/json'
};

fetch('/application/setConstraints',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json'
}

result = RestClient.get '/application/setConstraints',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json'
}

r = requests.get('/application/setConstraints', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/setConstraints', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/setConstraints");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/setConstraints", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/setConstraints`

Sets the constraints for a given application.

> Body parameter

```json
{
  "application": "string",
  "constraints": {
    "allocate-public-ip": true,
    "arch": "string",
    "container": "string",
    "cores": 0,
    "cpu-power": 0,
    "image-id": "string",
    "instance-role": "string",
    "instance-type": "string",
    "mem": 0,
    "root-disk": 0,
    "root-disk-source": "string",
    "spaces": [
      "string"
    ],
    "tags": [
      "string"
    ],
    "virt-type": "string",
    "zones": [
      "string"
    ]
  }
}
```

<h3 id="setconstraints-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[SetConstraints](#schemasetconstraints)|true|none|

<h3 id="setconstraints-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|

<aside class="success">
This operation does not require authentication
</aside>

## setMetricCredentials

<a id="opIdsetMetricCredentials"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/setMetricCredentials \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /application/setMetricCredentials HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "creds": [
    {
      "application": "string",
      "metrics-credentials": [
        0
      ]
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/application/setMetricCredentials',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/application/setMetricCredentials',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/application/setMetricCredentials', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/setMetricCredentials', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/setMetricCredentials");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/setMetricCredentials", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/setMetricCredentials`

Sets credentials on the application.

> Body parameter

```json
{
  "creds": [
    {
      "application": "string",
      "metrics-credentials": [
        0
      ]
    }
  ]
}
```

<h3 id="setmetriccredentials-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ApplicationMetricCredentials](#schemaapplicationmetriccredentials)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="setmetriccredentials-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## setRelationsSuspended

<a id="opIdsetRelationsSuspended"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/setRelationsSuspended \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /application/setRelationsSuspended HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "args": [
    {
      "message": "string",
      "relation-id": 0,
      "suspended": true
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/application/setRelationsSuspended',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/application/setRelationsSuspended',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/application/setRelationsSuspended', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/setRelationsSuspended', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/setRelationsSuspended");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/setRelationsSuspended", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/setRelationsSuspended`

Sets the suspended status of the specified relations.

> Body parameter

```json
{
  "args": [
    {
      "message": "string",
      "relation-id": 0,
      "suspended": true
    }
  ]
}
```

<h3 id="setrelationssuspended-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[RelationSuspendedArgs](#schemarelationsuspendedargs)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="setrelationssuspended-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## unexpose

<a id="opIdunexpose"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/unexpose \
  -H 'Content-Type: application/json'

```

```http
GET /application/unexpose HTTP/1.1

Content-Type: application/json

```

```javascript
const inputBody = '{
  "application": "string",
  "exposed-endpoints": [
    "string"
  ]
}';
const headers = {
  'Content-Type':'application/json'
};

fetch('/application/unexpose',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json'
}

result = RestClient.get '/application/unexpose',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json'
}

r = requests.get('/application/unexpose', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/unexpose', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/unexpose");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/unexpose", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/unexpose`

Changes the juju-managed firewall to unexpose any ports that were also explicitly marked by units as open.

> Body parameter

```json
{
  "application": "string",
  "exposed-endpoints": [
    "string"
  ]
}
```

<h3 id="unexpose-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ApplicationUnexpose](#schemaapplicationunexpose)|true|none|

<h3 id="unexpose-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|

<aside class="success">
This operation does not require authentication
</aside>

## unitsInfo

<a id="opIdunitsInfo"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/unitsInfo \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /application/unitsInfo HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/application/unitsInfo',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/application/unitsInfo',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/application/unitsInfo', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/unitsInfo', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/unitsInfo");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/unitsInfo", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/unitsInfo`

Returns unit information for the given entities (units or applications).

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="unitsinfo-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "address": "string",
        "charm": "string",
        "leader": true,
        "life": "string",
        "machine": "string",
        "opened-ports": [
          "string"
        ],
        "provider-id": "string",
        "public-address": "string",
        "relation-data": [
          {
            "ApplicationData": {},
            "cross-model": true,
            "endpoint": "string",
            "related-endpoint": "string",
            "relation-id": 0,
            "unit-relation-data": {}
          }
        ],
        "tag": "string",
        "workload-version": "string"
      }
    }
  ]
}
```

<h3 id="unitsinfo-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[UnitInfoResults](#schemaunitinforesults)|

<aside class="success">
This operation does not require authentication
</aside>

## unsetApplicationsConfig

<a id="opIdunsetApplicationsConfig"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/unsetApplicationsConfig \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /application/unsetApplicationsConfig HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "Args": [
    {
      "application": "string",
      "branch": "string",
      "options": [
        "string"
      ]
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/application/unsetApplicationsConfig',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/application/unsetApplicationsConfig',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/application/unsetApplicationsConfig', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/unsetApplicationsConfig', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/unsetApplicationsConfig");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/unsetApplicationsConfig", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/unsetApplicationsConfig`

Implements the server side of Application.UnsetApplicationsConfig.

> Body parameter

```json
{
  "Args": [
    {
      "application": "string",
      "branch": "string",
      "options": [
        "string"
      ]
    }
  ]
}
```

<h3 id="unsetapplicationsconfig-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ApplicationConfigUnsetArgs](#schemaapplicationconfigunsetargs)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="unsetapplicationsconfig-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## updateApplicationBase

<a id="opIdupdateApplicationBase"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /application/updateApplicationBase \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /application/updateApplicationBase HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "args": [
    {
      "channel": "string",
      "force": true,
      "tag": {
        "tag": "string"
      }
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/application/updateApplicationBase',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/application/updateApplicationBase',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/application/updateApplicationBase', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/application/updateApplicationBase', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/application/updateApplicationBase");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/application/updateApplicationBase", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /application/updateApplicationBase`

Updates the application base. Base for subordinates is updated too.

> Body parameter

```json
{
  "args": [
    {
      "channel": "string",
      "force": true,
      "tag": {
        "tag": "string"
      }
    }
  ]
}
```

<h3 id="updateapplicationbase-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[UpdateChannelArgs](#schemaupdatechannelargs)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="updateapplicationbase-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-applicationoffers">applicationoffers</h1>

## applicationOffers

<a id="opIdapplicationOffers"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /applicationoffers/applicationOffers \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /applicationoffers/applicationOffers HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "bakery-version": 0,
  "offer-urls": [
    "string"
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/applicationoffers/applicationOffers',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/applicationoffers/applicationOffers',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/applicationoffers/applicationOffers', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/applicationoffers/applicationOffers', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/applicationoffers/applicationOffers");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/applicationoffers/applicationOffers", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /applicationoffers/applicationOffers`

Gets details about remote applications that match given URLs.

> Body parameter

```json
{
  "bakery-version": 0,
  "offer-urls": [
    "string"
  ]
}
```

<h3 id="applicationoffers-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[OfferURLs](#schemaofferurls)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "ApplicationOfferDetails": {
          "application-description": "string",
          "bindings": {},
          "endpoints": [
            {
              "interface": "string",
              "limit": 0,
              "name": "string",
              "role": "string"
            }
          ],
          "offer-name": "string",
          "offer-url": "string",
          "offer-uuid": "string",
          "source-model-tag": "string",
          "spaces": [
            {
              "cloud-type": "string",
              "name": "string",
              "provider-attributes": {},
              "provider-id": "string",
              "subnets": [
                {
                  "cidr": "string",
                  "life": "string",
                  "provider-id": "string",
                  "provider-network-id": "string",
                  "provider-space-id": "string",
                  "space-tag": "string",
                  "status": "string",
                  "vlan-tag": 0,
                  "zones": [
                    "string"
                  ]
                }
              ]
            }
          ],
          "users": [
            {
              "access": "string",
              "display-name": "string",
              "user": "string"
            }
          ]
        },
        "application-description": "string",
        "application-name": "string",
        "bindings": {},
        "charm-url": "string",
        "connections": [
          {
            "endpoint": "string",
            "ingress-subnets": [
              "string"
            ],
            "relation-id": 0,
            "source-model-tag": "string",
            "status": {
              "data": {},
              "info": "string",
              "since": "2019-08-24T14:15:22Z",
              "status": "string"
            },
            "username": "string"
          }
        ],
        "endpoints": [
          {
            "interface": "string",
            "limit": 0,
            "name": "string",
            "role": "string"
          }
        ],
        "offer-name": "string",
        "offer-url": "string",
        "offer-uuid": "string",
        "source-model-tag": "string",
        "spaces": [
          {
            "cloud-type": "string",
            "name": "string",
            "provider-attributes": {},
            "provider-id": "string",
            "subnets": [
              {
                "cidr": "string",
                "life": "string",
                "provider-id": "string",
                "provider-network-id": "string",
                "provider-space-id": "string",
                "space-tag": "string",
                "status": "string",
                "vlan-tag": 0,
                "zones": [
                  "string"
                ]
              }
            ]
          }
        ],
        "users": [
          {
            "access": "string",
            "display-name": "string",
            "user": "string"
          }
        ]
      }
    }
  ]
}
```

<h3 id="applicationoffers-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ApplicationOffersResults](#schemaapplicationoffersresults)|

<aside class="success">
This operation does not require authentication
</aside>

## destroyOffers

<a id="opIddestroyOffers"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /applicationoffers/destroyOffers \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /applicationoffers/destroyOffers HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "force": true,
  "offer-urls": [
    "string"
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/applicationoffers/destroyOffers',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/applicationoffers/destroyOffers',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/applicationoffers/destroyOffers', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/applicationoffers/destroyOffers', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/applicationoffers/destroyOffers");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/applicationoffers/destroyOffers", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /applicationoffers/destroyOffers`

Removes the offers specified by the given URLs, forcing if necessary.

> Body parameter

```json
{
  "force": true,
  "offer-urls": [
    "string"
  ]
}
```

<h3 id="destroyoffers-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[DestroyApplicationOffers](#schemadestroyapplicationoffers)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="destroyoffers-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## findApplicationOffers

<a id="opIdfindApplicationOffers"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /applicationoffers/findApplicationOffers \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /applicationoffers/findApplicationOffers HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "Filters": [
    {
      "allowed-users": [
        "string"
      ],
      "application-description": "string",
      "application-name": "string",
      "application-user": "string",
      "connected-users": [
        "string"
      ],
      "endpoints": [
        {
          "interface": "string",
          "name": "string",
          "role": "string"
        }
      ],
      "model-name": "string",
      "offer-name": "string",
      "owner-name": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/applicationoffers/findApplicationOffers',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/applicationoffers/findApplicationOffers',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/applicationoffers/findApplicationOffers', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/applicationoffers/findApplicationOffers', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/applicationoffers/findApplicationOffers");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/applicationoffers/findApplicationOffers", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /applicationoffers/findApplicationOffers`

Gets details about remote applications that match given filter.

> Body parameter

```json
{
  "Filters": [
    {
      "allowed-users": [
        "string"
      ],
      "application-description": "string",
      "application-name": "string",
      "application-user": "string",
      "connected-users": [
        "string"
      ],
      "endpoints": [
        {
          "interface": "string",
          "name": "string",
          "role": "string"
        }
      ],
      "model-name": "string",
      "offer-name": "string",
      "owner-name": "string"
    }
  ]
}
```

<h3 id="findapplicationoffers-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[OfferFilters](#schemaofferfilters)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "ApplicationOfferDetails": {
        "application-description": "string",
        "bindings": {},
        "endpoints": [
          {
            "interface": "string",
            "limit": 0,
            "name": "string",
            "role": "string"
          }
        ],
        "offer-name": "string",
        "offer-url": "string",
        "offer-uuid": "string",
        "source-model-tag": "string",
        "spaces": [
          {
            "cloud-type": "string",
            "name": "string",
            "provider-attributes": {},
            "provider-id": "string",
            "subnets": [
              {
                "cidr": "string",
                "life": "string",
                "provider-id": "string",
                "provider-network-id": "string",
                "provider-space-id": "string",
                "space-tag": "string",
                "status": "string",
                "vlan-tag": 0,
                "zones": [
                  "string"
                ]
              }
            ]
          }
        ],
        "users": [
          {
            "access": "string",
            "display-name": "string",
            "user": "string"
          }
        ]
      },
      "application-description": "string",
      "application-name": "string",
      "bindings": {},
      "charm-url": "string",
      "connections": [
        {
          "endpoint": "string",
          "ingress-subnets": [
            "string"
          ],
          "relation-id": 0,
          "source-model-tag": "string",
          "status": {
            "data": {},
            "info": "string",
            "since": "2019-08-24T14:15:22Z",
            "status": "string"
          },
          "username": "string"
        }
      ],
      "endpoints": [
        {
          "interface": "string",
          "limit": 0,
          "name": "string",
          "role": "string"
        }
      ],
      "offer-name": "string",
      "offer-url": "string",
      "offer-uuid": "string",
      "source-model-tag": "string",
      "spaces": [
        {
          "cloud-type": "string",
          "name": "string",
          "provider-attributes": {},
          "provider-id": "string",
          "subnets": [
            {
              "cidr": "string",
              "life": "string",
              "provider-id": "string",
              "provider-network-id": "string",
              "provider-space-id": "string",
              "space-tag": "string",
              "status": "string",
              "vlan-tag": 0,
              "zones": [
                "string"
              ]
            }
          ]
        }
      ],
      "users": [
        {
          "access": "string",
          "display-name": "string",
          "user": "string"
        }
      ]
    }
  ]
}
```

<h3 id="findapplicationoffers-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[QueryApplicationOffersResults](#schemaqueryapplicationoffersresults)|

<aside class="success">
This operation does not require authentication
</aside>

## getConsumeDetails

<a id="opIdgetConsumeDetails"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /applicationoffers/getConsumeDetails \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /applicationoffers/getConsumeDetails HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "offer-urls": {
    "bakery-version": 0,
    "offer-urls": [
      "string"
    ]
  },
  "user-tag": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/applicationoffers/getConsumeDetails',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/applicationoffers/getConsumeDetails',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/applicationoffers/getConsumeDetails', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/applicationoffers/getConsumeDetails', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/applicationoffers/getConsumeDetails");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/applicationoffers/getConsumeDetails", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /applicationoffers/getConsumeDetails`

Returns the details necessary to pass to another model to allow the specified args user to consume the offers represented by the args URLs.

> Body parameter

```json
{
  "offer-urls": {
    "bakery-version": 0,
    "offer-urls": [
      "string"
    ]
  },
  "user-tag": "string"
}
```

<h3 id="getconsumedetails-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ConsumeOfferDetailsArg](#schemaconsumeofferdetailsarg)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "ConsumeOfferDetails": {
        "external-controller": {
          "addrs": [
            "string"
          ],
          "ca-cert": "string",
          "controller-alias": "string",
          "controller-tag": "string"
        },
        "macaroon": {},
        "offer": {
          "application-description": "string",
          "bindings": {},
          "endpoints": [
            {
              "interface": "string",
              "limit": 0,
              "name": "string",
              "role": "string"
            }
          ],
          "offer-name": "string",
          "offer-url": "string",
          "offer-uuid": "string",
          "source-model-tag": "string",
          "spaces": [
            {
              "cloud-type": "string",
              "name": "string",
              "provider-attributes": {},
              "provider-id": "string",
              "subnets": [
                {
                  "cidr": "string",
                  "life": "string",
                  "provider-id": "string",
                  "provider-network-id": "string",
                  "provider-space-id": "string",
                  "space-tag": "string",
                  "status": "string",
                  "vlan-tag": 0,
                  "zones": [
                    "string"
                  ]
                }
              ]
            }
          ],
          "users": [
            {
              "access": "string",
              "display-name": "string",
              "user": "string"
            }
          ]
        }
      },
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "external-controller": {
        "addrs": [
          "string"
        ],
        "ca-cert": "string",
        "controller-alias": "string",
        "controller-tag": "string"
      },
      "macaroon": {},
      "offer": {
        "application-description": "string",
        "bindings": {},
        "endpoints": [
          {
            "interface": "string",
            "limit": 0,
            "name": "string",
            "role": "string"
          }
        ],
        "offer-name": "string",
        "offer-url": "string",
        "offer-uuid": "string",
        "source-model-tag": "string",
        "spaces": [
          {
            "cloud-type": "string",
            "name": "string",
            "provider-attributes": {},
            "provider-id": "string",
            "subnets": [
              {
                "cidr": "string",
                "life": "string",
                "provider-id": "string",
                "provider-network-id": "string",
                "provider-space-id": "string",
                "space-tag": "string",
                "status": "string",
                "vlan-tag": 0,
                "zones": [
                  "string"
                ]
              }
            ]
          }
        ],
        "users": [
          {
            "access": "string",
            "display-name": "string",
            "user": "string"
          }
        ]
      }
    }
  ]
}
```

<h3 id="getconsumedetails-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ConsumeOfferDetailsResults](#schemaconsumeofferdetailsresults)|

<aside class="success">
This operation does not require authentication
</aside>

## listApplicationOffers

<a id="opIdlistApplicationOffers"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /applicationoffers/listApplicationOffers \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /applicationoffers/listApplicationOffers HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "Filters": [
    {
      "allowed-users": [
        "string"
      ],
      "application-description": "string",
      "application-name": "string",
      "application-user": "string",
      "connected-users": [
        "string"
      ],
      "endpoints": [
        {
          "interface": "string",
          "name": "string",
          "role": "string"
        }
      ],
      "model-name": "string",
      "offer-name": "string",
      "owner-name": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/applicationoffers/listApplicationOffers',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/applicationoffers/listApplicationOffers',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/applicationoffers/listApplicationOffers', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/applicationoffers/listApplicationOffers', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/applicationoffers/listApplicationOffers");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/applicationoffers/listApplicationOffers", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /applicationoffers/listApplicationOffers`

Gets deployed details about application offers that match given filter. The results contain details about the deployed applications such as connection count.

> Body parameter

```json
{
  "Filters": [
    {
      "allowed-users": [
        "string"
      ],
      "application-description": "string",
      "application-name": "string",
      "application-user": "string",
      "connected-users": [
        "string"
      ],
      "endpoints": [
        {
          "interface": "string",
          "name": "string",
          "role": "string"
        }
      ],
      "model-name": "string",
      "offer-name": "string",
      "owner-name": "string"
    }
  ]
}
```

<h3 id="listapplicationoffers-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[OfferFilters](#schemaofferfilters)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "ApplicationOfferDetails": {
        "application-description": "string",
        "bindings": {},
        "endpoints": [
          {
            "interface": "string",
            "limit": 0,
            "name": "string",
            "role": "string"
          }
        ],
        "offer-name": "string",
        "offer-url": "string",
        "offer-uuid": "string",
        "source-model-tag": "string",
        "spaces": [
          {
            "cloud-type": "string",
            "name": "string",
            "provider-attributes": {},
            "provider-id": "string",
            "subnets": [
              {
                "cidr": "string",
                "life": "string",
                "provider-id": "string",
                "provider-network-id": "string",
                "provider-space-id": "string",
                "space-tag": "string",
                "status": "string",
                "vlan-tag": 0,
                "zones": [
                  "string"
                ]
              }
            ]
          }
        ],
        "users": [
          {
            "access": "string",
            "display-name": "string",
            "user": "string"
          }
        ]
      },
      "application-description": "string",
      "application-name": "string",
      "bindings": {},
      "charm-url": "string",
      "connections": [
        {
          "endpoint": "string",
          "ingress-subnets": [
            "string"
          ],
          "relation-id": 0,
          "source-model-tag": "string",
          "status": {
            "data": {},
            "info": "string",
            "since": "2019-08-24T14:15:22Z",
            "status": "string"
          },
          "username": "string"
        }
      ],
      "endpoints": [
        {
          "interface": "string",
          "limit": 0,
          "name": "string",
          "role": "string"
        }
      ],
      "offer-name": "string",
      "offer-url": "string",
      "offer-uuid": "string",
      "source-model-tag": "string",
      "spaces": [
        {
          "cloud-type": "string",
          "name": "string",
          "provider-attributes": {},
          "provider-id": "string",
          "subnets": [
            {
              "cidr": "string",
              "life": "string",
              "provider-id": "string",
              "provider-network-id": "string",
              "provider-space-id": "string",
              "space-tag": "string",
              "status": "string",
              "vlan-tag": 0,
              "zones": [
                "string"
              ]
            }
          ]
        }
      ],
      "users": [
        {
          "access": "string",
          "display-name": "string",
          "user": "string"
        }
      ]
    }
  ]
}
```

<h3 id="listapplicationoffers-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[QueryApplicationOffersResults](#schemaqueryapplicationoffersresults)|

<aside class="success">
This operation does not require authentication
</aside>

## modifyOfferAccess

<a id="opIdmodifyOfferAccess"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /applicationoffers/modifyOfferAccess \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /applicationoffers/modifyOfferAccess HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "changes": [
    {
      "access": "string",
      "action": "string",
      "offer-url": "string",
      "user-tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/applicationoffers/modifyOfferAccess',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/applicationoffers/modifyOfferAccess',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/applicationoffers/modifyOfferAccess', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/applicationoffers/modifyOfferAccess', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/applicationoffers/modifyOfferAccess");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/applicationoffers/modifyOfferAccess", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /applicationoffers/modifyOfferAccess`

Changes the application offer access granted to users.

> Body parameter

```json
{
  "changes": [
    {
      "access": "string",
      "action": "string",
      "offer-url": "string",
      "user-tag": "string"
    }
  ]
}
```

<h3 id="modifyofferaccess-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ModifyOfferAccessRequest](#schemamodifyofferaccessrequest)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="modifyofferaccess-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## offer

<a id="opIdoffer"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /applicationoffers/offer \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /applicationoffers/offer HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "Offers": [
    {
      "application-description": "string",
      "application-name": "string",
      "endpoints": {},
      "model-tag": "string",
      "offer-name": "string",
      "owner-tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/applicationoffers/offer',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/applicationoffers/offer',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/applicationoffers/offer', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/applicationoffers/offer', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/applicationoffers/offer");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/applicationoffers/offer", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /applicationoffers/offer`

Makes application endpoints available for consumption at a specified URL.

> Body parameter

```json
{
  "Offers": [
    {
      "application-description": "string",
      "application-name": "string",
      "endpoints": {},
      "model-tag": "string",
      "offer-name": "string",
      "owner-tag": "string"
    }
  ]
}
```

<h3 id="offer-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[AddApplicationOffers](#schemaaddapplicationoffers)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="offer-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## remoteApplicationInfo

<a id="opIdremoteApplicationInfo"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /applicationoffers/remoteApplicationInfo \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /applicationoffers/remoteApplicationInfo HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "bakery-version": 0,
  "offer-urls": [
    "string"
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/applicationoffers/remoteApplicationInfo',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/applicationoffers/remoteApplicationInfo',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/applicationoffers/remoteApplicationInfo', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/applicationoffers/remoteApplicationInfo', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/applicationoffers/remoteApplicationInfo");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/applicationoffers/remoteApplicationInfo", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /applicationoffers/remoteApplicationInfo`

Returns information about the requested remote application. This call currently has no client side API, only there for the Dashboard at this stage.

> Body parameter

```json
{
  "bakery-version": 0,
  "offer-urls": [
    "string"
  ]
}
```

<h3 id="remoteapplicationinfo-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[OfferURLs](#schemaofferurls)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "description": "string",
        "endpoints": [
          {
            "interface": "string",
            "limit": 0,
            "name": "string",
            "role": "string"
          }
        ],
        "icon-url-path": "string",
        "model-tag": "string",
        "name": "string",
        "offer-url": "string",
        "source-model-label": "string"
      }
    }
  ]
}
```

<h3 id="remoteapplicationinfo-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[RemoteApplicationInfoResults](#schemaremoteapplicationinforesults)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-backups">backups</h1>

## create

<a id="opIdcreate"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /backups/create \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /backups/create HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "no-download": true,
  "notes": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/backups/create',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/backups/create',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/backups/create', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/backups/create', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/backups/create");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/backups/create", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /backups/create`

Is the API method that requests juju to create a new backup of its state.

> Body parameter

```json
{
  "no-download": true,
  "notes": "string"
}
```

<h3 id="create-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[BackupsCreateArgs](#schemabackupscreateargs)|true|none|

> Example responses

> 200 Response

```json
{
  "base": "string",
  "checksum": "string",
  "checksum-format": "string",
  "controller-machine-id": "string",
  "controller-machine-inst-id": "string",
  "controller-uuid": "string",
  "filename": "string",
  "finished": "2019-08-24T14:15:22Z",
  "format-version": 0,
  "ha-nodes": 0,
  "hostname": "string",
  "id": "string",
  "machine": "string",
  "model": "string",
  "notes": "string",
  "size": 0,
  "started": "2019-08-24T14:15:22Z",
  "stored": "2019-08-24T14:15:22Z",
  "version": {
    "Build": 0,
    "Major": 0,
    "Minor": 0,
    "Patch": 0,
    "Tag": "string"
  }
}
```

<h3 id="create-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[BackupsMetadataResult](#schemabackupsmetadataresult)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-block">block</h1>

## list

<a id="opIdlist"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /block/list \
  -H 'Accept: application/json'

```

```http
GET /block/list HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/block/list',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/block/list',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/block/list', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/block/list', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/block/list");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/block/list", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /block/list`

Implements Block.List().

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "id": "string",
        "message": "string",
        "tag": "string",
        "type": "string"
      }
    }
  ]
}
```

<h3 id="list-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[BlockResults](#schemablockresults)|

<aside class="success">
This operation does not require authentication
</aside>

## switchBlockOff

<a id="opIdswitchBlockOff"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /block/switchBlockOff \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /block/switchBlockOff HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "message": "string",
  "type": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/block/switchBlockOff',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/block/switchBlockOff',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/block/switchBlockOff', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/block/switchBlockOff', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/block/switchBlockOff");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/block/switchBlockOff", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /block/switchBlockOff`

Implements Block.SwitchBlockOff().

> Body parameter

```json
{
  "message": "string",
  "type": "string"
}
```

<h3 id="switchblockoff-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[BlockSwitchParams](#schemablockswitchparams)|true|none|

> Example responses

> 200 Response

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  }
}
```

<h3 id="switchblockoff-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResult](#schemaerrorresult)|

<aside class="success">
This operation does not require authentication
</aside>

## switchBlockOn

<a id="opIdswitchBlockOn"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /block/switchBlockOn \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /block/switchBlockOn HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "message": "string",
  "type": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/block/switchBlockOn',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/block/switchBlockOn',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/block/switchBlockOn', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/block/switchBlockOn', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/block/switchBlockOn");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/block/switchBlockOn", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /block/switchBlockOn`

Implements Block.SwitchBlockOn().

> Body parameter

```json
{
  "message": "string",
  "type": "string"
}
```

<h3 id="switchblockon-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[BlockSwitchParams](#schemablockswitchparams)|true|none|

> Example responses

> 200 Response

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  }
}
```

<h3 id="switchblockon-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResult](#schemaerrorresult)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-bundle">bundle</h1>

## exportBundle

<a id="opIdexportBundle"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /bundle/exportBundle \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /bundle/exportBundle HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "include-charm-defaults": true
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/bundle/exportBundle',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/bundle/exportBundle',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/bundle/exportBundle', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/bundle/exportBundle', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/bundle/exportBundle");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/bundle/exportBundle", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /bundle/exportBundle`

Exports the current model configuration as bundle.

> Body parameter

```json
{
  "include-charm-defaults": true
}
```

<h3 id="exportbundle-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ExportBundleParams](#schemaexportbundleparams)|true|none|

> Example responses

> 200 Response

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": "string"
}
```

<h3 id="exportbundle-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[StringResult](#schemastringresult)|

<aside class="success">
This operation does not require authentication
</aside>

## getChanges

<a id="opIdgetChanges"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /bundle/getChanges \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /bundle/getChanges HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "bundleURL": "string",
  "yaml": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/bundle/getChanges',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/bundle/getChanges',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/bundle/getChanges', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/bundle/getChanges', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/bundle/getChanges");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/bundle/getChanges", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /bundle/getChanges`

Returns the list of changes required to deploy the given bundle data. The changes are sorted by requirements, so that they can be applied in order. GetChanges has been superseded in favour of GetChangesMapArgs. It's preferable to use that new method to add new functionality and move clients away from this one.

> Body parameter

```json
{
  "bundleURL": "string",
  "yaml": "string"
}
```

<h3 id="getchanges-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[BundleChangesParams](#schemabundlechangesparams)|true|none|

> Example responses

> 200 Response

```json
{
  "changes": [
    {
      "args": [
        {}
      ],
      "id": "string",
      "method": "string",
      "requires": [
        "string"
      ]
    }
  ],
  "errors": [
    "string"
  ]
}
```

<h3 id="getchanges-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[BundleChangesResults](#schemabundlechangesresults)|

<aside class="success">
This operation does not require authentication
</aside>

## getChangesMapArgs

<a id="opIdgetChangesMapArgs"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /bundle/getChangesMapArgs \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /bundle/getChangesMapArgs HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "bundleURL": "string",
  "yaml": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/bundle/getChangesMapArgs',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/bundle/getChangesMapArgs',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/bundle/getChangesMapArgs', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/bundle/getChangesMapArgs', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/bundle/getChangesMapArgs");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/bundle/getChangesMapArgs", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /bundle/getChangesMapArgs`

Returns the list of changes required to deploy the given bundle data. The changes are sorted by requirements, so that they can be applied in order. V4 GetChangesMapArgs is not supported on anything less than v4

> Body parameter

```json
{
  "bundleURL": "string",
  "yaml": "string"
}
```

<h3 id="getchangesmapargs-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[BundleChangesParams](#schemabundlechangesparams)|true|none|

> Example responses

> 200 Response

```json
{
  "changes": [
    {
      "args": {},
      "id": "string",
      "method": "string",
      "requires": [
        "string"
      ]
    }
  ],
  "errors": [
    "string"
  ]
}
```

<h3 id="getchangesmapargs-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[BundleChangesMapArgsResults](#schemabundlechangesmapargsresults)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-charms">charms</h1>

## addCharm

<a id="opIdaddCharm"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /charms/addCharm \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /charms/addCharm HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "charm-origin": {
    "architecture": "string",
    "base": {
      "channel": "string",
      "name": "string"
    },
    "branch": "string",
    "hash": "string",
    "id": "string",
    "instance-key": "string",
    "revision": 0,
    "risk": "string",
    "source": "string",
    "track": "string",
    "type": "string"
  },
  "force": true,
  "url": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/charms/addCharm',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/charms/addCharm',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/charms/addCharm', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/charms/addCharm', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/charms/addCharm");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/charms/addCharm", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /charms/addCharm`

Adds the given charm URL (which must include revision) to the environment, if it does not exist yet. Local charms are not supported, only charm store and charm hub URLs. See also AddLocalCharm().

> Body parameter

```json
{
  "charm-origin": {
    "architecture": "string",
    "base": {
      "channel": "string",
      "name": "string"
    },
    "branch": "string",
    "hash": "string",
    "id": "string",
    "instance-key": "string",
    "revision": 0,
    "risk": "string",
    "source": "string",
    "track": "string",
    "type": "string"
  },
  "force": true,
  "url": "string"
}
```

<h3 id="addcharm-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[AddCharmWithOrigin](#schemaaddcharmwithorigin)|true|none|

> Example responses

> 200 Response

```json
{
  "charm-origin": {
    "architecture": "string",
    "base": {
      "channel": "string",
      "name": "string"
    },
    "branch": "string",
    "hash": "string",
    "id": "string",
    "instance-key": "string",
    "revision": 0,
    "risk": "string",
    "source": "string",
    "track": "string",
    "type": "string"
  },
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  }
}
```

<h3 id="addcharm-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[CharmOriginResult](#schemacharmoriginresult)|

<aside class="success">
This operation does not require authentication
</aside>

## charmInfo

<a id="opIdcharmInfo"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /charms/charmInfo \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /charms/charmInfo HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "url": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/charms/charmInfo',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/charms/charmInfo',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/charms/charmInfo', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/charms/charmInfo', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/charms/charmInfo");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/charms/charmInfo", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /charms/charmInfo`

Returns information about the requested charm.

> Body parameter

```json
{
  "url": "string"
}
```

<h3 id="charminfo-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[CharmURL](#schemacharmurl)|true|none|

> Example responses

> 200 Response

```json
{
  "actions": {
    "specs": {}
  },
  "config": {},
  "lxd-profile": {
    "config": {},
    "description": "string",
    "devices": {}
  },
  "manifest": {
    "bases": [
      {
        "architectures": [
          "string"
        ],
        "channel": "string",
        "name": "string"
      }
    ]
  },
  "meta": {
    "assumes-expr": {
      "Expression": {}
    },
    "categories": [
      "string"
    ],
    "containers": {},
    "deployment": {
      "min-version": "string",
      "mode": "string",
      "service": "string",
      "type": "string"
    },
    "description": "string",
    "devices": {},
    "extra-bindings": {},
    "min-juju-version": "string",
    "name": "string",
    "payload-classes": {},
    "peers": {},
    "provides": {},
    "requires": {},
    "resources": {},
    "series": [
      "string"
    ],
    "storage": {},
    "subordinate": true,
    "summary": "string",
    "tags": [
      "string"
    ],
    "terms": [
      "string"
    ]
  },
  "metrics": {
    "metrics": {},
    "plan": {
      "required": true
    }
  },
  "revision": 0,
  "url": "string"
}
```

<h3 id="charminfo-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[Charm](#schemacharm)|

<aside class="success">
This operation does not require authentication
</aside>

## checkCharmPlacement

<a id="opIdcheckCharmPlacement"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /charms/checkCharmPlacement \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /charms/checkCharmPlacement HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "placements": [
    {
      "application": "string",
      "charm-url": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/charms/checkCharmPlacement',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/charms/checkCharmPlacement',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/charms/checkCharmPlacement', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/charms/checkCharmPlacement', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/charms/checkCharmPlacement");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/charms/checkCharmPlacement", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /charms/checkCharmPlacement`

Checks if a charm is allowed to be placed with in a given application.

> Body parameter

```json
{
  "placements": [
    {
      "application": "string",
      "charm-url": "string"
    }
  ]
}
```

<h3 id="checkcharmplacement-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ApplicationCharmPlacements](#schemaapplicationcharmplacements)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="checkcharmplacement-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## getDownloadInfos

<a id="opIdgetDownloadInfos"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /charms/getDownloadInfos \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /charms/getDownloadInfos HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "charm-origin": {
        "architecture": "string",
        "base": {
          "channel": "string",
          "name": "string"
        },
        "branch": "string",
        "hash": "string",
        "id": "string",
        "instance-key": "string",
        "revision": 0,
        "risk": "string",
        "source": "string",
        "track": "string",
        "type": "string"
      },
      "charm-url": "string",
      "macaroon": {}
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/charms/getDownloadInfos',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/charms/getDownloadInfos',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/charms/getDownloadInfos', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/charms/getDownloadInfos', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/charms/getDownloadInfos");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/charms/getDownloadInfos", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /charms/getDownloadInfos`

Attempts to get the bundle corresponding to the charm url and origin.

> Body parameter

```json
{
  "entities": [
    {
      "charm-origin": {
        "architecture": "string",
        "base": {
          "channel": "string",
          "name": "string"
        },
        "branch": "string",
        "hash": "string",
        "id": "string",
        "instance-key": "string",
        "revision": 0,
        "risk": "string",
        "source": "string",
        "track": "string",
        "type": "string"
      },
      "charm-url": "string",
      "macaroon": {}
    }
  ]
}
```

<h3 id="getdownloadinfos-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[CharmURLAndOrigins](#schemacharmurlandorigins)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "charm-origin": {
        "architecture": "string",
        "base": {
          "channel": "string",
          "name": "string"
        },
        "branch": "string",
        "hash": "string",
        "id": "string",
        "instance-key": "string",
        "revision": 0,
        "risk": "string",
        "source": "string",
        "track": "string",
        "type": "string"
      },
      "url": "string"
    }
  ]
}
```

<h3 id="getdownloadinfos-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[DownloadInfoResults](#schemadownloadinforesults)|

<aside class="success">
This operation does not require authentication
</aside>

## isMetered

<a id="opIdisMetered"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /charms/isMetered \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /charms/isMetered HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "url": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/charms/isMetered',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/charms/isMetered',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/charms/isMetered', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/charms/isMetered', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/charms/isMetered");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/charms/isMetered", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /charms/isMetered`

Returns whether or not the charm is metered.

> Body parameter

```json
{
  "url": "string"
}
```

<h3 id="ismetered-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[CharmURL](#schemacharmurl)|true|none|

> Example responses

> 200 Response

```json
{
  "metered": true
}
```

<h3 id="ismetered-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[IsMeteredResult](#schemaismeteredresult)|

<aside class="success">
This operation does not require authentication
</aside>

## list

<a id="opIdlist"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /charms/list \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /charms/list HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "names": [
    "string"
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/charms/list',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/charms/list',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/charms/list', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/charms/list', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/charms/list");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/charms/list", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /charms/list`

Returns a list of charm URLs currently in the state. If supplied parameter contains any names, the result will be filtered to return only the charms with supplied names.

> Body parameter

```json
{
  "names": [
    "string"
  ]
}
```

<h3 id="list-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[CharmsList](#schemacharmslist)|true|none|

> Example responses

> 200 Response

```json
{
  "charm-urls": [
    "string"
  ]
}
```

<h3 id="list-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[CharmsListResult](#schemacharmslistresult)|

<aside class="success">
This operation does not require authentication
</aside>

## listCharmResources

<a id="opIdlistCharmResources"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /charms/listCharmResources \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /charms/listCharmResources HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "charm-origin": {
        "architecture": "string",
        "base": {
          "channel": "string",
          "name": "string"
        },
        "branch": "string",
        "hash": "string",
        "id": "string",
        "instance-key": "string",
        "revision": 0,
        "risk": "string",
        "source": "string",
        "track": "string",
        "type": "string"
      },
      "charm-url": "string",
      "macaroon": {}
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/charms/listCharmResources',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/charms/listCharmResources',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/charms/listCharmResources', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/charms/listCharmResources', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/charms/listCharmResources");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/charms/listCharmResources", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /charms/listCharmResources`

Returns a series of resources for a given charm.

> Body parameter

```json
{
  "entities": [
    {
      "charm-origin": {
        "architecture": "string",
        "base": {
          "channel": "string",
          "name": "string"
        },
        "branch": "string",
        "hash": "string",
        "id": "string",
        "instance-key": "string",
        "revision": 0,
        "risk": "string",
        "source": "string",
        "track": "string",
        "type": "string"
      },
      "charm-url": "string",
      "macaroon": {}
    }
  ]
}
```

<h3 id="listcharmresources-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[CharmURLAndOrigins](#schemacharmurlandorigins)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    [
      {
        "CharmResource": {
          "description": "string",
          "fingerprint": [
            0
          ],
          "name": "string",
          "origin": "string",
          "path": "string",
          "revision": 0,
          "size": 0,
          "type": "string"
        },
        "ErrorResult": {
          "error": {
            "code": "string",
            "info": {},
            "message": "string"
          }
        },
        "description": "string",
        "error": {
          "code": "string",
          "info": {},
          "message": "string"
        },
        "fingerprint": [
          0
        ],
        "name": "string",
        "origin": "string",
        "path": "string",
        "revision": 0,
        "size": 0,
        "type": "string"
      }
    ]
  ]
}
```

<h3 id="listcharmresources-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[CharmResourcesResults](#schemacharmresourcesresults)|

<aside class="success">
This operation does not require authentication
</aside>

## resolveCharms

<a id="opIdresolveCharms"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /charms/resolveCharms \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /charms/resolveCharms HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "macaroon": {},
  "resolve": [
    {
      "charm-origin": {
        "architecture": "string",
        "base": {
          "channel": "string",
          "name": "string"
        },
        "branch": "string",
        "hash": "string",
        "id": "string",
        "instance-key": "string",
        "revision": 0,
        "risk": "string",
        "source": "string",
        "track": "string",
        "type": "string"
      },
      "reference": "string",
      "switch-charm": true
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/charms/resolveCharms',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/charms/resolveCharms',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/charms/resolveCharms', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/charms/resolveCharms', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/charms/resolveCharms");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/charms/resolveCharms", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /charms/resolveCharms`

Resolves the given charm URLs with an optionally specified preferred channel.  Channel provided via CharmOrigin.

> Body parameter

```json
{
  "macaroon": {},
  "resolve": [
    {
      "charm-origin": {
        "architecture": "string",
        "base": {
          "channel": "string",
          "name": "string"
        },
        "branch": "string",
        "hash": "string",
        "id": "string",
        "instance-key": "string",
        "revision": 0,
        "risk": "string",
        "source": "string",
        "track": "string",
        "type": "string"
      },
      "reference": "string",
      "switch-charm": true
    }
  ]
}
```

<h3 id="resolvecharms-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ResolveCharmsWithChannel](#schemaresolvecharmswithchannel)|true|none|

> Example responses

> 200 Response

```json
{
  "Results": [
    {
      "charm-origin": {
        "architecture": "string",
        "base": {
          "channel": "string",
          "name": "string"
        },
        "branch": "string",
        "hash": "string",
        "id": "string",
        "instance-key": "string",
        "revision": 0,
        "risk": "string",
        "source": "string",
        "track": "string",
        "type": "string"
      },
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "supported-series": [
        "string"
      ],
      "url": "string"
    }
  ]
}
```

<h3 id="resolvecharms-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ResolveCharmWithChannelResults](#schemaresolvecharmwithchannelresults)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-client">client</h1>

## findTools

<a id="opIdfindTools"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /client/findTools \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /client/findTools HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "agentstream": "string",
  "arch": "string",
  "major": 0,
  "number": {
    "Build": 0,
    "Major": 0,
    "Minor": 0,
    "Patch": 0,
    "Tag": "string"
  },
  "os-type": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/client/findTools',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/client/findTools',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/client/findTools', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/client/findTools', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/client/findTools");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/client/findTools", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /client/findTools`

Returns a List containing all tools matching the given parameters. TODO(juju 3.1) - remove, used by 2.9 client only

> Body parameter

```json
{
  "agentstream": "string",
  "arch": "string",
  "major": 0,
  "number": {
    "Build": 0,
    "Major": 0,
    "Minor": 0,
    "Patch": 0,
    "Tag": "string"
  },
  "os-type": "string"
}
```

<h3 id="findtools-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[FindToolsParams](#schemafindtoolsparams)|true|none|

> Example responses

> 200 Response

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "list": [
    {
      "sha256": "string",
      "size": 0,
      "url": "string",
      "version": {
        "Arch": "string",
        "Build": 0,
        "Major": 0,
        "Minor": 0,
        "Number": {
          "Build": 0,
          "Major": 0,
          "Minor": 0,
          "Patch": 0,
          "Tag": "string"
        },
        "Patch": 0,
        "Release": "string",
        "Tag": "string"
      }
    }
  ]
}
```

<h3 id="findtools-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[FindToolsResult](#schemafindtoolsresult)|

<aside class="success">
This operation does not require authentication
</aside>

## fullStatus

<a id="opIdfullStatus"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /client/fullStatus \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /client/fullStatus HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "patterns": [
    "string"
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/client/fullStatus',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/client/fullStatus',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/client/fullStatus', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/client/fullStatus', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/client/fullStatus");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/client/fullStatus", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /client/fullStatus`

Gives the information needed for juju status over the api

> Body parameter

```json
{
  "patterns": [
    "string"
  ]
}
```

<h3 id="fullstatus-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[StatusParams](#schemastatusparams)|true|none|

> Example responses

> 200 Response

```json
{
  "applications": {},
  "branches": {},
  "controller-timestamp": "2019-08-24T14:15:22Z",
  "machines": {},
  "model": {
    "available-version": "string",
    "cloud-tag": "string",
    "meter-status": {
      "color": "string",
      "message": "string"
    },
    "model-status": {
      "data": {},
      "err": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "info": "string",
      "kind": "string",
      "life": "string",
      "since": "2019-08-24T14:15:22Z",
      "status": "string",
      "version": "string"
    },
    "name": "string",
    "region": "string",
    "sla": "string",
    "type": "string",
    "version": "string"
  },
  "offers": {},
  "relations": [
    {
      "endpoints": [
        {
          "application": "string",
          "name": "string",
          "role": "string",
          "subordinate": true
        }
      ],
      "id": 0,
      "interface": "string",
      "key": "string",
      "scope": "string",
      "status": {
        "data": {},
        "err": {
          "code": "string",
          "info": {},
          "message": "string"
        },
        "info": "string",
        "kind": "string",
        "life": "string",
        "since": "2019-08-24T14:15:22Z",
        "status": "string",
        "version": "string"
      }
    }
  ],
  "remote-applications": {}
}
```

<h3 id="fullstatus-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[FullStatus](#schemafullstatus)|

<aside class="success">
This operation does not require authentication
</aside>

## statusHistory

<a id="opIdstatusHistory"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /client/statusHistory \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /client/statusHistory HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "requests": [
    {
      "filter": {
        "date": "2019-08-24T14:15:22Z",
        "delta": 0,
        "exclude": [
          "string"
        ],
        "size": 0
      },
      "historyKind": "string",
      "size": 0,
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/client/statusHistory',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/client/statusHistory',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/client/statusHistory', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/client/statusHistory', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/client/statusHistory");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/client/statusHistory", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /client/statusHistory`

Returns a slice of past statuses for several entities.

> Body parameter

```json
{
  "requests": [
    {
      "filter": {
        "date": "2019-08-24T14:15:22Z",
        "delta": 0,
        "exclude": [
          "string"
        ],
        "size": 0
      },
      "historyKind": "string",
      "size": 0,
      "tag": "string"
    }
  ]
}
```

<h3 id="statushistory-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[StatusHistoryRequests](#schemastatushistoryrequests)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "history": {
        "error": {
          "code": "string",
          "info": {},
          "message": "string"
        },
        "statuses": [
          {
            "data": {},
            "err": {
              "code": "string",
              "info": {},
              "message": "string"
            },
            "info": "string",
            "kind": "string",
            "life": "string",
            "since": "2019-08-24T14:15:22Z",
            "status": "string",
            "version": "string"
          }
        ]
      }
    }
  ]
}
```

<h3 id="statushistory-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[StatusHistoryResults](#schemastatushistoryresults)|

<aside class="success">
This operation does not require authentication
</aside>

## watchAll

<a id="opIdwatchAll"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /client/watchAll \
  -H 'Accept: application/json'

```

```http
GET /client/watchAll HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/client/watchAll',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/client/watchAll',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/client/watchAll', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/client/watchAll', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/client/watchAll");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/client/watchAll", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /client/watchAll`

Initiates a watcher for entities in the connected model.

> Example responses

> 200 Response

```json
{
  "watcher-id": "string"
}
```

<h3 id="watchall-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[AllWatcherId](#schemaallwatcherid)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-cloud">cloud</h1>

## addCloud

<a id="opIdaddCloud"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /cloud/addCloud \
  -H 'Content-Type: application/json'

```

```http
GET /cloud/addCloud HTTP/1.1

Content-Type: application/json

```

```javascript
const inputBody = '{
  "cloud": {
    "auth-types": [
      "string"
    ],
    "ca-certificates": [
      "string"
    ],
    "config": {},
    "endpoint": "string",
    "host-cloud-region": "string",
    "identity-endpoint": "string",
    "is-controller-cloud": true,
    "region-config": {},
    "regions": [
      {
        "endpoint": "string",
        "identity-endpoint": "string",
        "name": "string",
        "storage-endpoint": "string"
      }
    ],
    "skip-tls-verify": true,
    "storage-endpoint": "string",
    "type": "string"
  },
  "force": true,
  "name": "string"
}';
const headers = {
  'Content-Type':'application/json'
};

fetch('/cloud/addCloud',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json'
}

result = RestClient.get '/cloud/addCloud',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json'
}

r = requests.get('/cloud/addCloud', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/cloud/addCloud', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/cloud/addCloud");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/cloud/addCloud", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /cloud/addCloud`

Adds a new cloud, different from the one managed by the controller.

> Body parameter

```json
{
  "cloud": {
    "auth-types": [
      "string"
    ],
    "ca-certificates": [
      "string"
    ],
    "config": {},
    "endpoint": "string",
    "host-cloud-region": "string",
    "identity-endpoint": "string",
    "is-controller-cloud": true,
    "region-config": {},
    "regions": [
      {
        "endpoint": "string",
        "identity-endpoint": "string",
        "name": "string",
        "storage-endpoint": "string"
      }
    ],
    "skip-tls-verify": true,
    "storage-endpoint": "string",
    "type": "string"
  },
  "force": true,
  "name": "string"
}
```

<h3 id="addcloud-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[AddCloudArgs](#schemaaddcloudargs)|true|none|

<h3 id="addcloud-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|

<aside class="success">
This operation does not require authentication
</aside>

## addCredentials

<a id="opIdaddCredentials"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /cloud/addCredentials \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /cloud/addCredentials HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "credentials": [
    {
      "credential": {
        "attrs": {},
        "auth-type": "string",
        "redacted": [
          "string"
        ]
      },
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/cloud/addCredentials',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/cloud/addCredentials',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/cloud/addCredentials', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/cloud/addCredentials', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/cloud/addCredentials");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/cloud/addCredentials", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /cloud/addCredentials`

Adds new credentials. In contrast to UpdateCredentials() below, the new credentials can be for a cloud that the controller does not manage (this is required for CAAS models)

> Body parameter

```json
{
  "credentials": [
    {
      "credential": {
        "attrs": {},
        "auth-type": "string",
        "redacted": [
          "string"
        ]
      },
      "tag": "string"
    }
  ]
}
```

<h3 id="addcredentials-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[TaggedCredentials](#schemataggedcredentials)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="addcredentials-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## checkCredentialsModels

<a id="opIdcheckCredentialsModels"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /cloud/checkCredentialsModels \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /cloud/checkCredentialsModels HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "credentials": [
    {
      "credential": {
        "attrs": {},
        "auth-type": "string",
        "redacted": [
          "string"
        ]
      },
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/cloud/checkCredentialsModels',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/cloud/checkCredentialsModels',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/cloud/checkCredentialsModels', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/cloud/checkCredentialsModels', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/cloud/checkCredentialsModels");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/cloud/checkCredentialsModels", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /cloud/checkCredentialsModels`

Validates supplied cloud credentials' content against models that currently use these credentials. If there are any models that are using a credential and these models or their cloud instances are not going to be accessible with corresponding credential, there will be detailed validation errors per model. There's no Juju API client which uses this, but JAAS does,

> Body parameter

```json
{
  "credentials": [
    {
      "credential": {
        "attrs": {},
        "auth-type": "string",
        "redacted": [
          "string"
        ]
      },
      "tag": "string"
    }
  ]
}
```

<h3 id="checkcredentialsmodels-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[TaggedCredentials](#schemataggedcredentials)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "models": [
        {
          "errors": [
            {
              "error": {
                "code": "string",
                "info": {},
                "message": "string"
              }
            }
          ],
          "name": "string",
          "uuid": "string"
        }
      ],
      "tag": "string"
    }
  ]
}
```

<h3 id="checkcredentialsmodels-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[UpdateCredentialResults](#schemaupdatecredentialresults)|

<aside class="success">
This operation does not require authentication
</aside>

## cloud

<a id="opIdcloud"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /cloud/cloud \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /cloud/cloud HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/cloud/cloud',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/cloud/cloud',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/cloud/cloud', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/cloud/cloud', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/cloud/cloud");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/cloud/cloud", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /cloud/cloud`

Returns the cloud definitions for the specified clouds.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="cloud-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "cloud": {
        "auth-types": [
          "string"
        ],
        "ca-certificates": [
          "string"
        ],
        "config": {},
        "endpoint": "string",
        "host-cloud-region": "string",
        "identity-endpoint": "string",
        "is-controller-cloud": true,
        "region-config": {},
        "regions": [
          {
            "endpoint": "string",
            "identity-endpoint": "string",
            "name": "string",
            "storage-endpoint": "string"
          }
        ],
        "skip-tls-verify": true,
        "storage-endpoint": "string",
        "type": "string"
      },
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="cloud-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[CloudResults](#schemacloudresults)|

<aside class="success">
This operation does not require authentication
</aside>

## cloudInfo

<a id="opIdcloudInfo"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /cloud/cloudInfo \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /cloud/cloudInfo HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/cloud/cloudInfo',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/cloud/cloudInfo',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/cloud/cloudInfo', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/cloud/cloudInfo', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/cloud/cloudInfo");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/cloud/cloudInfo", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /cloud/cloudInfo`

Returns information about the specified clouds.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="cloudinfo-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "CloudDetails": {
          "auth-types": [
            "string"
          ],
          "endpoint": "string",
          "identity-endpoint": "string",
          "regions": [
            {
              "endpoint": "string",
              "identity-endpoint": "string",
              "name": "string",
              "storage-endpoint": "string"
            }
          ],
          "storage-endpoint": "string",
          "type": "string"
        },
        "users": [
          {
            "access": "string",
            "display-name": "string",
            "user": "string"
          }
        ]
      }
    }
  ]
}
```

<h3 id="cloudinfo-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[CloudInfoResults](#schemacloudinforesults)|

<aside class="success">
This operation does not require authentication
</aside>

## clouds

<a id="opIdclouds"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /cloud/clouds \
  -H 'Accept: application/json'

```

```http
GET /cloud/clouds HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/cloud/clouds',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/cloud/clouds',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/cloud/clouds', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/cloud/clouds', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/cloud/clouds");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/cloud/clouds", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /cloud/clouds`

Returns the definitions of all clouds supported by the controller that the logged in user can see.

> Example responses

> 200 Response

```json
{
  "clouds": {}
}
```

<h3 id="clouds-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[CloudsResult](#schemacloudsresult)|

<aside class="success">
This operation does not require authentication
</aside>

## credential

<a id="opIdcredential"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /cloud/credential \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /cloud/credential HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/cloud/credential',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/cloud/credential',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/cloud/credential', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/cloud/credential', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/cloud/credential");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/cloud/credential", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /cloud/credential`

Returns the specified cloud credential for each tag, minus secrets.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="credential-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "attrs": {},
        "auth-type": "string",
        "redacted": [
          "string"
        ]
      }
    }
  ]
}
```

<h3 id="credential-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[CloudCredentialResults](#schemacloudcredentialresults)|

<aside class="success">
This operation does not require authentication
</aside>

## credentialContents

<a id="opIdcredentialContents"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /cloud/credentialContents \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /cloud/credentialContents HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "credentials": [
    {
      "cloud-name": "string",
      "credential-name": "string"
    }
  ],
  "include-secrets": true
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/cloud/credentialContents',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/cloud/credentialContents',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/cloud/credentialContents', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/cloud/credentialContents', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/cloud/credentialContents");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/cloud/credentialContents", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /cloud/credentialContents`

Returns the specified cloud credentials, including the secrets if requested. If no specific credential name/cloud was passed in, all credentials for this user are returned. Only credential owner can see its contents as well as what models use it. Controller admin has no special superpowers here and is treated the same as all other users.

> Body parameter

```json
{
  "credentials": [
    {
      "cloud-name": "string",
      "credential-name": "string"
    }
  ],
  "include-secrets": true
}
```

<h3 id="credentialcontents-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[CloudCredentialArgs](#schemacloudcredentialargs)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "content": {
          "attrs": {},
          "auth-type": "string",
          "cloud": "string",
          "name": "string",
          "valid": true
        },
        "models": [
          {
            "access": "string",
            "model": "string"
          }
        ]
      }
    }
  ]
}
```

<h3 id="credentialcontents-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[CredentialContentResults](#schemacredentialcontentresults)|

<aside class="success">
This operation does not require authentication
</aside>

## instanceTypes

<a id="opIdinstanceTypes"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /cloud/instanceTypes \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /cloud/instanceTypes HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "constraints": [
    {
      "cloud-tag": "string",
      "constraints": {
        "allocate-public-ip": true,
        "arch": "string",
        "container": "string",
        "cores": 0,
        "cpu-power": 0,
        "image-id": "string",
        "instance-role": "string",
        "instance-type": "string",
        "mem": 0,
        "root-disk": 0,
        "root-disk-source": "string",
        "spaces": [
          "string"
        ],
        "tags": [
          "string"
        ],
        "virt-type": "string",
        "zones": [
          "string"
        ]
      },
      "region": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/cloud/instanceTypes',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/cloud/instanceTypes',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/cloud/instanceTypes', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/cloud/instanceTypes', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/cloud/instanceTypes");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/cloud/instanceTypes", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /cloud/instanceTypes`

Returns instance type information for the cloud and region in which the current model is deployed.

> Body parameter

```json
{
  "constraints": [
    {
      "cloud-tag": "string",
      "constraints": {
        "allocate-public-ip": true,
        "arch": "string",
        "container": "string",
        "cores": 0,
        "cpu-power": 0,
        "image-id": "string",
        "instance-role": "string",
        "instance-type": "string",
        "mem": 0,
        "root-disk": 0,
        "root-disk-source": "string",
        "spaces": [
          "string"
        ],
        "tags": [
          "string"
        ],
        "virt-type": "string",
        "zones": [
          "string"
        ]
      },
      "region": "string"
    }
  ]
}
```

<h3 id="instancetypes-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[CloudInstanceTypesConstraints](#schemacloudinstancetypesconstraints)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "cost-currency": "string",
      "cost-divisor": 0,
      "cost-unit": "string",
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "instance-types": [
        {
          "arches": [
            "string"
          ],
          "cost": 0,
          "cpu-cores": 0,
          "deprecated": true,
          "memory": 0,
          "name": "string",
          "root-disk": 0,
          "virt-type": "string"
        }
      ]
    }
  ]
}
```

<h3 id="instancetypes-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[InstanceTypesResults](#schemainstancetypesresults)|

<aside class="success">
This operation does not require authentication
</aside>

## listCloudInfo

<a id="opIdlistCloudInfo"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /cloud/listCloudInfo \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /cloud/listCloudInfo HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "all": true,
  "user-tag": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/cloud/listCloudInfo',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/cloud/listCloudInfo',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/cloud/listCloudInfo', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/cloud/listCloudInfo', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/cloud/listCloudInfo");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/cloud/listCloudInfo", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /cloud/listCloudInfo`

Returns clouds that the specified user has access to. Controller admins (superuser) can list clouds for any user. Other users can only ask about their own clouds.

> Body parameter

```json
{
  "all": true,
  "user-tag": "string"
}
```

<h3 id="listcloudinfo-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ListCloudsRequest](#schemalistcloudsrequest)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "CloudDetails": {
          "auth-types": [
            "string"
          ],
          "endpoint": "string",
          "identity-endpoint": "string",
          "regions": [
            {
              "endpoint": "string",
              "identity-endpoint": "string",
              "name": "string",
              "storage-endpoint": "string"
            }
          ],
          "storage-endpoint": "string",
          "type": "string"
        },
        "user-access": "string"
      }
    }
  ]
}
```

<h3 id="listcloudinfo-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ListCloudInfoResults](#schemalistcloudinforesults)|

<aside class="success">
This operation does not require authentication
</aside>

## modifyCloudAccess

<a id="opIdmodifyCloudAccess"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /cloud/modifyCloudAccess \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /cloud/modifyCloudAccess HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "changes": [
    {
      "access": "string",
      "action": "string",
      "cloud-tag": "string",
      "user-tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/cloud/modifyCloudAccess',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/cloud/modifyCloudAccess',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/cloud/modifyCloudAccess', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/cloud/modifyCloudAccess', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/cloud/modifyCloudAccess");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/cloud/modifyCloudAccess", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /cloud/modifyCloudAccess`

Changes the model access granted to users.

> Body parameter

```json
{
  "changes": [
    {
      "access": "string",
      "action": "string",
      "cloud-tag": "string",
      "user-tag": "string"
    }
  ]
}
```

<h3 id="modifycloudaccess-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ModifyCloudAccessRequest](#schemamodifycloudaccessrequest)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="modifycloudaccess-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## removeClouds

<a id="opIdremoveClouds"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /cloud/removeClouds \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /cloud/removeClouds HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/cloud/removeClouds',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/cloud/removeClouds',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/cloud/removeClouds', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/cloud/removeClouds', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/cloud/removeClouds");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/cloud/removeClouds", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /cloud/removeClouds`

Removes the specified clouds from the controller. If a cloud is in use (has models deployed to it), the removal will fail.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="removeclouds-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="removeclouds-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## revokeCredentialsCheckModels

<a id="opIdrevokeCredentialsCheckModels"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /cloud/revokeCredentialsCheckModels \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /cloud/revokeCredentialsCheckModels HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "credentials": [
    {
      "force": true,
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/cloud/revokeCredentialsCheckModels',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/cloud/revokeCredentialsCheckModels',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/cloud/revokeCredentialsCheckModels', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/cloud/revokeCredentialsCheckModels', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/cloud/revokeCredentialsCheckModels");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/cloud/revokeCredentialsCheckModels", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /cloud/revokeCredentialsCheckModels`

Revokes a set of cloud credentials. If the credentials are used by any of the models, the credential deletion will be aborted. If credential-in-use needs to be revoked nonetheless, this method allows the use of force.

> Body parameter

```json
{
  "credentials": [
    {
      "force": true,
      "tag": "string"
    }
  ]
}
```

<h3 id="revokecredentialscheckmodels-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[RevokeCredentialArgs](#schemarevokecredentialargs)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="revokecredentialscheckmodels-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## updateCloud

<a id="opIdupdateCloud"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /cloud/updateCloud \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /cloud/updateCloud HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "clouds": [
    {
      "cloud": {
        "auth-types": [
          "string"
        ],
        "ca-certificates": [
          "string"
        ],
        "config": {},
        "endpoint": "string",
        "host-cloud-region": "string",
        "identity-endpoint": "string",
        "is-controller-cloud": true,
        "region-config": {},
        "regions": [
          {
            "endpoint": "string",
            "identity-endpoint": "string",
            "name": "string",
            "storage-endpoint": "string"
          }
        ],
        "skip-tls-verify": true,
        "storage-endpoint": "string",
        "type": "string"
      },
      "force": true,
      "name": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/cloud/updateCloud',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/cloud/updateCloud',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/cloud/updateCloud', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/cloud/updateCloud', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/cloud/updateCloud");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/cloud/updateCloud", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /cloud/updateCloud`

Updates an existing cloud that the controller knows about.

> Body parameter

```json
{
  "clouds": [
    {
      "cloud": {
        "auth-types": [
          "string"
        ],
        "ca-certificates": [
          "string"
        ],
        "config": {},
        "endpoint": "string",
        "host-cloud-region": "string",
        "identity-endpoint": "string",
        "is-controller-cloud": true,
        "region-config": {},
        "regions": [
          {
            "endpoint": "string",
            "identity-endpoint": "string",
            "name": "string",
            "storage-endpoint": "string"
          }
        ],
        "skip-tls-verify": true,
        "storage-endpoint": "string",
        "type": "string"
      },
      "force": true,
      "name": "string"
    }
  ]
}
```

<h3 id="updatecloud-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[UpdateCloudArgs](#schemaupdatecloudargs)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="updatecloud-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## updateCredentialsCheckModels

<a id="opIdupdateCredentialsCheckModels"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /cloud/updateCredentialsCheckModels \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /cloud/updateCredentialsCheckModels HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "credentials": [
    {
      "credential": {
        "attrs": {},
        "auth-type": "string",
        "redacted": [
          "string"
        ]
      },
      "tag": "string"
    }
  ],
  "force": true
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/cloud/updateCredentialsCheckModels',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/cloud/updateCredentialsCheckModels',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/cloud/updateCredentialsCheckModels', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/cloud/updateCredentialsCheckModels', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/cloud/updateCredentialsCheckModels");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/cloud/updateCredentialsCheckModels", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /cloud/updateCredentialsCheckModels`

Updates a set of cloud credentials' content. If there are any models that are using a credential and these models are not going to be visible with updated credential content, there will be detailed validation errors per model.  Such model errors are returned separately and do not contribute to the overall method error status. Controller admins can 'force' an update of the credential regardless of whether it is deemed valid or not.

> Body parameter

```json
{
  "credentials": [
    {
      "credential": {
        "attrs": {},
        "auth-type": "string",
        "redacted": [
          "string"
        ]
      },
      "tag": "string"
    }
  ],
  "force": true
}
```

<h3 id="updatecredentialscheckmodels-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[UpdateCredentialArgs](#schemaupdatecredentialargs)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "models": [
        {
          "errors": [
            {
              "error": {
                "code": "string",
                "info": {},
                "message": "string"
              }
            }
          ],
          "name": "string",
          "uuid": "string"
        }
      ],
      "tag": "string"
    }
  ]
}
```

<h3 id="updatecredentialscheckmodels-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[UpdateCredentialResults](#schemaupdatecredentialresults)|

<aside class="success">
This operation does not require authentication
</aside>

## userCredentials

<a id="opIduserCredentials"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /cloud/userCredentials \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /cloud/userCredentials HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "user-clouds": [
    {
      "cloud-tag": "string",
      "user-tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/cloud/userCredentials',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/cloud/userCredentials',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/cloud/userCredentials', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/cloud/userCredentials', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/cloud/userCredentials");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/cloud/userCredentials", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /cloud/userCredentials`

Returns the cloud credentials for a set of users.

> Body parameter

```json
{
  "user-clouds": [
    {
      "cloud-tag": "string",
      "user-tag": "string"
    }
  ]
}
```

<h3 id="usercredentials-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[UserClouds](#schemauserclouds)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": [
        "string"
      ]
    }
  ]
}
```

<h3 id="usercredentials-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[StringsResults](#schemastringsresults)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-controller">controller</h1>

## allModels

<a id="opIdallModels"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /controller/allModels \
  -H 'Accept: application/json'

```

```http
GET /controller/allModels HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/controller/allModels',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/controller/allModels',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/controller/allModels', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/controller/allModels', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/controller/allModels");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/controller/allModels", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /controller/allModels`

Allows controller administrators to get the list of all the models in the controller.

> Example responses

> 200 Response

```json
{
  "user-models": [
    {
      "last-connection": "2019-08-24T14:15:22Z",
      "model": {
        "name": "string",
        "owner-tag": "string",
        "type": "string",
        "uuid": "string"
      }
    }
  ]
}
```

<h3 id="allmodels-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[UserModelList](#schemausermodellist)|

<aside class="success">
This operation does not require authentication
</aside>

## cloudSpec

<a id="opIdcloudSpec"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /controller/cloudSpec \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /controller/cloudSpec HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/controller/cloudSpec',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/controller/cloudSpec',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/controller/cloudSpec', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/controller/cloudSpec', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/controller/cloudSpec");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/controller/cloudSpec", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /controller/cloudSpec`

Returns the model's cloud spec.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="cloudspec-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "cacertificates": [
          "string"
        ],
        "credential": {
          "attrs": {},
          "auth-type": "string",
          "redacted": [
            "string"
          ]
        },
        "endpoint": "string",
        "identity-endpoint": "string",
        "is-controller-cloud": true,
        "name": "string",
        "region": "string",
        "skip-tls-verify": true,
        "storage-endpoint": "string",
        "type": "string"
      }
    }
  ]
}
```

<h3 id="cloudspec-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[CloudSpecResults](#schemacloudspecresults)|

<aside class="success">
This operation does not require authentication
</aside>

## configSet

<a id="opIdconfigSet"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /controller/configSet \
  -H 'Content-Type: application/json'

```

```http
GET /controller/configSet HTTP/1.1

Content-Type: application/json

```

```javascript
const inputBody = '{
  "config": {}
}';
const headers = {
  'Content-Type':'application/json'
};

fetch('/controller/configSet',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json'
}

result = RestClient.get '/controller/configSet',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json'
}

r = requests.get('/controller/configSet', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/controller/configSet', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/controller/configSet");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/controller/configSet", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /controller/configSet`

Changes the value of specified controller configuration settings. Only some settings can be changed after bootstrap. Settings that aren't specified in the params are left unchanged.

> Body parameter

```json
{
  "config": {}
}
```

<h3 id="configset-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ControllerConfigSet](#schemacontrollerconfigset)|true|none|

<h3 id="configset-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|

<aside class="success">
This operation does not require authentication
</aside>

## controllerAPIInfoForModels

<a id="opIdcontrollerAPIInfoForModels"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /controller/controllerAPIInfoForModels \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /controller/controllerAPIInfoForModels HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/controller/controllerAPIInfoForModels',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/controller/controllerAPIInfoForModels',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/controller/controllerAPIInfoForModels', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/controller/controllerAPIInfoForModels', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/controller/controllerAPIInfoForModels");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/controller/controllerAPIInfoForModels", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /controller/controllerAPIInfoForModels`

Returns the controller api connection details for the specified models.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="controllerapiinfoformodels-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "addresses": [
        "string"
      ],
      "cacert": "string",
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="controllerapiinfoformodels-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ControllerAPIInfoResults](#schemacontrollerapiinforesults)|

<aside class="success">
This operation does not require authentication
</aside>

## controllerConfig

<a id="opIdcontrollerConfig"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /controller/controllerConfig \
  -H 'Accept: application/json'

```

```http
GET /controller/controllerConfig HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/controller/controllerConfig',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/controller/controllerConfig',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/controller/controllerConfig', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/controller/controllerConfig', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/controller/controllerConfig");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/controller/controllerConfig", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /controller/controllerConfig`

Returns the controller's configuration.

> Example responses

> 200 Response

```json
{
  "config": {}
}
```

<h3 id="controllerconfig-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ControllerConfigResult](#schemacontrollerconfigresult)|

<aside class="success">
This operation does not require authentication
</aside>

## controllerVersion

<a id="opIdcontrollerVersion"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /controller/controllerVersion \
  -H 'Accept: application/json'

```

```http
GET /controller/controllerVersion HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/controller/controllerVersion',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/controller/controllerVersion',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/controller/controllerVersion', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/controller/controllerVersion', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/controller/controllerVersion");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/controller/controllerVersion", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /controller/controllerVersion`

Returns the version information associated with this controller binary.  NOTE: the implementation intentionally does not check for SuperuserAccess as the Version is known even to users with login access.

> Example responses

> 200 Response

```json
{
  "git-commit": "string",
  "version": "string"
}
```

<h3 id="controllerversion-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ControllerVersionResults](#schemacontrollerversionresults)|

<aside class="success">
This operation does not require authentication
</aside>

## dashboardConnectionInfo

<a id="opIddashboardConnectionInfo"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /controller/dashboardConnectionInfo \
  -H 'Accept: application/json'

```

```http
GET /controller/dashboardConnectionInfo HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/controller/dashboardConnectionInfo',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/controller/dashboardConnectionInfo',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/controller/dashboardConnectionInfo', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/controller/dashboardConnectionInfo', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/controller/dashboardConnectionInfo");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/controller/dashboardConnectionInfo", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /controller/dashboardConnectionInfo`

Returns the connection information for a client to connect to the Juju Dashboard including any proxying information.

> Example responses

> 200 Response

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "proxy-connection": {
    "config": {},
    "type": "string"
  },
  "ssh-connection": {
    "entity": "string",
    "host": "string",
    "model": "string",
    "port": "string"
  }
}
```

<h3 id="dashboardconnectioninfo-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[DashboardConnectionInfo](#schemadashboardconnectioninfo)|

<aside class="success">
This operation does not require authentication
</aside>

## destroyController

<a id="opIddestroyController"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /controller/destroyController \
  -H 'Content-Type: application/json'

```

```http
GET /controller/destroyController HTTP/1.1

Content-Type: application/json

```

```javascript
const inputBody = '{
  "destroy-models": true,
  "destroy-storage": true,
  "force": true,
  "max-wait": 0,
  "model-timeout": 0
}';
const headers = {
  'Content-Type':'application/json'
};

fetch('/controller/destroyController',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json'
}

result = RestClient.get '/controller/destroyController',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json'
}

r = requests.get('/controller/destroyController', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/controller/destroyController', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/controller/destroyController");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/controller/destroyController", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /controller/destroyController`

Destroys the controller.  If the args specify the destruction of the models, this method will attempt to do so. Otherwise, if the controller has any non-empty, non-Dead hosted models, then an error with the code params.CodeHasHostedModels will be transmitted.

> Body parameter

```json
{
  "destroy-models": true,
  "destroy-storage": true,
  "force": true,
  "max-wait": 0,
  "model-timeout": 0
}
```

<h3 id="destroycontroller-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[DestroyControllerArgs](#schemadestroycontrollerargs)|true|none|

<h3 id="destroycontroller-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|

<aside class="success">
This operation does not require authentication
</aside>

## getCloudSpec

<a id="opIdgetCloudSpec"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /controller/getCloudSpec \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /controller/getCloudSpec HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/controller/getCloudSpec',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/controller/getCloudSpec',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/controller/getCloudSpec', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/controller/getCloudSpec', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/controller/getCloudSpec");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/controller/getCloudSpec", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /controller/getCloudSpec`

Constructs the CloudSpec for a validated and authorized model.

> Body parameter

```json
{}
```

<h3 id="getcloudspec-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ModelTag](#schemamodeltag)|true|none|

> Example responses

> 200 Response

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": {
    "cacertificates": [
      "string"
    ],
    "credential": {
      "attrs": {},
      "auth-type": "string",
      "redacted": [
        "string"
      ]
    },
    "endpoint": "string",
    "identity-endpoint": "string",
    "is-controller-cloud": true,
    "name": "string",
    "region": "string",
    "skip-tls-verify": true,
    "storage-endpoint": "string",
    "type": "string"
  }
}
```

<h3 id="getcloudspec-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[CloudSpecResult](#schemacloudspecresult)|

<aside class="success">
This operation does not require authentication
</aside>

## getControllerAccess

<a id="opIdgetControllerAccess"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /controller/getControllerAccess \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /controller/getControllerAccess HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/controller/getControllerAccess',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/controller/getControllerAccess',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/controller/getControllerAccess', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/controller/getControllerAccess', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/controller/getControllerAccess");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/controller/getControllerAccess", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /controller/getControllerAccess`

Returns the level of access the specified users have on the controller.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="getcontrolleraccess-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "access": "string",
        "user-tag": "string"
      }
    }
  ]
}
```

<h3 id="getcontrolleraccess-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[UserAccessResults](#schemauseraccessresults)|

<aside class="success">
This operation does not require authentication
</aside>

## hostedModelConfigs

<a id="opIdhostedModelConfigs"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /controller/hostedModelConfigs \
  -H 'Accept: application/json'

```

```http
GET /controller/hostedModelConfigs HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/controller/hostedModelConfigs',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/controller/hostedModelConfigs',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/controller/hostedModelConfigs', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/controller/hostedModelConfigs', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/controller/hostedModelConfigs");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/controller/hostedModelConfigs", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /controller/hostedModelConfigs`

Returns all the information that the client needs in order to connect directly with the host model's provider and destroy it directly.

> Example responses

> 200 Response

```json
{
  "models": [
    {
      "cloud-spec": {
        "cacertificates": [
          "string"
        ],
        "credential": {
          "attrs": {},
          "auth-type": "string",
          "redacted": [
            "string"
          ]
        },
        "endpoint": "string",
        "identity-endpoint": "string",
        "is-controller-cloud": true,
        "name": "string",
        "region": "string",
        "skip-tls-verify": true,
        "storage-endpoint": "string",
        "type": "string"
      },
      "config": {},
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "name": "string",
      "owner": "string"
    }
  ]
}
```

<h3 id="hostedmodelconfigs-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[HostedModelConfigsResults](#schemahostedmodelconfigsresults)|

<aside class="success">
This operation does not require authentication
</aside>

## identityProviderURL

<a id="opIdidentityProviderURL"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /controller/identityProviderURL \
  -H 'Accept: application/json'

```

```http
GET /controller/identityProviderURL HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/controller/identityProviderURL',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/controller/identityProviderURL',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/controller/identityProviderURL', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/controller/identityProviderURL', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/controller/identityProviderURL");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/controller/identityProviderURL", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /controller/identityProviderURL`

Returns the URL of the configured external identity provider for this controller or an empty string if no external identity provider has been configured when the controller was bootstrapped.  NOTE: the implementation intentionally does not check for SuperuserAccess as the URL is known even to users with login access.

> Example responses

> 200 Response

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": "string"
}
```

<h3 id="identityproviderurl-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[StringResult](#schemastringresult)|

<aside class="success">
This operation does not require authentication
</aside>

## initiateMigration

<a id="opIdinitiateMigration"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /controller/initiateMigration \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /controller/initiateMigration HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "specs": [
    {
      "model-tag": "string",
      "target-info": {
        "addrs": [
          "string"
        ],
        "auth-tag": "string",
        "ca-cert": "string",
        "controller-alias": "string",
        "controller-tag": "string",
        "macaroons": "string",
        "password": "string"
      }
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/controller/initiateMigration',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/controller/initiateMigration',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/controller/initiateMigration', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/controller/initiateMigration', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/controller/initiateMigration");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/controller/initiateMigration", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /controller/initiateMigration`

Attempts to begin the migration of one or more models to other controllers.

> Body parameter

```json
{
  "specs": [
    {
      "model-tag": "string",
      "target-info": {
        "addrs": [
          "string"
        ],
        "auth-tag": "string",
        "ca-cert": "string",
        "controller-alias": "string",
        "controller-tag": "string",
        "macaroons": "string",
        "password": "string"
      }
    }
  ]
}
```

<h3 id="initiatemigration-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[InitiateMigrationArgs](#schemainitiatemigrationargs)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "migration-id": "string",
      "model-tag": "string"
    }
  ]
}
```

<h3 id="initiatemigration-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[InitiateMigrationResults](#schemainitiatemigrationresults)|

<aside class="success">
This operation does not require authentication
</aside>

## listBlockedModels

<a id="opIdlistBlockedModels"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /controller/listBlockedModels \
  -H 'Accept: application/json'

```

```http
GET /controller/listBlockedModels HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/controller/listBlockedModels',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/controller/listBlockedModels',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/controller/listBlockedModels', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/controller/listBlockedModels', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/controller/listBlockedModels");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/controller/listBlockedModels", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /controller/listBlockedModels`

Returns a list of all models on the controller which have a block in place.  The resulting slice is sorted by model name, then owner. Callers must be controller administrators to retrieve the list.

> Example responses

> 200 Response

```json
{
  "models": [
    {
      "blocks": [
        "string"
      ],
      "model-uuid": "string",
      "name": "string",
      "owner-tag": "string"
    }
  ]
}
```

<h3 id="listblockedmodels-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ModelBlockInfoList](#schemamodelblockinfolist)|

<aside class="success">
This operation does not require authentication
</aside>

## modelConfig

<a id="opIdmodelConfig"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /controller/modelConfig \
  -H 'Accept: application/json'

```

```http
GET /controller/modelConfig HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/controller/modelConfig',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/controller/modelConfig',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/controller/modelConfig', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/controller/modelConfig', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/controller/modelConfig");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/controller/modelConfig", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /controller/modelConfig`

Returns the model config for the controller model.  For information on the current model, use client.ModelGet

> Example responses

> 200 Response

```json
{
  "config": {}
}
```

<h3 id="modelconfig-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ModelConfigResults](#schemamodelconfigresults)|

<aside class="success">
This operation does not require authentication
</aside>

## modelStatus

<a id="opIdmodelStatus"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /controller/modelStatus \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /controller/modelStatus HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/controller/modelStatus',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/controller/modelStatus',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/controller/modelStatus', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/controller/modelStatus', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/controller/modelStatus");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/controller/modelStatus", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /controller/modelStatus`

Returns a summary of the model.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="modelstatus-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "models": [
    {
      "application-count": 0,
      "applications": [
        {
          "name": "string"
        }
      ],
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "filesystems": [
        {
          "detachable": true,
          "id": "string",
          "message": "string",
          "provider-id": "string",
          "status": "string"
        }
      ],
      "hosted-machine-count": 0,
      "life": "string",
      "machines": [
        {
          "display-name": "string",
          "ha-primary": true,
          "hardware": {
            "arch": "string",
            "availability-zone": "string",
            "cores": 0,
            "cpu-power": 0,
            "mem": 0,
            "root-disk": 0,
            "tags": [
              "string"
            ],
            "virt-type": "string"
          },
          "has-vote": true,
          "id": "string",
          "instance-id": "string",
          "message": "string",
          "status": "string",
          "wants-vote": true
        }
      ],
      "model-tag": "string",
      "owner-tag": "string",
      "type": "string",
      "unit-count": 0,
      "volumes": [
        {
          "detachable": true,
          "id": "string",
          "message": "string",
          "provider-id": "string",
          "status": "string"
        }
      ]
    }
  ]
}
```

<h3 id="modelstatus-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ModelStatusResults](#schemamodelstatusresults)|

<aside class="success">
This operation does not require authentication
</aside>

## modifyControllerAccess

<a id="opIdmodifyControllerAccess"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /controller/modifyControllerAccess \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /controller/modifyControllerAccess HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "changes": [
    {
      "access": "string",
      "action": "string",
      "user-tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/controller/modifyControllerAccess',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/controller/modifyControllerAccess',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/controller/modifyControllerAccess', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/controller/modifyControllerAccess', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/controller/modifyControllerAccess");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/controller/modifyControllerAccess", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /controller/modifyControllerAccess`

Changes the model access granted to users.

> Body parameter

```json
{
  "changes": [
    {
      "access": "string",
      "action": "string",
      "user-tag": "string"
    }
  ]
}
```

<h3 id="modifycontrolleraccess-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ModifyControllerAccessRequest](#schemamodifycontrolleraccessrequest)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="modifycontrolleraccess-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## mongoVersion

<a id="opIdmongoVersion"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /controller/mongoVersion \
  -H 'Accept: application/json'

```

```http
GET /controller/mongoVersion HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/controller/mongoVersion',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/controller/mongoVersion',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/controller/mongoVersion', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/controller/mongoVersion', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/controller/mongoVersion");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/controller/mongoVersion", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /controller/mongoVersion`

Allows the introspection of the mongo version per controller

> Example responses

> 200 Response

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": "string"
}
```

<h3 id="mongoversion-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[StringResult](#schemastringresult)|

<aside class="success">
This operation does not require authentication
</aside>

## removeBlocks

<a id="opIdremoveBlocks"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /controller/removeBlocks \
  -H 'Content-Type: application/json'

```

```http
GET /controller/removeBlocks HTTP/1.1

Content-Type: application/json

```

```javascript
const inputBody = '{
  "all": true
}';
const headers = {
  'Content-Type':'application/json'
};

fetch('/controller/removeBlocks',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json'
}

result = RestClient.get '/controller/removeBlocks',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json'
}

r = requests.get('/controller/removeBlocks', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/controller/removeBlocks', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/controller/removeBlocks");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/controller/removeBlocks", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /controller/removeBlocks`

Removes all the blocks in the controller.

> Body parameter

```json
{
  "all": true
}
```

<h3 id="removeblocks-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[RemoveBlocksArgs](#schemaremoveblocksargs)|true|none|

<h3 id="removeblocks-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|

<aside class="success">
This operation does not require authentication
</aside>

## watchAllModelSummaries

<a id="opIdwatchAllModelSummaries"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /controller/watchAllModelSummaries \
  -H 'Accept: application/json'

```

```http
GET /controller/watchAllModelSummaries HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/controller/watchAllModelSummaries',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/controller/watchAllModelSummaries',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/controller/watchAllModelSummaries', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/controller/watchAllModelSummaries', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/controller/watchAllModelSummaries");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/controller/watchAllModelSummaries", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /controller/watchAllModelSummaries`

Starts watching the summary updates from the cache. This method is superuser access only, and watches all models in the controller.

> Example responses

> 200 Response

```json
{
  "watcher-id": "string"
}
```

<h3 id="watchallmodelsummaries-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[SummaryWatcherID](#schemasummarywatcherid)|

<aside class="success">
This operation does not require authentication
</aside>

## watchAllModels

<a id="opIdwatchAllModels"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /controller/watchAllModels \
  -H 'Accept: application/json'

```

```http
GET /controller/watchAllModels HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/controller/watchAllModels',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/controller/watchAllModels',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/controller/watchAllModels', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/controller/watchAllModels', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/controller/watchAllModels");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/controller/watchAllModels", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /controller/watchAllModels`

Starts watching events for all models in the controller. The returned AllWatcherId should be used with Next on the AllModelWatcher endpoint to receive deltas.

> Example responses

> 200 Response

```json
{
  "watcher-id": "string"
}
```

<h3 id="watchallmodels-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[AllWatcherId](#schemaallwatcherid)|

<aside class="success">
This operation does not require authentication
</aside>

## watchCloudSpecsChanges

<a id="opIdwatchCloudSpecsChanges"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /controller/watchCloudSpecsChanges \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /controller/watchCloudSpecsChanges HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/controller/watchCloudSpecsChanges',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/controller/watchCloudSpecsChanges',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/controller/watchCloudSpecsChanges', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/controller/watchCloudSpecsChanges', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/controller/watchCloudSpecsChanges");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/controller/watchCloudSpecsChanges", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /controller/watchCloudSpecsChanges`

Returns a watcher for cloud spec changes.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="watchcloudspecschanges-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "NotifyWatcherId": "string",
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="watchcloudspecschanges-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[NotifyWatchResults](#schemanotifywatchresults)|

<aside class="success">
This operation does not require authentication
</aside>

## watchModelSummaries

<a id="opIdwatchModelSummaries"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /controller/watchModelSummaries \
  -H 'Accept: application/json'

```

```http
GET /controller/watchModelSummaries HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/controller/watchModelSummaries',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/controller/watchModelSummaries',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/controller/watchModelSummaries', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/controller/watchModelSummaries', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/controller/watchModelSummaries");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/controller/watchModelSummaries", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /controller/watchModelSummaries`

Starts watching the summary updates from the cache. Only models that the user has access to are returned.

> Example responses

> 200 Response

```json
{
  "watcher-id": "string"
}
```

<h3 id="watchmodelsummaries-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[SummaryWatcherID](#schemasummarywatcherid)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-credentialmanager">credentialmanager</h1>

## invalidateModelCredential

<a id="opIdinvalidateModelCredential"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /credentialmanager/invalidateModelCredential \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /credentialmanager/invalidateModelCredential HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "reason": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/credentialmanager/invalidateModelCredential',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/credentialmanager/invalidateModelCredential',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/credentialmanager/invalidateModelCredential', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/credentialmanager/invalidateModelCredential', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/credentialmanager/invalidateModelCredential");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/credentialmanager/invalidateModelCredential", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /credentialmanager/invalidateModelCredential`

Marks the cloud credential for this model as invalid.

> Body parameter

```json
{
  "reason": "string"
}
```

<h3 id="invalidatemodelcredential-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[InvalidateCredentialArg](#schemainvalidatecredentialarg)|true|none|

> Example responses

> 200 Response

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  }
}
```

<h3 id="invalidatemodelcredential-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResult](#schemaerrorresult)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-firewallrules">firewallrules</h1>

## listFirewallRules

<a id="opIdlistFirewallRules"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /firewallrules/listFirewallRules \
  -H 'Accept: application/json'

```

```http
GET /firewallrules/listFirewallRules HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/firewallrules/listFirewallRules',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/firewallrules/listFirewallRules',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/firewallrules/listFirewallRules', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/firewallrules/listFirewallRules', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/firewallrules/listFirewallRules");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/firewallrules/listFirewallRules", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /firewallrules/listFirewallRules`

Returns all the firewall rules.

> Example responses

> 200 Response

```json
{
  "Rules": [
    {
      "known-service": "string",
      "whitelist-cidrs": [
        "string"
      ]
    }
  ]
}
```

<h3 id="listfirewallrules-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ListFirewallRulesResults](#schemalistfirewallrulesresults)|

<aside class="success">
This operation does not require authentication
</aside>

## setFirewallRules

<a id="opIdsetFirewallRules"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /firewallrules/setFirewallRules \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /firewallrules/setFirewallRules HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "args": [
    {
      "known-service": "string",
      "whitelist-cidrs": [
        "string"
      ]
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/firewallrules/setFirewallRules',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/firewallrules/setFirewallRules',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/firewallrules/setFirewallRules', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/firewallrules/setFirewallRules', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/firewallrules/setFirewallRules");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/firewallrules/setFirewallRules", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /firewallrules/setFirewallRules`

Creates or updates the specified firewall rules.

> Body parameter

```json
{
  "args": [
    {
      "known-service": "string",
      "whitelist-cidrs": [
        "string"
      ]
    }
  ]
}
```

<h3 id="setfirewallrules-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[FirewallRuleArgs](#schemafirewallruleargs)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="setfirewallrules-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-highavailability">highavailability</h1>

## enableHA

<a id="opIdenableHA"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /highavailability/enableHA \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /highavailability/enableHA HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "specs": [
    {
      "constraints": {
        "allocate-public-ip": true,
        "arch": "string",
        "container": "string",
        "cores": 0,
        "cpu-power": 0,
        "image-id": "string",
        "instance-role": "string",
        "instance-type": "string",
        "mem": 0,
        "root-disk": 0,
        "root-disk-source": "string",
        "spaces": [
          "string"
        ],
        "tags": [
          "string"
        ],
        "virt-type": "string",
        "zones": [
          "string"
        ]
      },
      "num-controllers": 0,
      "placement": [
        "string"
      ]
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/highavailability/enableHA',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/highavailability/enableHA',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/highavailability/enableHA', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/highavailability/enableHA', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/highavailability/enableHA");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/highavailability/enableHA", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /highavailability/enableHA`

Adds controller machines as necessary to ensure the controller has the number of machines specified.

> Body parameter

```json
{
  "specs": [
    {
      "constraints": {
        "allocate-public-ip": true,
        "arch": "string",
        "container": "string",
        "cores": 0,
        "cpu-power": 0,
        "image-id": "string",
        "instance-role": "string",
        "instance-type": "string",
        "mem": 0,
        "root-disk": 0,
        "root-disk-source": "string",
        "spaces": [
          "string"
        ],
        "tags": [
          "string"
        ],
        "virt-type": "string",
        "zones": [
          "string"
        ]
      },
      "num-controllers": 0,
      "placement": [
        "string"
      ]
    }
  ]
}
```

<h3 id="enableha-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ControllersSpecs](#schemacontrollersspecs)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "added": [
          "string"
        ],
        "converted": [
          "string"
        ],
        "maintained": [
          "string"
        ],
        "removed": [
          "string"
        ]
      }
    }
  ]
}
```

<h3 id="enableha-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ControllersChangeResults](#schemacontrollerschangeresults)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-imagemetadatamanager">imagemetadatamanager</h1>

## delete

<a id="opIddelete"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /imagemetadatamanager/delete \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /imagemetadatamanager/delete HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "image-ids": [
    "string"
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/imagemetadatamanager/delete',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/imagemetadatamanager/delete',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/imagemetadatamanager/delete', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/imagemetadatamanager/delete', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/imagemetadatamanager/delete");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/imagemetadatamanager/delete", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /imagemetadatamanager/delete`

Deletes cloud image metadata for given image ids. It supports bulk calls.

> Body parameter

```json
{
  "image-ids": [
    "string"
  ]
}
```

<h3 id="delete-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[MetadataImageIds](#schemametadataimageids)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="delete-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## list

<a id="opIdlist"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /imagemetadatamanager/list \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /imagemetadatamanager/list HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "arches": [
    "string"
  ],
  "region": "string",
  "root-storage-type": "string",
  "stream": "string",
  "versions": [
    "string"
  ],
  "virt-type": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/imagemetadatamanager/list',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/imagemetadatamanager/list',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/imagemetadatamanager/list', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/imagemetadatamanager/list', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/imagemetadatamanager/list");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/imagemetadatamanager/list", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /imagemetadatamanager/list`

Returns all found cloud image metadata that satisfy given filter. Returned list contains metadata ordered by priority.

> Body parameter

```json
{
  "arches": [
    "string"
  ],
  "region": "string",
  "root-storage-type": "string",
  "stream": "string",
  "versions": [
    "string"
  ],
  "virt-type": "string"
}
```

<h3 id="list-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ImageMetadataFilter](#schemaimagemetadatafilter)|true|none|

> Example responses

> 200 Response

```json
{
  "result": [
    {
      "arch": "string",
      "image-id": "string",
      "priority": 0,
      "region": "string",
      "root-storage-size": 0,
      "root-storage-type": "string",
      "source": "string",
      "stream": "string",
      "version": "string",
      "virt-type": "string"
    }
  ]
}
```

<h3 id="list-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ListCloudImageMetadataResult](#schemalistcloudimagemetadataresult)|

<aside class="success">
This operation does not require authentication
</aside>

## save

<a id="opIdsave"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /imagemetadatamanager/save \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /imagemetadatamanager/save HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "metadata": [
    {
      "metadata": [
        {
          "arch": "string",
          "image-id": "string",
          "priority": 0,
          "region": "string",
          "root-storage-size": 0,
          "root-storage-type": "string",
          "source": "string",
          "stream": "string",
          "version": "string",
          "virt-type": "string"
        }
      ]
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/imagemetadatamanager/save',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/imagemetadatamanager/save',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/imagemetadatamanager/save', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/imagemetadatamanager/save', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/imagemetadatamanager/save");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/imagemetadatamanager/save", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /imagemetadatamanager/save`

Stores given cloud image metadata. It supports bulk calls.

> Body parameter

```json
{
  "metadata": [
    {
      "metadata": [
        {
          "arch": "string",
          "image-id": "string",
          "priority": 0,
          "region": "string",
          "root-storage-size": 0,
          "root-storage-type": "string",
          "source": "string",
          "stream": "string",
          "version": "string",
          "virt-type": "string"
        }
      ]
    }
  ]
}
```

<h3 id="save-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[MetadataSaveParams](#schemametadatasaveparams)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="save-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-keymanager">keymanager</h1>

## addKeys

<a id="opIdaddKeys"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /keymanager/addKeys \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /keymanager/addKeys HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "ssh-keys": [
    "string"
  ],
  "user": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/keymanager/addKeys',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/keymanager/addKeys',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/keymanager/addKeys', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/keymanager/addKeys', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/keymanager/addKeys");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/keymanager/addKeys", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /keymanager/addKeys`

Adds new authorised ssh keys for the specified user.

> Body parameter

```json
{
  "ssh-keys": [
    "string"
  ],
  "user": "string"
}
```

<h3 id="addkeys-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ModifyUserSSHKeys](#schemamodifyusersshkeys)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="addkeys-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## deleteKeys

<a id="opIddeleteKeys"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /keymanager/deleteKeys \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /keymanager/deleteKeys HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "ssh-keys": [
    "string"
  ],
  "user": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/keymanager/deleteKeys',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/keymanager/deleteKeys',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/keymanager/deleteKeys', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/keymanager/deleteKeys', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/keymanager/deleteKeys");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/keymanager/deleteKeys", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /keymanager/deleteKeys`

Deletes the authorised ssh keys for the specified user.

> Body parameter

```json
{
  "ssh-keys": [
    "string"
  ],
  "user": "string"
}
```

<h3 id="deletekeys-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ModifyUserSSHKeys](#schemamodifyusersshkeys)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="deletekeys-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## importKeys

<a id="opIdimportKeys"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /keymanager/importKeys \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /keymanager/importKeys HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "ssh-keys": [
    "string"
  ],
  "user": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/keymanager/importKeys',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/keymanager/importKeys',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/keymanager/importKeys', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/keymanager/importKeys', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/keymanager/importKeys");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/keymanager/importKeys", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /keymanager/importKeys`

Imports new authorised ssh keys from the specified key ids for the specified user.

> Body parameter

```json
{
  "ssh-keys": [
    "string"
  ],
  "user": "string"
}
```

<h3 id="importkeys-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ModifyUserSSHKeys](#schemamodifyusersshkeys)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="importkeys-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## listKeys

<a id="opIdlistKeys"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /keymanager/listKeys \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /keymanager/listKeys HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": {
    "entities": [
      {
        "tag": "string"
      }
    ]
  },
  "mode": true
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/keymanager/listKeys',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/keymanager/listKeys',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/keymanager/listKeys', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/keymanager/listKeys', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/keymanager/listKeys");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/keymanager/listKeys", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /keymanager/listKeys`

Returns the authorised ssh keys for the specified users.

> Body parameter

```json
{
  "entities": {
    "entities": [
      {
        "tag": "string"
      }
    ]
  },
  "mode": true
}
```

<h3 id="listkeys-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ListSSHKeys](#schemalistsshkeys)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": [
        "string"
      ]
    }
  ]
}
```

<h3 id="listkeys-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[StringsResults](#schemastringsresults)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-machinemanager">machinemanager</h1>

## addMachines

<a id="opIdaddMachines"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /machinemanager/addMachines \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /machinemanager/addMachines HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "params": [
    {
      "addresses": [
        {
          "cidr": "string",
          "config-type": "string",
          "is-secondary": true,
          "scope": "string",
          "space-id": "string",
          "space-name": "string",
          "type": "string",
          "value": "string"
        }
      ],
      "base": {
        "channel": "string",
        "name": "string"
      },
      "constraints": {
        "allocate-public-ip": true,
        "arch": "string",
        "container": "string",
        "cores": 0,
        "cpu-power": 0,
        "image-id": "string",
        "instance-role": "string",
        "instance-type": "string",
        "mem": 0,
        "root-disk": 0,
        "root-disk-source": "string",
        "spaces": [
          "string"
        ],
        "tags": [
          "string"
        ],
        "virt-type": "string",
        "zones": [
          "string"
        ]
      },
      "container-type": "string",
      "disks": [
        {
          "Count": 0,
          "Pool": "string",
          "Size": 0
        }
      ],
      "hardware-characteristics": {
        "arch": "string",
        "availability-zone": "string",
        "cpu-cores": 0,
        "cpu-power": 0,
        "mem": 0,
        "root-disk": 0,
        "root-disk-source": "string",
        "tags": [
          "string"
        ],
        "virt-type": "string"
      },
      "instance-id": "string",
      "jobs": [
        "string"
      ],
      "nonce": "string",
      "parent-id": "string",
      "placement": {
        "directive": "string",
        "scope": "string"
      }
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/machinemanager/addMachines',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/machinemanager/addMachines',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/machinemanager/addMachines', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/machinemanager/addMachines', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/machinemanager/addMachines");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/machinemanager/addMachines", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /machinemanager/addMachines`

Adds new machines with the supplied parameters. The args will contain Base info.

> Body parameter

```json
{
  "params": [
    {
      "addresses": [
        {
          "cidr": "string",
          "config-type": "string",
          "is-secondary": true,
          "scope": "string",
          "space-id": "string",
          "space-name": "string",
          "type": "string",
          "value": "string"
        }
      ],
      "base": {
        "channel": "string",
        "name": "string"
      },
      "constraints": {
        "allocate-public-ip": true,
        "arch": "string",
        "container": "string",
        "cores": 0,
        "cpu-power": 0,
        "image-id": "string",
        "instance-role": "string",
        "instance-type": "string",
        "mem": 0,
        "root-disk": 0,
        "root-disk-source": "string",
        "spaces": [
          "string"
        ],
        "tags": [
          "string"
        ],
        "virt-type": "string",
        "zones": [
          "string"
        ]
      },
      "container-type": "string",
      "disks": [
        {
          "Count": 0,
          "Pool": "string",
          "Size": 0
        }
      ],
      "hardware-characteristics": {
        "arch": "string",
        "availability-zone": "string",
        "cpu-cores": 0,
        "cpu-power": 0,
        "mem": 0,
        "root-disk": 0,
        "root-disk-source": "string",
        "tags": [
          "string"
        ],
        "virt-type": "string"
      },
      "instance-id": "string",
      "jobs": [
        "string"
      ],
      "nonce": "string",
      "parent-id": "string",
      "placement": {
        "directive": "string",
        "scope": "string"
      }
    }
  ]
}
```

<h3 id="addmachines-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[AddMachines](#schemaaddmachines)|true|none|

> Example responses

> 200 Response

```json
{
  "machines": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "machine": "string"
    }
  ]
}
```

<h3 id="addmachines-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[AddMachinesResults](#schemaaddmachinesresults)|

<aside class="success">
This operation does not require authentication
</aside>

## destroyMachineWithParams

<a id="opIddestroyMachineWithParams"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /machinemanager/destroyMachineWithParams \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /machinemanager/destroyMachineWithParams HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "dry-run": true,
  "force": true,
  "keep": true,
  "machine-tags": [
    "string"
  ],
  "max-wait": 0
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/machinemanager/destroyMachineWithParams',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/machinemanager/destroyMachineWithParams',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/machinemanager/destroyMachineWithParams', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/machinemanager/destroyMachineWithParams', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/machinemanager/destroyMachineWithParams");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/machinemanager/destroyMachineWithParams", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /machinemanager/destroyMachineWithParams`

Removes a set of machines from the model.

> Body parameter

```json
{
  "dry-run": true,
  "force": true,
  "keep": true,
  "machine-tags": [
    "string"
  ],
  "max-wait": 0
}
```

<h3 id="destroymachinewithparams-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[DestroyMachinesParams](#schemadestroymachinesparams)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "info": {
        "destroyed-containers": [
          {}
        ],
        "destroyed-storage": [
          {
            "tag": "string"
          }
        ],
        "destroyed-units": [
          {
            "tag": "string"
          }
        ],
        "detached-storage": [
          {
            "tag": "string"
          }
        ],
        "machine-id": "string"
      }
    }
  ]
}
```

<h3 id="destroymachinewithparams-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[DestroyMachineResults](#schemadestroymachineresults)|

<aside class="success">
This operation does not require authentication
</aside>

## getUpgradeSeriesMessages

<a id="opIdgetUpgradeSeriesMessages"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /machinemanager/getUpgradeSeriesMessages \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /machinemanager/getUpgradeSeriesMessages HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "params": [
    {
      "entity": {
        "tag": "string"
      },
      "watcher-id": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/machinemanager/getUpgradeSeriesMessages',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/machinemanager/getUpgradeSeriesMessages',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/machinemanager/getUpgradeSeriesMessages', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/machinemanager/getUpgradeSeriesMessages', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/machinemanager/getUpgradeSeriesMessages");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/machinemanager/getUpgradeSeriesMessages", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /machinemanager/getUpgradeSeriesMessages`

Returns all new messages associated with upgrade series events. Messages that have already been retrieved once are not returned by this method.

> Body parameter

```json
{
  "params": [
    {
      "entity": {
        "tag": "string"
      },
      "watcher-id": "string"
    }
  ]
}
```

<h3 id="getupgradeseriesmessages-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[UpgradeSeriesNotificationParams](#schemaupgradeseriesnotificationparams)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": [
        "string"
      ]
    }
  ]
}
```

<h3 id="getupgradeseriesmessages-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[StringsResults](#schemastringsresults)|

<aside class="success">
This operation does not require authentication
</aside>

## instanceTypes

<a id="opIdinstanceTypes"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /machinemanager/instanceTypes \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /machinemanager/instanceTypes HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "constraints": [
    {
      "value": {
        "allocate-public-ip": true,
        "arch": "string",
        "container": "string",
        "cores": 0,
        "cpu-power": 0,
        "image-id": "string",
        "instance-role": "string",
        "instance-type": "string",
        "mem": 0,
        "root-disk": 0,
        "root-disk-source": "string",
        "spaces": [
          "string"
        ],
        "tags": [
          "string"
        ],
        "virt-type": "string",
        "zones": [
          "string"
        ]
      }
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/machinemanager/instanceTypes',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/machinemanager/instanceTypes',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/machinemanager/instanceTypes', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/machinemanager/instanceTypes', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/machinemanager/instanceTypes");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/machinemanager/instanceTypes", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /machinemanager/instanceTypes`

Returns instance type information for the cloud and region in which the current model is deployed.

> Body parameter

```json
{
  "constraints": [
    {
      "value": {
        "allocate-public-ip": true,
        "arch": "string",
        "container": "string",
        "cores": 0,
        "cpu-power": 0,
        "image-id": "string",
        "instance-role": "string",
        "instance-type": "string",
        "mem": 0,
        "root-disk": 0,
        "root-disk-source": "string",
        "spaces": [
          "string"
        ],
        "tags": [
          "string"
        ],
        "virt-type": "string",
        "zones": [
          "string"
        ]
      }
    }
  ]
}
```

<h3 id="instancetypes-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ModelInstanceTypesConstraints](#schemamodelinstancetypesconstraints)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "cost-currency": "string",
      "cost-divisor": 0,
      "cost-unit": "string",
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "instance-types": [
        {
          "arches": [
            "string"
          ],
          "cost": 0,
          "cpu-cores": 0,
          "deprecated": true,
          "memory": 0,
          "name": "string",
          "root-disk": 0,
          "virt-type": "string"
        }
      ]
    }
  ]
}
```

<h3 id="instancetypes-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[InstanceTypesResults](#schemainstancetypesresults)|

<aside class="success">
This operation does not require authentication
</aside>

## provisioningScript

<a id="opIdprovisioningScript"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /machinemanager/provisioningScript \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /machinemanager/provisioningScript HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "data-dir": "string",
  "disable-package-commands": true,
  "machine-id": "string",
  "nonce": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/machinemanager/provisioningScript',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/machinemanager/provisioningScript',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/machinemanager/provisioningScript', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/machinemanager/provisioningScript', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/machinemanager/provisioningScript");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/machinemanager/provisioningScript", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /machinemanager/provisioningScript`

Returns a shell script that, when run, provisions a machine agent on the machine executing the script.

> Body parameter

```json
{
  "data-dir": "string",
  "disable-package-commands": true,
  "machine-id": "string",
  "nonce": "string"
}
```

<h3 id="provisioningscript-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ProvisioningScriptParams](#schemaprovisioningscriptparams)|true|none|

> Example responses

> 200 Response

```json
{
  "script": "string"
}
```

<h3 id="provisioningscript-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ProvisioningScriptResult](#schemaprovisioningscriptresult)|

<aside class="success">
This operation does not require authentication
</aside>

## retryProvisioning

<a id="opIdretryProvisioning"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /machinemanager/retryProvisioning \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /machinemanager/retryProvisioning HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "all": true,
  "machines": [
    "string"
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/machinemanager/retryProvisioning',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/machinemanager/retryProvisioning',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/machinemanager/retryProvisioning', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/machinemanager/retryProvisioning', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/machinemanager/retryProvisioning");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/machinemanager/retryProvisioning", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /machinemanager/retryProvisioning`

Marks a provisioning error as transient on the machines.

> Body parameter

```json
{
  "all": true,
  "machines": [
    "string"
  ]
}
```

<h3 id="retryprovisioning-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[RetryProvisioningArgs](#schemaretryprovisioningargs)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="retryprovisioning-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## upgradeSeriesComplete

<a id="opIdupgradeSeriesComplete"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /machinemanager/upgradeSeriesComplete \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /machinemanager/upgradeSeriesComplete HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "channel": "string",
  "force": true,
  "tag": {
    "tag": "string"
  }
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/machinemanager/upgradeSeriesComplete',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/machinemanager/upgradeSeriesComplete',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/machinemanager/upgradeSeriesComplete', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/machinemanager/upgradeSeriesComplete', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/machinemanager/upgradeSeriesComplete");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/machinemanager/upgradeSeriesComplete", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /machinemanager/upgradeSeriesComplete`

Marks a machine as having completed a managed series upgrade.

> Body parameter

```json
{
  "channel": "string",
  "force": true,
  "tag": {
    "tag": "string"
  }
}
```

<h3 id="upgradeseriescomplete-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[UpdateChannelArg](#schemaupdatechannelarg)|true|none|

> Example responses

> 200 Response

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  }
}
```

<h3 id="upgradeseriescomplete-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResult](#schemaerrorresult)|

<aside class="success">
This operation does not require authentication
</aside>

## upgradeSeriesPrepare

<a id="opIdupgradeSeriesPrepare"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /machinemanager/upgradeSeriesPrepare \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /machinemanager/upgradeSeriesPrepare HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "channel": "string",
  "force": true,
  "tag": {
    "tag": "string"
  }
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/machinemanager/upgradeSeriesPrepare',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/machinemanager/upgradeSeriesPrepare',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/machinemanager/upgradeSeriesPrepare', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/machinemanager/upgradeSeriesPrepare', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/machinemanager/upgradeSeriesPrepare");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/machinemanager/upgradeSeriesPrepare", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /machinemanager/upgradeSeriesPrepare`

Prepares a machine for a OS series upgrade.

> Body parameter

```json
{
  "channel": "string",
  "force": true,
  "tag": {
    "tag": "string"
  }
}
```

<h3 id="upgradeseriesprepare-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[UpdateChannelArg](#schemaupdatechannelarg)|true|none|

> Example responses

> 200 Response

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  }
}
```

<h3 id="upgradeseriesprepare-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResult](#schemaerrorresult)|

<aside class="success">
This operation does not require authentication
</aside>

## upgradeSeriesValidate

<a id="opIdupgradeSeriesValidate"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /machinemanager/upgradeSeriesValidate \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /machinemanager/upgradeSeriesValidate HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "args": [
    {
      "channel": "string",
      "force": true,
      "tag": {
        "tag": "string"
      }
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/machinemanager/upgradeSeriesValidate',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/machinemanager/upgradeSeriesValidate',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/machinemanager/upgradeSeriesValidate', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/machinemanager/upgradeSeriesValidate', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/machinemanager/upgradeSeriesValidate");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/machinemanager/upgradeSeriesValidate", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /machinemanager/upgradeSeriesValidate`

Validates that the incoming arguments correspond to a valid series upgrade for the target machine. If they do, a list of the machine's current units is returned for use in soliciting user confirmation of the command.

> Body parameter

```json
{
  "args": [
    {
      "channel": "string",
      "force": true,
      "tag": {
        "tag": "string"
      }
    }
  ]
}
```

<h3 id="upgradeseriesvalidate-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[UpdateChannelArgs](#schemaupdatechannelargs)|true|none|

> Example responses

> 200 Response

```json
{
  "Results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "unit-names": [
        "string"
      ]
    }
  ]
}
```

<h3 id="upgradeseriesvalidate-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[UpgradeSeriesUnitsResults](#schemaupgradeseriesunitsresults)|

<aside class="success">
This operation does not require authentication
</aside>

## watchUpgradeSeriesNotifications

<a id="opIdwatchUpgradeSeriesNotifications"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /machinemanager/watchUpgradeSeriesNotifications \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /machinemanager/watchUpgradeSeriesNotifications HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/machinemanager/watchUpgradeSeriesNotifications',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/machinemanager/watchUpgradeSeriesNotifications',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/machinemanager/watchUpgradeSeriesNotifications', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/machinemanager/watchUpgradeSeriesNotifications', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/machinemanager/watchUpgradeSeriesNotifications");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/machinemanager/watchUpgradeSeriesNotifications", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /machinemanager/watchUpgradeSeriesNotifications`

Returns a watcher that fires on upgrade series events.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="watchupgradeseriesnotifications-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "NotifyWatcherId": "string",
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="watchupgradeseriesnotifications-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[NotifyWatchResults](#schemanotifywatchresults)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-metricsdebug">metricsdebug</h1>

## getMetrics

<a id="opIdgetMetrics"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /metricsdebug/getMetrics \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /metricsdebug/getMetrics HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/metricsdebug/getMetrics',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/metricsdebug/getMetrics',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/metricsdebug/getMetrics', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/metricsdebug/getMetrics', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/metricsdebug/getMetrics");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/metricsdebug/getMetrics", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /metricsdebug/getMetrics`

Returns all metrics stored by the state server.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="getmetrics-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "metrics": [
        {
          "key": "string",
          "labels": {},
          "time": "2019-08-24T14:15:22Z",
          "unit": "string",
          "value": "string"
        }
      ]
    }
  ]
}
```

<h3 id="getmetrics-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[MetricResults](#schemametricresults)|

<aside class="success">
This operation does not require authentication
</aside>

## setMeterStatus

<a id="opIdsetMeterStatus"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /metricsdebug/setMeterStatus \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /metricsdebug/setMeterStatus HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "statues": [
    {
      "code": "string",
      "info": "string",
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/metricsdebug/setMeterStatus',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/metricsdebug/setMeterStatus',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/metricsdebug/setMeterStatus', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/metricsdebug/setMeterStatus', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/metricsdebug/setMeterStatus");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/metricsdebug/setMeterStatus", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /metricsdebug/setMeterStatus`

Sets meter statuses for entities.

> Body parameter

```json
{
  "statues": [
    {
      "code": "string",
      "info": "string",
      "tag": "string"
    }
  ]
}
```

<h3 id="setmeterstatus-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[MeterStatusParams](#schemameterstatusparams)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="setmeterstatus-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-modelconfig">modelconfig</h1>

## getModelConstraints

<a id="opIdgetModelConstraints"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelconfig/getModelConstraints \
  -H 'Accept: application/json'

```

```http
GET /modelconfig/getModelConstraints HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/modelconfig/getModelConstraints',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/modelconfig/getModelConstraints',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/modelconfig/getModelConstraints', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelconfig/getModelConstraints', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelconfig/getModelConstraints");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelconfig/getModelConstraints", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelconfig/getModelConstraints`

Returns the constraints for the model.

> Example responses

> 200 Response

```json
{
  "constraints": {
    "allocate-public-ip": true,
    "arch": "string",
    "container": "string",
    "cores": 0,
    "cpu-power": 0,
    "image-id": "string",
    "instance-role": "string",
    "instance-type": "string",
    "mem": 0,
    "root-disk": 0,
    "root-disk-source": "string",
    "spaces": [
      "string"
    ],
    "tags": [
      "string"
    ],
    "virt-type": "string",
    "zones": [
      "string"
    ]
  }
}
```

<h3 id="getmodelconstraints-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[GetConstraintsResults](#schemagetconstraintsresults)|

<aside class="success">
This operation does not require authentication
</aside>

## modelGet

<a id="opIdmodelGet"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelconfig/modelGet \
  -H 'Accept: application/json'

```

```http
GET /modelconfig/modelGet HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/modelconfig/modelGet',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/modelconfig/modelGet',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/modelconfig/modelGet', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelconfig/modelGet', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelconfig/modelGet");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelconfig/modelGet", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelconfig/modelGet`

Implements the server-side part of the model-config CLI command.

> Example responses

> 200 Response

```json
{
  "config": {}
}
```

<h3 id="modelget-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ModelConfigResults](#schemamodelconfigresults)|

<aside class="success">
This operation does not require authentication
</aside>

## modelSet

<a id="opIdmodelSet"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelconfig/modelSet \
  -H 'Content-Type: application/json'

```

```http
GET /modelconfig/modelSet HTTP/1.1

Content-Type: application/json

```

```javascript
const inputBody = '{
  "config": {}
}';
const headers = {
  'Content-Type':'application/json'
};

fetch('/modelconfig/modelSet',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json'
}

result = RestClient.get '/modelconfig/modelSet',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json'
}

r = requests.get('/modelconfig/modelSet', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelconfig/modelSet', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelconfig/modelSet");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelconfig/modelSet", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelconfig/modelSet`

Implements the server-side part of the set-model-config CLI command.

> Body parameter

```json
{
  "config": {}
}
```

<h3 id="modelset-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ModelSet](#schemamodelset)|true|none|

<h3 id="modelset-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|

<aside class="success">
This operation does not require authentication
</aside>

## modelUnset

<a id="opIdmodelUnset"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelconfig/modelUnset \
  -H 'Content-Type: application/json'

```

```http
GET /modelconfig/modelUnset HTTP/1.1

Content-Type: application/json

```

```javascript
const inputBody = '{
  "keys": [
    "string"
  ]
}';
const headers = {
  'Content-Type':'application/json'
};

fetch('/modelconfig/modelUnset',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json'
}

result = RestClient.get '/modelconfig/modelUnset',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json'
}

r = requests.get('/modelconfig/modelUnset', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelconfig/modelUnset', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelconfig/modelUnset");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelconfig/modelUnset", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelconfig/modelUnset`

Implements the server-side part of the set-model-config CLI command.

> Body parameter

```json
{
  "keys": [
    "string"
  ]
}
```

<h3 id="modelunset-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ModelUnset](#schemamodelunset)|true|none|

<h3 id="modelunset-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|

<aside class="success">
This operation does not require authentication
</aside>

## sLALevel

<a id="opIdsLALevel"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelconfig/sLALevel \
  -H 'Accept: application/json'

```

```http
GET /modelconfig/sLALevel HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/modelconfig/sLALevel',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/modelconfig/sLALevel',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/modelconfig/sLALevel', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelconfig/sLALevel', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelconfig/sLALevel");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelconfig/sLALevel", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelconfig/sLALevel`

Returns the current sla level for the model.

> Example responses

> 200 Response

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": "string"
}
```

<h3 id="slalevel-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[StringResult](#schemastringresult)|

<aside class="success">
This operation does not require authentication
</aside>

## sequences

<a id="opIdsequences"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelconfig/sequences \
  -H 'Accept: application/json'

```

```http
GET /modelconfig/sequences HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/modelconfig/sequences',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/modelconfig/sequences',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/modelconfig/sequences', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelconfig/sequences', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelconfig/sequences");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelconfig/sequences", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelconfig/sequences`

Returns the model's sequence names and next values.

> Example responses

> 200 Response

```json
{
  "sequences": {}
}
```

<h3 id="sequences-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ModelSequencesResult](#schemamodelsequencesresult)|

<aside class="success">
This operation does not require authentication
</aside>

## setModelConstraints

<a id="opIdsetModelConstraints"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelconfig/setModelConstraints \
  -H 'Content-Type: application/json'

```

```http
GET /modelconfig/setModelConstraints HTTP/1.1

Content-Type: application/json

```

```javascript
const inputBody = '{
  "application": "string",
  "constraints": {
    "allocate-public-ip": true,
    "arch": "string",
    "container": "string",
    "cores": 0,
    "cpu-power": 0,
    "image-id": "string",
    "instance-role": "string",
    "instance-type": "string",
    "mem": 0,
    "root-disk": 0,
    "root-disk-source": "string",
    "spaces": [
      "string"
    ],
    "tags": [
      "string"
    ],
    "virt-type": "string",
    "zones": [
      "string"
    ]
  }
}';
const headers = {
  'Content-Type':'application/json'
};

fetch('/modelconfig/setModelConstraints',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json'
}

result = RestClient.get '/modelconfig/setModelConstraints',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json'
}

r = requests.get('/modelconfig/setModelConstraints', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelconfig/setModelConstraints', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelconfig/setModelConstraints");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelconfig/setModelConstraints", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelconfig/setModelConstraints`

Sets the constraints for the model.

> Body parameter

```json
{
  "application": "string",
  "constraints": {
    "allocate-public-ip": true,
    "arch": "string",
    "container": "string",
    "cores": 0,
    "cpu-power": 0,
    "image-id": "string",
    "instance-role": "string",
    "instance-type": "string",
    "mem": 0,
    "root-disk": 0,
    "root-disk-source": "string",
    "spaces": [
      "string"
    ],
    "tags": [
      "string"
    ],
    "virt-type": "string",
    "zones": [
      "string"
    ]
  }
}
```

<h3 id="setmodelconstraints-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[SetConstraints](#schemasetconstraints)|true|none|

<h3 id="setmodelconstraints-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|

<aside class="success">
This operation does not require authentication
</aside>

## setSLALevel

<a id="opIdsetSLALevel"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelconfig/setSLALevel \
  -H 'Content-Type: application/json'

```

```http
GET /modelconfig/setSLALevel HTTP/1.1

Content-Type: application/json

```

```javascript
const inputBody = '{
  "ModelSLAInfo": {
    "level": "string",
    "owner": "string"
  },
  "creds": [
    0
  ],
  "level": "string",
  "owner": "string"
}';
const headers = {
  'Content-Type':'application/json'
};

fetch('/modelconfig/setSLALevel',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json'
}

result = RestClient.get '/modelconfig/setSLALevel',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json'
}

r = requests.get('/modelconfig/setSLALevel', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelconfig/setSLALevel', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelconfig/setSLALevel");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelconfig/setSLALevel", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelconfig/setSLALevel`

Sets the sla level on the model.

> Body parameter

```json
{
  "ModelSLAInfo": {
    "level": "string",
    "owner": "string"
  },
  "creds": [
    0
  ],
  "level": "string",
  "owner": "string"
}
```

<h3 id="setslalevel-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ModelSLA](#schemamodelsla)|true|none|

<h3 id="setslalevel-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-modelgeneration">modelgeneration</h1>

## abortBranch

<a id="opIdabortBranch"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelgeneration/abortBranch \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /modelgeneration/abortBranch HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "branch": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/modelgeneration/abortBranch',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/modelgeneration/abortBranch',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/modelgeneration/abortBranch', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelgeneration/abortBranch', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelgeneration/abortBranch");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelgeneration/abortBranch", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelgeneration/abortBranch`

Aborts the input branch, marking it complete.  However no changes are made applicable to the whole model.  No units may be assigned to the branch when aborting.

> Body parameter

```json
{
  "branch": "string"
}
```

<h3 id="abortbranch-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[BranchArg](#schemabrancharg)|true|none|

> Example responses

> 200 Response

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  }
}
```

<h3 id="abortbranch-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResult](#schemaerrorresult)|

<aside class="success">
This operation does not require authentication
</aside>

## addBranch

<a id="opIdaddBranch"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelgeneration/addBranch \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /modelgeneration/addBranch HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "branch": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/modelgeneration/addBranch',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/modelgeneration/addBranch',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/modelgeneration/addBranch', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelgeneration/addBranch', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelgeneration/addBranch");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelgeneration/addBranch", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelgeneration/addBranch`

Adds a new branch with the input name to the model.

> Body parameter

```json
{
  "branch": "string"
}
```

<h3 id="addbranch-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[BranchArg](#schemabrancharg)|true|none|

> Example responses

> 200 Response

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  }
}
```

<h3 id="addbranch-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResult](#schemaerrorresult)|

<aside class="success">
This operation does not require authentication
</aside>

## branchInfo

<a id="opIdbranchInfo"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelgeneration/branchInfo \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /modelgeneration/branchInfo HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "branches": [
    "string"
  ],
  "detailed": true
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/modelgeneration/branchInfo',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/modelgeneration/branchInfo',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/modelgeneration/branchInfo', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelgeneration/branchInfo', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelgeneration/branchInfo");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelgeneration/branchInfo", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelgeneration/branchInfo`

Will return details of branch identified by the input argument, including units on the branch and the configuration disjoint with the master generation. An error is returned if no in-flight branch matching in input is found.

> Body parameter

```json
{
  "branches": [
    "string"
  ],
  "detailed": true
}
```

<h3 id="branchinfo-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[BranchInfoArgs](#schemabranchinfoargs)|true|none|

> Example responses

> 200 Response

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "generations": [
    {
      "applications": [
        {
          "application": "string",
          "config": {},
          "pending": [
            "string"
          ],
          "progress": "string",
          "tracking": [
            "string"
          ]
        }
      ],
      "branch": "string",
      "completed": 0,
      "completed-by": "string",
      "created": 0,
      "created-by": "string",
      "generation-id": 0
    }
  ]
}
```

<h3 id="branchinfo-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[BranchResults](#schemabranchresults)|

<aside class="success">
This operation does not require authentication
</aside>

## commitBranch

<a id="opIdcommitBranch"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelgeneration/commitBranch \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /modelgeneration/commitBranch HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "branch": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/modelgeneration/commitBranch',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/modelgeneration/commitBranch',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/modelgeneration/commitBranch', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelgeneration/commitBranch', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelgeneration/commitBranch");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelgeneration/commitBranch", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelgeneration/commitBranch`

Commits the input branch, making its changes applicable to the whole model and marking it complete.

> Body parameter

```json
{
  "branch": "string"
}
```

<h3 id="commitbranch-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[BranchArg](#schemabrancharg)|true|none|

> Example responses

> 200 Response

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": 0
}
```

<h3 id="commitbranch-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[IntResult](#schemaintresult)|

<aside class="success">
This operation does not require authentication
</aside>

## hasActiveBranch

<a id="opIdhasActiveBranch"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelgeneration/hasActiveBranch \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /modelgeneration/hasActiveBranch HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "branch": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/modelgeneration/hasActiveBranch',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/modelgeneration/hasActiveBranch',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/modelgeneration/hasActiveBranch', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelgeneration/hasActiveBranch', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelgeneration/hasActiveBranch");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelgeneration/hasActiveBranch", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelgeneration/hasActiveBranch`

Returns a true result if the input model has an "in-flight" branch matching the input name.

> Body parameter

```json
{
  "branch": "string"
}
```

<h3 id="hasactivebranch-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[BranchArg](#schemabrancharg)|true|none|

> Example responses

> 200 Response

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": true
}
```

<h3 id="hasactivebranch-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[BoolResult](#schemaboolresult)|

<aside class="success">
This operation does not require authentication
</aside>

## listCommits

<a id="opIdlistCommits"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelgeneration/listCommits \
  -H 'Accept: application/json'

```

```http
GET /modelgeneration/listCommits HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/modelgeneration/listCommits',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/modelgeneration/listCommits',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/modelgeneration/listCommits', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelgeneration/listCommits', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelgeneration/listCommits");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelgeneration/listCommits", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelgeneration/listCommits`

Will return the commits, hence only branches with generation_id higher than 0

> Example responses

> 200 Response

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "generations": [
    {
      "applications": [
        {
          "application": "string",
          "config": {},
          "pending": [
            "string"
          ],
          "progress": "string",
          "tracking": [
            "string"
          ]
        }
      ],
      "branch": "string",
      "completed": 0,
      "completed-by": "string",
      "created": 0,
      "created-by": "string",
      "generation-id": 0
    }
  ]
}
```

<h3 id="listcommits-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[BranchResults](#schemabranchresults)|

<aside class="success">
This operation does not require authentication
</aside>

## showCommit

<a id="opIdshowCommit"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelgeneration/showCommit \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /modelgeneration/showCommit HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "generation-id": 0
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/modelgeneration/showCommit',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/modelgeneration/showCommit',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/modelgeneration/showCommit', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelgeneration/showCommit', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelgeneration/showCommit");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelgeneration/showCommit", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelgeneration/showCommit`

Will return details a commit given by its generationId An error is returned if either no branch can be found corresponding to the generation id. Or the generation id given is below 1.

> Body parameter

```json
{
  "generation-id": 0
}
```

<h3 id="showcommit-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[GenerationId](#schemagenerationid)|true|none|

> Example responses

> 200 Response

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "generation": {
    "applications": [
      {
        "application": "string",
        "config": {},
        "pending": [
          "string"
        ],
        "progress": "string",
        "tracking": [
          "string"
        ]
      }
    ],
    "branch": "string",
    "completed": 0,
    "completed-by": "string",
    "created": 0,
    "created-by": "string",
    "generation-id": 0
  }
}
```

<h3 id="showcommit-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[GenerationResult](#schemagenerationresult)|

<aside class="success">
This operation does not require authentication
</aside>

## trackBranch

<a id="opIdtrackBranch"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelgeneration/trackBranch \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /modelgeneration/trackBranch HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "branch": "string",
  "entities": [
    {
      "tag": "string"
    }
  ],
  "num-units": 0
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/modelgeneration/trackBranch',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/modelgeneration/trackBranch',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/modelgeneration/trackBranch', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelgeneration/trackBranch', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelgeneration/trackBranch");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelgeneration/trackBranch", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelgeneration/trackBranch`

Marks the input units and/or applications as tracking the input branch, causing them to realise changes made under that branch.

> Body parameter

```json
{
  "branch": "string",
  "entities": [
    {
      "tag": "string"
    }
  ],
  "num-units": 0
}
```

<h3 id="trackbranch-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[BranchTrackArg](#schemabranchtrackarg)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="trackbranch-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-modelmanager">modelmanager</h1>

## changeModelCredential

<a id="opIdchangeModelCredential"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelmanager/changeModelCredential \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /modelmanager/changeModelCredential HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "model-credentials": [
    {
      "credential-tag": "string",
      "model-tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/modelmanager/changeModelCredential',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/modelmanager/changeModelCredential',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/modelmanager/changeModelCredential', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelmanager/changeModelCredential', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelmanager/changeModelCredential");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelmanager/changeModelCredential", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelmanager/changeModelCredential`

Changes cloud credential reference for models. These new cloud credentials must already exist on the controller.

> Body parameter

```json
{
  "model-credentials": [
    {
      "credential-tag": "string",
      "model-tag": "string"
    }
  ]
}
```

<h3 id="changemodelcredential-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ChangeModelCredentialsParams](#schemachangemodelcredentialsparams)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="changemodelcredential-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## createModel

<a id="opIdcreateModel"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelmanager/createModel \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /modelmanager/createModel HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "cloud-tag": "string",
  "config": {},
  "credential": "string",
  "name": "string",
  "owner-tag": "string",
  "region": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/modelmanager/createModel',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/modelmanager/createModel',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/modelmanager/createModel', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelmanager/createModel', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelmanager/createModel");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelmanager/createModel", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelmanager/createModel`

Creates a new model using the account and model config specified in the args.

> Body parameter

```json
{
  "cloud-tag": "string",
  "config": {},
  "credential": "string",
  "name": "string",
  "owner-tag": "string",
  "region": "string"
}
```

<h3 id="createmodel-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ModelCreateArgs](#schemamodelcreateargs)|true|none|

> Example responses

> 200 Response

```json
{
  "agent-version": {
    "Build": 0,
    "Major": 0,
    "Minor": 0,
    "Patch": 0,
    "Tag": "string"
  },
  "cloud-credential-tag": "string",
  "cloud-credential-validity": true,
  "cloud-region": "string",
  "cloud-tag": "string",
  "controller-uuid": "string",
  "default-base": "string",
  "default-series": "string",
  "is-controller": true,
  "life": "string",
  "machines": [
    {
      "display-name": "string",
      "ha-primary": true,
      "hardware": {
        "arch": "string",
        "availability-zone": "string",
        "cores": 0,
        "cpu-power": 0,
        "mem": 0,
        "root-disk": 0,
        "tags": [
          "string"
        ],
        "virt-type": "string"
      },
      "has-vote": true,
      "id": "string",
      "instance-id": "string",
      "message": "string",
      "status": "string",
      "wants-vote": true
    }
  ],
  "migration": {
    "end": "2019-08-24T14:15:22Z",
    "start": "2019-08-24T14:15:22Z",
    "status": "string"
  },
  "name": "string",
  "owner-tag": "string",
  "provider-type": "string",
  "secret-backends": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "id": "string",
      "message": "string",
      "num-secrets": 0,
      "result": {
        "backend-type": "string",
        "config": {},
        "name": "string",
        "token-rotate-interval": 0
      },
      "status": "string"
    }
  ],
  "sla": {
    "level": "string",
    "owner": "string"
  },
  "status": {
    "data": {},
    "info": "string",
    "since": "2019-08-24T14:15:22Z",
    "status": "string"
  },
  "supported-features": [
    {
      "description": "string",
      "name": "string",
      "version": "string"
    }
  ],
  "type": "string",
  "users": [
    {
      "access": "string",
      "display-name": "string",
      "last-connection": "2019-08-24T14:15:22Z",
      "model-tag": "string",
      "user": "string"
    }
  ],
  "uuid": "string"
}
```

<h3 id="createmodel-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ModelInfo](#schemamodelinfo)|

<aside class="success">
This operation does not require authentication
</aside>

## destroyModels

<a id="opIddestroyModels"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelmanager/destroyModels \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /modelmanager/destroyModels HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "models": [
    {
      "destroy-storage": true,
      "force": true,
      "max-wait": 0,
      "model-tag": "string",
      "timeout": 0
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/modelmanager/destroyModels',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/modelmanager/destroyModels',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/modelmanager/destroyModels', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelmanager/destroyModels', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelmanager/destroyModels");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelmanager/destroyModels", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelmanager/destroyModels`

Will try to destroy the specified models. If there is a block on destruction, this method will return an error. From ModelManager v7 onwards, DestroyModels gains 'force' and 'max-wait' parameters.

> Body parameter

```json
{
  "models": [
    {
      "destroy-storage": true,
      "force": true,
      "max-wait": 0,
      "model-tag": "string",
      "timeout": 0
    }
  ]
}
```

<h3 id="destroymodels-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[DestroyModelsParams](#schemadestroymodelsparams)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="destroymodels-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## dumpModels

<a id="opIddumpModels"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelmanager/dumpModels \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /modelmanager/dumpModels HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ],
  "simplified": true
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/modelmanager/dumpModels',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/modelmanager/dumpModels',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/modelmanager/dumpModels', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelmanager/dumpModels', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelmanager/dumpModels");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelmanager/dumpModels", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelmanager/dumpModels`

Will export the models into the database agnostic representation. The user needs to either be a controller admin, or have admin privileges on the model itself.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ],
  "simplified": true
}
```

<h3 id="dumpmodels-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[DumpModelRequest](#schemadumpmodelrequest)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": "string"
    }
  ]
}
```

<h3 id="dumpmodels-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[StringResults](#schemastringresults)|

<aside class="success">
This operation does not require authentication
</aside>

## dumpModelsDB

<a id="opIddumpModelsDB"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelmanager/dumpModelsDB \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /modelmanager/dumpModelsDB HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/modelmanager/dumpModelsDB',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/modelmanager/dumpModelsDB',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/modelmanager/dumpModelsDB', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelmanager/dumpModelsDB', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelmanager/dumpModelsDB");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelmanager/dumpModelsDB", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelmanager/dumpModelsDB`

Will gather all documents from all model collections for the specified model. The map result contains a map of collection names to lists of documents represented as maps.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="dumpmodelsdb-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {}
    }
  ]
}
```

<h3 id="dumpmodelsdb-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[MapResults](#schemamapresults)|

<aside class="success">
This operation does not require authentication
</aside>

## listModelSummaries

<a id="opIdlistModelSummaries"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelmanager/listModelSummaries \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /modelmanager/listModelSummaries HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "all": true,
  "user-tag": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/modelmanager/listModelSummaries',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/modelmanager/listModelSummaries',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/modelmanager/listModelSummaries', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelmanager/listModelSummaries', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelmanager/listModelSummaries");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelmanager/listModelSummaries", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelmanager/listModelSummaries`

Returns models that the specified user has access to in the current server.  Controller admins (superuser) can list models for any user.  Other users can only ask about their own models.

> Body parameter

```json
{
  "all": true,
  "user-tag": "string"
}
```

<h3 id="listmodelsummaries-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ModelSummariesRequest](#schemamodelsummariesrequest)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "agent-version": {
          "Build": 0,
          "Major": 0,
          "Minor": 0,
          "Patch": 0,
          "Tag": "string"
        },
        "cloud-credential-tag": "string",
        "cloud-region": "string",
        "cloud-tag": "string",
        "controller-uuid": "string",
        "counts": [
          {
            "count": 0,
            "entity": "string"
          }
        ],
        "default-series": "string",
        "is-controller": true,
        "last-connection": "2019-08-24T14:15:22Z",
        "life": "string",
        "migration": {
          "end": "2019-08-24T14:15:22Z",
          "start": "2019-08-24T14:15:22Z",
          "status": "string"
        },
        "name": "string",
        "owner-tag": "string",
        "provider-type": "string",
        "sla": {
          "level": "string",
          "owner": "string"
        },
        "status": {
          "data": {},
          "info": "string",
          "since": "2019-08-24T14:15:22Z",
          "status": "string"
        },
        "type": "string",
        "user-access": "string",
        "uuid": "string"
      }
    }
  ]
}
```

<h3 id="listmodelsummaries-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ModelSummaryResults](#schemamodelsummaryresults)|

<aside class="success">
This operation does not require authentication
</aside>

## listModels

<a id="opIdlistModels"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelmanager/listModels \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /modelmanager/listModels HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "tag": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/modelmanager/listModels',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/modelmanager/listModels',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/modelmanager/listModels', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelmanager/listModels', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelmanager/listModels");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelmanager/listModels", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelmanager/listModels`

Returns the models that the specified user has access to in the current server.  Controller admins (superuser) can list models for any user.  Other users can only ask about their own models.

> Body parameter

```json
{
  "tag": "string"
}
```

<h3 id="listmodels-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entity](#schemaentity)|true|none|

> Example responses

> 200 Response

```json
{
  "user-models": [
    {
      "last-connection": "2019-08-24T14:15:22Z",
      "model": {
        "name": "string",
        "owner-tag": "string",
        "type": "string",
        "uuid": "string"
      }
    }
  ]
}
```

<h3 id="listmodels-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[UserModelList](#schemausermodellist)|

<aside class="success">
This operation does not require authentication
</aside>

## modelDefaultsForClouds

<a id="opIdmodelDefaultsForClouds"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelmanager/modelDefaultsForClouds \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /modelmanager/modelDefaultsForClouds HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/modelmanager/modelDefaultsForClouds',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/modelmanager/modelDefaultsForClouds',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/modelmanager/modelDefaultsForClouds', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelmanager/modelDefaultsForClouds', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelmanager/modelDefaultsForClouds");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelmanager/modelDefaultsForClouds", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelmanager/modelDefaultsForClouds`

Returns the default config values for the specified clouds.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="modeldefaultsforclouds-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "config": {},
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="modeldefaultsforclouds-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ModelDefaultsResults](#schemamodeldefaultsresults)|

<aside class="success">
This operation does not require authentication
</aside>

## modelInfo

<a id="opIdmodelInfo"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelmanager/modelInfo \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /modelmanager/modelInfo HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/modelmanager/modelInfo',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/modelmanager/modelInfo',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/modelmanager/modelInfo', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelmanager/modelInfo', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelmanager/modelInfo");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelmanager/modelInfo", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelmanager/modelInfo`

Returns information about the specified models.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="modelinfo-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "agent-version": {
          "Build": 0,
          "Major": 0,
          "Minor": 0,
          "Patch": 0,
          "Tag": "string"
        },
        "cloud-credential-tag": "string",
        "cloud-credential-validity": true,
        "cloud-region": "string",
        "cloud-tag": "string",
        "controller-uuid": "string",
        "default-base": "string",
        "default-series": "string",
        "is-controller": true,
        "life": "string",
        "machines": [
          {
            "display-name": "string",
            "ha-primary": true,
            "hardware": {
              "arch": "string",
              "availability-zone": "string",
              "cores": 0,
              "cpu-power": 0,
              "mem": 0,
              "root-disk": 0,
              "tags": [
                "string"
              ],
              "virt-type": "string"
            },
            "has-vote": true,
            "id": "string",
            "instance-id": "string",
            "message": "string",
            "status": "string",
            "wants-vote": true
          }
        ],
        "migration": {
          "end": "2019-08-24T14:15:22Z",
          "start": "2019-08-24T14:15:22Z",
          "status": "string"
        },
        "name": "string",
        "owner-tag": "string",
        "provider-type": "string",
        "secret-backends": [
          {
            "error": {
              "code": "string",
              "info": {},
              "message": "string"
            },
            "id": "string",
            "message": "string",
            "num-secrets": 0,
            "result": {
              "backend-type": "string",
              "config": {},
              "name": "string",
              "token-rotate-interval": 0
            },
            "status": "string"
          }
        ],
        "sla": {
          "level": "string",
          "owner": "string"
        },
        "status": {
          "data": {},
          "info": "string",
          "since": "2019-08-24T14:15:22Z",
          "status": "string"
        },
        "supported-features": [
          {
            "description": "string",
            "name": "string",
            "version": "string"
          }
        ],
        "type": "string",
        "users": [
          {
            "access": "string",
            "display-name": "string",
            "last-connection": "2019-08-24T14:15:22Z",
            "model-tag": "string",
            "user": "string"
          }
        ],
        "uuid": "string"
      }
    }
  ]
}
```

<h3 id="modelinfo-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ModelInfoResults](#schemamodelinforesults)|

<aside class="success">
This operation does not require authentication
</aside>

## modelStatus

<a id="opIdmodelStatus"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelmanager/modelStatus \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /modelmanager/modelStatus HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/modelmanager/modelStatus',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/modelmanager/modelStatus',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/modelmanager/modelStatus', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelmanager/modelStatus', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelmanager/modelStatus");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelmanager/modelStatus", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelmanager/modelStatus`

Returns a summary of the model.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="modelstatus-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "models": [
    {
      "application-count": 0,
      "applications": [
        {
          "name": "string"
        }
      ],
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "filesystems": [
        {
          "detachable": true,
          "id": "string",
          "message": "string",
          "provider-id": "string",
          "status": "string"
        }
      ],
      "hosted-machine-count": 0,
      "life": "string",
      "machines": [
        {
          "display-name": "string",
          "ha-primary": true,
          "hardware": {
            "arch": "string",
            "availability-zone": "string",
            "cores": 0,
            "cpu-power": 0,
            "mem": 0,
            "root-disk": 0,
            "tags": [
              "string"
            ],
            "virt-type": "string"
          },
          "has-vote": true,
          "id": "string",
          "instance-id": "string",
          "message": "string",
          "status": "string",
          "wants-vote": true
        }
      ],
      "model-tag": "string",
      "owner-tag": "string",
      "type": "string",
      "unit-count": 0,
      "volumes": [
        {
          "detachable": true,
          "id": "string",
          "message": "string",
          "provider-id": "string",
          "status": "string"
        }
      ]
    }
  ]
}
```

<h3 id="modelstatus-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ModelStatusResults](#schemamodelstatusresults)|

<aside class="success">
This operation does not require authentication
</aside>

## modifyModelAccess

<a id="opIdmodifyModelAccess"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelmanager/modifyModelAccess \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /modelmanager/modifyModelAccess HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "changes": [
    {
      "access": "string",
      "action": "string",
      "model-tag": "string",
      "user-tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/modelmanager/modifyModelAccess',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/modelmanager/modifyModelAccess',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/modelmanager/modifyModelAccess', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelmanager/modifyModelAccess', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelmanager/modifyModelAccess");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelmanager/modifyModelAccess", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelmanager/modifyModelAccess`

Changes the model access granted to users.

> Body parameter

```json
{
  "changes": [
    {
      "access": "string",
      "action": "string",
      "model-tag": "string",
      "user-tag": "string"
    }
  ]
}
```

<h3 id="modifymodelaccess-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ModifyModelAccessRequest](#schemamodifymodelaccessrequest)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="modifymodelaccess-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## setModelDefaults

<a id="opIdsetModelDefaults"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelmanager/setModelDefaults \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /modelmanager/setModelDefaults HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "config": [
    {
      "cloud-region": "string",
      "cloud-tag": "string",
      "config": {}
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/modelmanager/setModelDefaults',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/modelmanager/setModelDefaults',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/modelmanager/setModelDefaults', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelmanager/setModelDefaults', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelmanager/setModelDefaults");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelmanager/setModelDefaults", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelmanager/setModelDefaults`

Writes new values for the specified default model settings.

> Body parameter

```json
{
  "config": [
    {
      "cloud-region": "string",
      "cloud-tag": "string",
      "config": {}
    }
  ]
}
```

<h3 id="setmodeldefaults-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[SetModelDefaults](#schemasetmodeldefaults)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="setmodeldefaults-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## unsetModelDefaults

<a id="opIdunsetModelDefaults"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelmanager/unsetModelDefaults \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /modelmanager/unsetModelDefaults HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "keys": [
    {
      "cloud-region": "string",
      "cloud-tag": "string",
      "keys": [
        "string"
      ]
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/modelmanager/unsetModelDefaults',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/modelmanager/unsetModelDefaults',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/modelmanager/unsetModelDefaults', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelmanager/unsetModelDefaults', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelmanager/unsetModelDefaults");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelmanager/unsetModelDefaults", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelmanager/unsetModelDefaults`

Removes the specified default model settings.

> Body parameter

```json
{
  "keys": [
    {
      "cloud-region": "string",
      "cloud-tag": "string",
      "keys": [
        "string"
      ]
    }
  ]
}
```

<h3 id="unsetmodeldefaults-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[UnsetModelDefaults](#schemaunsetmodeldefaults)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="unsetmodeldefaults-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-modelupgrader">modelupgrader</h1>

## abortModelUpgrade

<a id="opIdabortModelUpgrade"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelupgrader/abortModelUpgrade \
  -H 'Content-Type: application/json'

```

```http
GET /modelupgrader/abortModelUpgrade HTTP/1.1

Content-Type: application/json

```

```javascript
const inputBody = '{
  "model-tag": "string"
}';
const headers = {
  'Content-Type':'application/json'
};

fetch('/modelupgrader/abortModelUpgrade',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json'
}

result = RestClient.get '/modelupgrader/abortModelUpgrade',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json'
}

r = requests.get('/modelupgrader/abortModelUpgrade', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelupgrader/abortModelUpgrade', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelupgrader/abortModelUpgrade");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelupgrader/abortModelUpgrade", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelupgrader/abortModelUpgrade`

Aborts and archives the model upgrade synchronisation record, if any.

> Body parameter

```json
{
  "model-tag": "string"
}
```

<h3 id="abortmodelupgrade-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ModelParam](#schemamodelparam)|true|none|

<h3 id="abortmodelupgrade-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|

<aside class="success">
This operation does not require authentication
</aside>

## upgradeModel

<a id="opIdupgradeModel"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /modelupgrader/upgradeModel \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /modelupgrader/upgradeModel HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "agent-stream": "string",
  "dry-run": true,
  "ignore-agent-versions": true,
  "model-tag": "string",
  "target-version": {
    "Build": 0,
    "Major": 0,
    "Minor": 0,
    "Patch": 0,
    "Tag": "string"
  }
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/modelupgrader/upgradeModel',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/modelupgrader/upgradeModel',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/modelupgrader/upgradeModel', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/modelupgrader/upgradeModel', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/modelupgrader/upgradeModel");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/modelupgrader/upgradeModel", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /modelupgrader/upgradeModel`

Upgrades a model.

> Body parameter

```json
{
  "agent-stream": "string",
  "dry-run": true,
  "ignore-agent-versions": true,
  "model-tag": "string",
  "target-version": {
    "Build": 0,
    "Major": 0,
    "Minor": 0,
    "Patch": 0,
    "Tag": "string"
  }
}
```

<h3 id="upgrademodel-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[UpgradeModelParams](#schemaupgrademodelparams)|true|none|

> Example responses

> 200 Response

```json
{
  "chosen-version": {
    "Build": 0,
    "Major": 0,
    "Minor": 0,
    "Patch": 0,
    "Tag": "string"
  },
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  }
}
```

<h3 id="upgrademodel-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[UpgradeModelResult](#schemaupgrademodelresult)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-payloads">payloads</h1>

## list

<a id="opIdlist"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /payloads/list \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /payloads/list HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "patterns": [
    "string"
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/payloads/list',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/payloads/list',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/payloads/list', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/payloads/list', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/payloads/list");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/payloads/list", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /payloads/list`

Builds the list of payloads being tracked for the given unit and IDs. If no IDs are provided then all tracked payloads for the unit are returned.

> Body parameter

```json
{
  "patterns": [
    "string"
  ]
}
```

<h3 id="list-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[PayloadListArgs](#schemapayloadlistargs)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "class": "string",
      "id": "string",
      "labels": [
        "string"
      ],
      "machine": "string",
      "status": "string",
      "type": "string",
      "unit": "string"
    }
  ]
}
```

<h3 id="list-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[PayloadListResults](#schemapayloadlistresults)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-pinger">pinger</h1>

## ping

<a id="opIdping"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /pinger/ping

```

```http
GET /pinger/ping HTTP/1.1

```

```javascript

fetch('/pinger/ping',
{
  method: 'GET'

})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

result = RestClient.get '/pinger/ping',
  params: {
  }

p JSON.parse(result)

```

```python
import requests

r = requests.get('/pinger/ping')

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/pinger/ping', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/pinger/ping");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/pinger/ping", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /pinger/ping`

<h3 id="ping-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|

<aside class="success">
This operation does not require authentication
</aside>

## stop

<a id="opIdstop"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /pinger/stop

```

```http
GET /pinger/stop HTTP/1.1

```

```javascript

fetch('/pinger/stop',
{
  method: 'GET'

})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

result = RestClient.get '/pinger/stop',
  params: {
  }

p JSON.parse(result)

```

```python
import requests

r = requests.get('/pinger/stop')

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/pinger/stop', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/pinger/stop");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/pinger/stop", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /pinger/stop`

<h3 id="stop-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-resources">resources</h1>

## addPendingResources

<a id="opIdaddPendingResources"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /resources/addPendingResources \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /resources/addPendingResources HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "Entity": {
    "tag": "string"
  },
  "charm-origin": {
    "architecture": "string",
    "base": {
      "channel": "string",
      "name": "string"
    },
    "branch": "string",
    "hash": "string",
    "id": "string",
    "instance-key": "string",
    "revision": 0,
    "risk": "string",
    "source": "string",
    "track": "string",
    "type": "string"
  },
  "macaroon": {},
  "resources": [
    {
      "description": "string",
      "fingerprint": [
        0
      ],
      "name": "string",
      "origin": "string",
      "path": "string",
      "revision": 0,
      "size": 0,
      "type": "string"
    }
  ],
  "tag": "string",
  "url": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/resources/addPendingResources',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/resources/addPendingResources',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/resources/addPendingResources', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/resources/addPendingResources', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/resources/addPendingResources");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/resources/addPendingResources", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /resources/addPendingResources`

Adds the provided resources (info) to the Juju model in a pending state, meaning they are not available until resolved. Handles CharmHub and Local charms.

> Body parameter

```json
{
  "Entity": {
    "tag": "string"
  },
  "charm-origin": {
    "architecture": "string",
    "base": {
      "channel": "string",
      "name": "string"
    },
    "branch": "string",
    "hash": "string",
    "id": "string",
    "instance-key": "string",
    "revision": 0,
    "risk": "string",
    "source": "string",
    "track": "string",
    "type": "string"
  },
  "macaroon": {},
  "resources": [
    {
      "description": "string",
      "fingerprint": [
        0
      ],
      "name": "string",
      "origin": "string",
      "path": "string",
      "revision": 0,
      "size": 0,
      "type": "string"
    }
  ],
  "tag": "string",
  "url": "string"
}
```

<h3 id="addpendingresources-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[AddPendingResourcesArgsV2](#schemaaddpendingresourcesargsv2)|true|none|

> Example responses

> 200 Response

```json
{
  "ErrorResult": {
    "error": {
      "code": "string",
      "info": {},
      "message": "string"
    }
  },
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "pending-ids": [
    "string"
  ]
}
```

<h3 id="addpendingresources-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[AddPendingResourcesResult](#schemaaddpendingresourcesresult)|

<aside class="success">
This operation does not require authentication
</aside>

## listResources

<a id="opIdlistResources"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /resources/listResources \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /resources/listResources HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/resources/listResources',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/resources/listResources',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/resources/listResources', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/resources/listResources', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/resources/listResources");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/resources/listResources", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /resources/listResources`

Returns the list of resources for the given application.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="listresources-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ListResourcesArgs](#schemalistresourcesargs)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "ErrorResult": {
        "error": {
          "code": "string",
          "info": {},
          "message": "string"
        }
      },
      "charm-store-resources": [
        {
          "description": "string",
          "fingerprint": [
            0
          ],
          "name": "string",
          "origin": "string",
          "path": "string",
          "revision": 0,
          "size": 0,
          "type": "string"
        }
      ],
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "resources": [
        {
          "CharmResource": {
            "description": "string",
            "fingerprint": [
              0
            ],
            "name": "string",
            "origin": "string",
            "path": "string",
            "revision": 0,
            "size": 0,
            "type": "string"
          },
          "application": "string",
          "description": "string",
          "fingerprint": [
            0
          ],
          "id": "string",
          "name": "string",
          "origin": "string",
          "path": "string",
          "pending-id": "string",
          "revision": 0,
          "size": 0,
          "timestamp": "2019-08-24T14:15:22Z",
          "type": "string",
          "username": "string"
        }
      ],
      "unit-resources": [
        {
          "Entity": {
            "tag": "string"
          },
          "download-progress": {},
          "resources": [
            {
              "CharmResource": {
                "description": "string",
                "fingerprint": [
                  0
                ],
                "name": "string",
                "origin": "string",
                "path": "string",
                "revision": 0,
                "size": 0,
                "type": "string"
              },
              "application": "string",
              "description": "string",
              "fingerprint": [
                0
              ],
              "id": "string",
              "name": "string",
              "origin": "string",
              "path": "string",
              "pending-id": "string",
              "revision": 0,
              "size": 0,
              "timestamp": "2019-08-24T14:15:22Z",
              "type": "string",
              "username": "string"
            }
          ],
          "tag": "string"
        }
      ]
    }
  ]
}
```

<h3 id="listresources-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ResourcesResults](#schemaresourcesresults)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-sshclient">sshclient</h1>

## allAddresses

<a id="opIdallAddresses"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /sshclient/allAddresses \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /sshclient/allAddresses HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/sshclient/allAddresses',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/sshclient/allAddresses',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/sshclient/allAddresses', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/sshclient/allAddresses', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/sshclient/allAddresses");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/sshclient/allAddresses", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /sshclient/allAddresses`

Reports all addresses that might have SSH listening for each entity in args. The result is sorted with public addresses first. Machines and units are supported as entity types.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="alladdresses-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "addresses": [
        "string"
      ],
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="alladdresses-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[SSHAddressesResults](#schemasshaddressesresults)|

<aside class="success">
This operation does not require authentication
</aside>

## modelCredentialForSSH

<a id="opIdmodelCredentialForSSH"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /sshclient/modelCredentialForSSH \
  -H 'Accept: application/json'

```

```http
GET /sshclient/modelCredentialForSSH HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/sshclient/modelCredentialForSSH',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/sshclient/modelCredentialForSSH',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/sshclient/modelCredentialForSSH', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/sshclient/modelCredentialForSSH', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/sshclient/modelCredentialForSSH");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/sshclient/modelCredentialForSSH", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /sshclient/modelCredentialForSSH`

Returns a cloud spec for ssh purpose. This facade call is only used for k8s model.

> Example responses

> 200 Response

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": {
    "cacertificates": [
      "string"
    ],
    "credential": {
      "attrs": {},
      "auth-type": "string",
      "redacted": [
        "string"
      ]
    },
    "endpoint": "string",
    "identity-endpoint": "string",
    "is-controller-cloud": true,
    "name": "string",
    "region": "string",
    "skip-tls-verify": true,
    "storage-endpoint": "string",
    "type": "string"
  }
}
```

<h3 id="modelcredentialforssh-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[CloudSpecResult](#schemacloudspecresult)|

<aside class="success">
This operation does not require authentication
</aside>

## privateAddress

<a id="opIdprivateAddress"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /sshclient/privateAddress \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /sshclient/privateAddress HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/sshclient/privateAddress',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/sshclient/privateAddress',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/sshclient/privateAddress', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/sshclient/privateAddress', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/sshclient/privateAddress");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/sshclient/privateAddress", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /sshclient/privateAddress`

Reports the preferred private network address for one or more entities. Machines and units are supported.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="privateaddress-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "address": "string",
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="privateaddress-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[SSHAddressResults](#schemasshaddressresults)|

<aside class="success">
This operation does not require authentication
</aside>

## proxy

<a id="opIdproxy"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /sshclient/proxy \
  -H 'Accept: application/json'

```

```http
GET /sshclient/proxy HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/sshclient/proxy',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/sshclient/proxy',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/sshclient/proxy', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/sshclient/proxy', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/sshclient/proxy");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/sshclient/proxy", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /sshclient/proxy`

Returns whether SSH connections should be proxied through the controller hosts for the model associated with the API connection.

> Example responses

> 200 Response

```json
{
  "use-proxy": true
}
```

<h3 id="proxy-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[SSHProxyResult](#schemasshproxyresult)|

<aside class="success">
This operation does not require authentication
</aside>

## publicAddress

<a id="opIdpublicAddress"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /sshclient/publicAddress \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /sshclient/publicAddress HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/sshclient/publicAddress',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/sshclient/publicAddress',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/sshclient/publicAddress', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/sshclient/publicAddress', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/sshclient/publicAddress");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/sshclient/publicAddress", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /sshclient/publicAddress`

Reports the preferred public network address for one or more entities. Machines and units are supported.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="publicaddress-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "address": "string",
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="publicaddress-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[SSHAddressResults](#schemasshaddressresults)|

<aside class="success">
This operation does not require authentication
</aside>

## publicKeys

<a id="opIdpublicKeys"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /sshclient/publicKeys \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /sshclient/publicKeys HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/sshclient/publicKeys',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/sshclient/publicKeys',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/sshclient/publicKeys', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/sshclient/publicKeys', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/sshclient/publicKeys");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/sshclient/publicKeys", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /sshclient/publicKeys`

Returns the public SSH hosts for one or more entities. Machines and units are supported.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="publickeys-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "public-keys": [
        "string"
      ]
    }
  ]
}
```

<h3 id="publickeys-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[SSHPublicKeysResults](#schemasshpublickeysresults)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-secretbackends">secretbackends</h1>

## addSecretBackends

<a id="opIdaddSecretBackends"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /secretbackends/addSecretBackends \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /secretbackends/addSecretBackends HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "args": [
    {
      "SecretBackend": {
        "backend-type": "string",
        "config": {},
        "name": "string",
        "token-rotate-interval": 0
      },
      "backend-type": "string",
      "config": {},
      "id": "string",
      "name": "string",
      "token-rotate-interval": 0
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/secretbackends/addSecretBackends',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/secretbackends/addSecretBackends',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/secretbackends/addSecretBackends', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/secretbackends/addSecretBackends', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/secretbackends/addSecretBackends");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/secretbackends/addSecretBackends", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /secretbackends/addSecretBackends`

Adds new secret backends.

> Body parameter

```json
{
  "args": [
    {
      "SecretBackend": {
        "backend-type": "string",
        "config": {},
        "name": "string",
        "token-rotate-interval": 0
      },
      "backend-type": "string",
      "config": {},
      "id": "string",
      "name": "string",
      "token-rotate-interval": 0
    }
  ]
}
```

<h3 id="addsecretbackends-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[AddSecretBackendArgs](#schemaaddsecretbackendargs)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="addsecretbackends-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## listSecretBackends

<a id="opIdlistSecretBackends"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /secretbackends/listSecretBackends \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /secretbackends/listSecretBackends HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "names": [
    "string"
  ],
  "reveal": true
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/secretbackends/listSecretBackends',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/secretbackends/listSecretBackends',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/secretbackends/listSecretBackends', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/secretbackends/listSecretBackends', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/secretbackends/listSecretBackends");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/secretbackends/listSecretBackends", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /secretbackends/listSecretBackends`

Lists available secret backends.

> Body parameter

```json
{
  "names": [
    "string"
  ],
  "reveal": true
}
```

<h3 id="listsecretbackends-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ListSecretBackendsArgs](#schemalistsecretbackendsargs)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "id": "string",
      "message": "string",
      "num-secrets": 0,
      "result": {
        "backend-type": "string",
        "config": {},
        "name": "string",
        "token-rotate-interval": 0
      },
      "status": "string"
    }
  ]
}
```

<h3 id="listsecretbackends-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ListSecretBackendsResults](#schemalistsecretbackendsresults)|

<aside class="success">
This operation does not require authentication
</aside>

## removeSecretBackends

<a id="opIdremoveSecretBackends"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /secretbackends/removeSecretBackends \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /secretbackends/removeSecretBackends HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "args": [
    {
      "force": true,
      "name": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/secretbackends/removeSecretBackends',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/secretbackends/removeSecretBackends',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/secretbackends/removeSecretBackends', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/secretbackends/removeSecretBackends', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/secretbackends/removeSecretBackends");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/secretbackends/removeSecretBackends", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /secretbackends/removeSecretBackends`

Removes secret backends.

> Body parameter

```json
{
  "args": [
    {
      "force": true,
      "name": "string"
    }
  ]
}
```

<h3 id="removesecretbackends-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[RemoveSecretBackendArgs](#schemaremovesecretbackendargs)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="removesecretbackends-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## updateSecretBackends

<a id="opIdupdateSecretBackends"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /secretbackends/updateSecretBackends \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /secretbackends/updateSecretBackends HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "args": [
    {
      "config": {},
      "force": true,
      "name": "string",
      "name-change": "string",
      "reset": [
        "string"
      ],
      "token-rotate-interval": 0
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/secretbackends/updateSecretBackends',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/secretbackends/updateSecretBackends',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/secretbackends/updateSecretBackends', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/secretbackends/updateSecretBackends', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/secretbackends/updateSecretBackends");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/secretbackends/updateSecretBackends", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /secretbackends/updateSecretBackends`

Updates secret backends.

> Body parameter

```json
{
  "args": [
    {
      "config": {},
      "force": true,
      "name": "string",
      "name-change": "string",
      "reset": [
        "string"
      ],
      "token-rotate-interval": 0
    }
  ]
}
```

<h3 id="updatesecretbackends-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[UpdateSecretBackendArgs](#schemaupdatesecretbackendargs)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="updatesecretbackends-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-secrets">secrets</h1>

## listSecrets

<a id="opIdlistSecrets"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /secrets/listSecrets \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /secrets/listSecrets HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "filter": {
    "owner-tag": "string",
    "revision": 0,
    "uri": "string"
  },
  "show-secrets": true
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/secrets/listSecrets',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/secrets/listSecrets',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/secrets/listSecrets', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/secrets/listSecrets', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/secrets/listSecrets");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/secrets/listSecrets", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /secrets/listSecrets`

Lists available secrets.

> Body parameter

```json
{
  "filter": {
    "owner-tag": "string",
    "revision": 0,
    "uri": "string"
  },
  "show-secrets": true
}
```

<h3 id="listsecrets-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[ListSecretsArgs](#schemalistsecretsargs)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "create-time": "2019-08-24T14:15:22Z",
      "description": "string",
      "label": "string",
      "latest-expire-time": "2019-08-24T14:15:22Z",
      "latest-revision": 0,
      "next-rotate-time": "2019-08-24T14:15:22Z",
      "owner-tag": "string",
      "revisions": [
        {
          "backend-name": "string",
          "create-time": "2019-08-24T14:15:22Z",
          "expire-time": "2019-08-24T14:15:22Z",
          "revision": 0,
          "update-time": "2019-08-24T14:15:22Z",
          "value-ref": {
            "backend-id": "string",
            "revision-id": "string"
          }
        }
      ],
      "rotate-policy": "string",
      "update-time": "2019-08-24T14:15:22Z",
      "uri": "string",
      "value": {
        "data": {},
        "error": {
          "code": "string",
          "info": {},
          "message": "string"
        }
      },
      "version": 0
    }
  ]
}
```

<h3 id="listsecrets-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ListSecretResults](#schemalistsecretresults)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-spaces">spaces</h1>

## createSpaces

<a id="opIdcreateSpaces"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /spaces/createSpaces \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /spaces/createSpaces HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "spaces": [
    {
      "cidrs": [
        "string"
      ],
      "provider-id": "string",
      "public": true,
      "space-tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/spaces/createSpaces',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/spaces/createSpaces',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/spaces/createSpaces', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/spaces/createSpaces', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/spaces/createSpaces");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/spaces/createSpaces", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /spaces/createSpaces`

Creates a new Juju network space, associating the specified subnets with it (optional; can be empty).

> Body parameter

```json
{
  "spaces": [
    {
      "cidrs": [
        "string"
      ],
      "provider-id": "string",
      "public": true,
      "space-tag": "string"
    }
  ]
}
```

<h3 id="createspaces-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[CreateSpacesParams](#schemacreatespacesparams)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="createspaces-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## listSpaces

<a id="opIdlistSpaces"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /spaces/listSpaces \
  -H 'Accept: application/json'

```

```http
GET /spaces/listSpaces HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/spaces/listSpaces',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/spaces/listSpaces',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/spaces/listSpaces', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/spaces/listSpaces', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/spaces/listSpaces");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/spaces/listSpaces", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /spaces/listSpaces`

Lists all the available spaces and their associated subnets.

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "id": "string",
      "name": "string",
      "subnets": [
        {
          "cidr": "string",
          "life": "string",
          "provider-id": "string",
          "provider-network-id": "string",
          "provider-space-id": "string",
          "space-tag": "string",
          "status": "string",
          "vlan-tag": 0,
          "zones": [
            "string"
          ]
        }
      ]
    }
  ]
}
```

<h3 id="listspaces-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ListSpacesResults](#schemalistspacesresults)|

<aside class="success">
This operation does not require authentication
</aside>

## moveSubnets

<a id="opIdmoveSubnets"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /spaces/moveSubnets \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /spaces/moveSubnets HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "args": [
    {
      "force": true,
      "space-tag": "string",
      "subnets": [
        "string"
      ]
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/spaces/moveSubnets',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/spaces/moveSubnets',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/spaces/moveSubnets', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/spaces/moveSubnets', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/spaces/moveSubnets");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/spaces/moveSubnets", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /spaces/moveSubnets`

Ensures that the input subnets are in the input space.

> Body parameter

```json
{
  "args": [
    {
      "force": true,
      "space-tag": "string",
      "subnets": [
        "string"
      ]
    }
  ]
}
```

<h3 id="movesubnets-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[MoveSubnetsParams](#schemamovesubnetsparams)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "moved-subnets": [
        {
          "cidr": "string",
          "old-space": "string",
          "subnet": "string"
        }
      ],
      "new-space": "string"
    }
  ]
}
```

<h3 id="movesubnets-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[MoveSubnetsResults](#schemamovesubnetsresults)|

<aside class="success">
This operation does not require authentication
</aside>

## reloadSpaces

<a id="opIdreloadSpaces"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /spaces/reloadSpaces

```

```http
GET /spaces/reloadSpaces HTTP/1.1

```

```javascript

fetch('/spaces/reloadSpaces',
{
  method: 'GET'

})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

result = RestClient.get '/spaces/reloadSpaces',
  params: {
  }

p JSON.parse(result)

```

```python
import requests

r = requests.get('/spaces/reloadSpaces')

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/spaces/reloadSpaces', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/spaces/reloadSpaces");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/spaces/reloadSpaces", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /spaces/reloadSpaces`

Refreshes spaces from substrate

<h3 id="reloadspaces-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|

<aside class="success">
This operation does not require authentication
</aside>

## removeSpace

<a id="opIdremoveSpace"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /spaces/removeSpace \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /spaces/removeSpace HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "space-param": [
    {
      "dry-run": true,
      "force": true,
      "space": {
        "tag": "string"
      }
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/spaces/removeSpace',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/spaces/removeSpace',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/spaces/removeSpace', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/spaces/removeSpace', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/spaces/removeSpace");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/spaces/removeSpace", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /spaces/removeSpace`

Removes a space. Returns SpaceResults if entities/settings are found which makes the deletion not possible.

> Body parameter

```json
{
  "space-param": [
    {
      "dry-run": true,
      "force": true,
      "space": {
        "tag": "string"
      }
    }
  ]
}
```

<h3 id="removespace-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[RemoveSpaceParams](#schemaremovespaceparams)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "bindings": [
        {
          "tag": "string"
        }
      ],
      "constraints": [
        {
          "tag": "string"
        }
      ],
      "controller-settings": [
        "string"
      ],
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="removespace-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[RemoveSpaceResults](#schemaremovespaceresults)|

<aside class="success">
This operation does not require authentication
</aside>

## renameSpace

<a id="opIdrenameSpace"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /spaces/renameSpace \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /spaces/renameSpace HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "changes": [
    {
      "from-space-tag": "string",
      "to-space-tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/spaces/renameSpace',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/spaces/renameSpace',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/spaces/renameSpace', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/spaces/renameSpace', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/spaces/renameSpace");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/spaces/renameSpace", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /spaces/renameSpace`

Renames a space.

> Body parameter

```json
{
  "changes": [
    {
      "from-space-tag": "string",
      "to-space-tag": "string"
    }
  ]
}
```

<h3 id="renamespace-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[RenameSpacesParams](#schemarenamespacesparams)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="renamespace-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## showSpace

<a id="opIdshowSpace"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /spaces/showSpace \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /spaces/showSpace HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/spaces/showSpace',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/spaces/showSpace',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/spaces/showSpace', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/spaces/showSpace', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/spaces/showSpace");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/spaces/showSpace", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /spaces/showSpace`

Shows the spaces for a set of given entities.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="showspace-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "applications": [
        "string"
      ],
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "machine-count": 0,
      "space": {
        "error": {
          "code": "string",
          "info": {},
          "message": "string"
        },
        "id": "string",
        "name": "string",
        "subnets": [
          {
            "cidr": "string",
            "life": "string",
            "provider-id": "string",
            "provider-network-id": "string",
            "provider-space-id": "string",
            "space-tag": "string",
            "status": "string",
            "vlan-tag": 0,
            "zones": [
              "string"
            ]
          }
        ]
      }
    }
  ]
}
```

<h3 id="showspace-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ShowSpaceResults](#schemashowspaceresults)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-storage">storage</h1>

## addToUnit

<a id="opIdaddToUnit"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /storage/addToUnit \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /storage/addToUnit HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "storages": [
    {
      "name": "string",
      "storage": {
        "count": 0,
        "pool": "string",
        "size": 0
      },
      "unit": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/storage/addToUnit',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/storage/addToUnit',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/storage/addToUnit', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/storage/addToUnit', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/storage/addToUnit");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/storage/addToUnit", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /storage/addToUnit`

Validates and creates additional storage instances for units. A "CHANGE" block can block this operation.

> Body parameter

```json
{
  "storages": [
    {
      "name": "string",
      "storage": {
        "count": 0,
        "pool": "string",
        "size": 0
      },
      "unit": "string"
    }
  ]
}
```

<h3 id="addtounit-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[StoragesAddParams](#schemastoragesaddparams)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "storage-tags": [
          "string"
        ]
      }
    }
  ]
}
```

<h3 id="addtounit-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[AddStorageResults](#schemaaddstorageresults)|

<aside class="success">
This operation does not require authentication
</aside>

## attach

<a id="opIdattach"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /storage/attach \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /storage/attach HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "ids": [
    {
      "storage-tag": "string",
      "unit-tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/storage/attach',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/storage/attach',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/storage/attach', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/storage/attach', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/storage/attach");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/storage/attach", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /storage/attach`

Attaches existing storage instances to units. A "CHANGE" block can block this operation.

> Body parameter

```json
{
  "ids": [
    {
      "storage-tag": "string",
      "unit-tag": "string"
    }
  ]
}
```

<h3 id="attach-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[StorageAttachmentIds](#schemastorageattachmentids)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="attach-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## createPool

<a id="opIdcreatePool"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /storage/createPool \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /storage/createPool HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "pools": [
    {
      "attrs": {},
      "name": "string",
      "provider": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/storage/createPool',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/storage/createPool',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/storage/createPool', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/storage/createPool', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/storage/createPool");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/storage/createPool", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /storage/createPool`

Creates a new pool with specified parameters.

> Body parameter

```json
{
  "pools": [
    {
      "attrs": {},
      "name": "string",
      "provider": "string"
    }
  ]
}
```

<h3 id="createpool-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[StoragePoolArgs](#schemastoragepoolargs)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="createpool-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## detachStorage

<a id="opIddetachStorage"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /storage/detachStorage \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /storage/detachStorage HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "force": true,
  "ids": {
    "ids": [
      {
        "storage-tag": "string",
        "unit-tag": "string"
      }
    ]
  },
  "max-wait": 0
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/storage/detachStorage',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/storage/detachStorage',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/storage/detachStorage', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/storage/detachStorage', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/storage/detachStorage");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/storage/detachStorage", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /storage/detachStorage`

Sets the specified storage attachments to Dying, unless they are already Dying or Dead. Any associated, persistent storage will remain alive. This call can be forced.

> Body parameter

```json
{
  "force": true,
  "ids": {
    "ids": [
      {
        "storage-tag": "string",
        "unit-tag": "string"
      }
    ]
  },
  "max-wait": 0
}
```

<h3 id="detachstorage-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[StorageDetachmentParams](#schemastoragedetachmentparams)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="detachstorage-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## import

<a id="opIdimport"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /storage/import \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /storage/import HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "storage": [
    {
      "kind": 0,
      "pool": "string",
      "provider-id": "string",
      "storage-name": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/storage/import',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/storage/import',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/storage/import', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/storage/import', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/storage/import");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/storage/import", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /storage/import`

Imports existing storage into the model. A "CHANGE" block can block this operation.

> Body parameter

```json
{
  "storage": [
    {
      "kind": 0,
      "pool": "string",
      "provider-id": "string",
      "storage-name": "string"
    }
  ]
}
```

<h3 id="import-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[BulkImportStorageParams](#schemabulkimportstorageparams)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "storage-tag": "string"
      }
    }
  ]
}
```

<h3 id="import-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ImportStorageResults](#schemaimportstorageresults)|

<aside class="success">
This operation does not require authentication
</aside>

## listFilesystems

<a id="opIdlistFilesystems"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /storage/listFilesystems \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /storage/listFilesystems HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "filters": [
    {
      "machines": [
        "string"
      ]
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/storage/listFilesystems',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/storage/listFilesystems',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/storage/listFilesystems', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/storage/listFilesystems', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/storage/listFilesystems");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/storage/listFilesystems", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /storage/listFilesystems`

Returns a list of filesystems in the environment matching the provided filter. Each result describes a filesystem in detail, including the filesystem's attachments.

> Body parameter

```json
{
  "filters": [
    {
      "machines": [
        "string"
      ]
    }
  ]
}
```

<h3 id="listfilesystems-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[FilesystemFilters](#schemafilesystemfilters)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": [
        {
          "filesystem-tag": "string",
          "info": {
            "filesystem-id": "string",
            "pool": "string",
            "size": 0
          },
          "life": "string",
          "machine-attachments": {},
          "status": {
            "data": {},
            "info": "string",
            "since": "2019-08-24T14:15:22Z",
            "status": "string"
          },
          "storage": {
            "attachments": {},
            "kind": 0,
            "life": "string",
            "owner-tag": "string",
            "persistent": true,
            "status": {
              "data": {},
              "info": "string",
              "since": "2019-08-24T14:15:22Z",
              "status": "string"
            },
            "storage-tag": "string"
          },
          "unit-attachments": {},
          "volume-tag": "string"
        }
      ]
    }
  ]
}
```

<h3 id="listfilesystems-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[FilesystemDetailsListResults](#schemafilesystemdetailslistresults)|

<aside class="success">
This operation does not require authentication
</aside>

## listPools

<a id="opIdlistPools"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /storage/listPools \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /storage/listPools HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "filters": [
    {
      "names": [
        "string"
      ],
      "providers": [
        "string"
      ]
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/storage/listPools',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/storage/listPools',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/storage/listPools', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/storage/listPools', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/storage/listPools");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/storage/listPools", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /storage/listPools`

Returns a list of pools. If filter is provided, returned list only contains pools that match the filter. Pools can be filtered on names and provider types. If both names and types are provided as filter, pools that match either are returned. This method lists union of pools and environment provider types. If no filter is provided, all pools are returned.

> Body parameter

```json
{
  "filters": [
    {
      "names": [
        "string"
      ],
      "providers": [
        "string"
      ]
    }
  ]
}
```

<h3 id="listpools-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[StoragePoolFilters](#schemastoragepoolfilters)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "storage-pools": [
        {
          "attrs": {},
          "name": "string",
          "provider": "string"
        }
      ]
    }
  ]
}
```

<h3 id="listpools-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[StoragePoolsResults](#schemastoragepoolsresults)|

<aside class="success">
This operation does not require authentication
</aside>

## listStorageDetails

<a id="opIdlistStorageDetails"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /storage/listStorageDetails \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /storage/listStorageDetails HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "filters": [
    {}
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/storage/listStorageDetails',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/storage/listStorageDetails',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/storage/listStorageDetails', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/storage/listStorageDetails', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/storage/listStorageDetails");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/storage/listStorageDetails", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /storage/listStorageDetails`

Returns storage matching a filter.

> Body parameter

```json
{
  "filters": [
    {}
  ]
}
```

<h3 id="liststoragedetails-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[StorageFilters](#schemastoragefilters)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": [
        {
          "attachments": {},
          "kind": 0,
          "life": "string",
          "owner-tag": "string",
          "persistent": true,
          "status": {
            "data": {},
            "info": "string",
            "since": "2019-08-24T14:15:22Z",
            "status": "string"
          },
          "storage-tag": "string"
        }
      ]
    }
  ]
}
```

<h3 id="liststoragedetails-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[StorageDetailsListResults](#schemastoragedetailslistresults)|

<aside class="success">
This operation does not require authentication
</aside>

## listVolumes

<a id="opIdlistVolumes"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /storage/listVolumes \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /storage/listVolumes HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "filters": [
    {
      "machines": [
        "string"
      ]
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/storage/listVolumes',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/storage/listVolumes',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/storage/listVolumes', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/storage/listVolumes', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/storage/listVolumes");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/storage/listVolumes", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /storage/listVolumes`

Lists volumes with the given filters. Each filter produces an independent list of volumes, or an error if the filter is invalid or the volumes could not be listed.

> Body parameter

```json
{
  "filters": [
    {
      "machines": [
        "string"
      ]
    }
  ]
}
```

<h3 id="listvolumes-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[VolumeFilters](#schemavolumefilters)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": [
        {
          "info": {
            "hardware-id": "string",
            "persistent": true,
            "pool": "string",
            "size": 0,
            "volume-id": "string",
            "wwn": "string"
          },
          "life": "string",
          "machine-attachments": {},
          "status": {
            "data": {},
            "info": "string",
            "since": "2019-08-24T14:15:22Z",
            "status": "string"
          },
          "storage": {
            "attachments": {},
            "kind": 0,
            "life": "string",
            "owner-tag": "string",
            "persistent": true,
            "status": {
              "data": {},
              "info": "string",
              "since": "2019-08-24T14:15:22Z",
              "status": "string"
            },
            "storage-tag": "string"
          },
          "unit-attachments": {},
          "volume-tag": "string"
        }
      ]
    }
  ]
}
```

<h3 id="listvolumes-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[VolumeDetailsListResults](#schemavolumedetailslistresults)|

<aside class="success">
This operation does not require authentication
</aside>

## remove

<a id="opIdremove"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /storage/remove \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /storage/remove HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "storage": [
    {
      "destroy-attachments": true,
      "destroy-storage": true,
      "force": true,
      "max-wait": 0,
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/storage/remove',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/storage/remove',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/storage/remove', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/storage/remove', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/storage/remove");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/storage/remove", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /storage/remove`

Sets the specified storage entities to Dying, unless they are already Dying or Dead, such that the storage will eventually be removed from the model. If the arguments specify that the storage should be destroyed, then the associated cloud storage will be destroyed first; otherwise it will only be released from Juju's control.

> Body parameter

```json
{
  "storage": [
    {
      "destroy-attachments": true,
      "destroy-storage": true,
      "force": true,
      "max-wait": 0,
      "tag": "string"
    }
  ]
}
```

<h3 id="remove-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[RemoveStorage](#schemaremovestorage)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="remove-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## removePool

<a id="opIdremovePool"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /storage/removePool \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /storage/removePool HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "pools": [
    {
      "name": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/storage/removePool',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/storage/removePool',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/storage/removePool', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/storage/removePool', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/storage/removePool");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/storage/removePool", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /storage/removePool`

Deletes the named pool

> Body parameter

```json
{
  "pools": [
    {
      "name": "string"
    }
  ]
}
```

<h3 id="removepool-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[StoragePoolDeleteArgs](#schemastoragepooldeleteargs)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="removepool-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## storageDetails

<a id="opIdstorageDetails"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /storage/storageDetails \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /storage/storageDetails HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/storage/storageDetails',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/storage/storageDetails',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/storage/storageDetails', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/storage/storageDetails', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/storage/storageDetails");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/storage/storageDetails", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /storage/storageDetails`

Retrieves and returns detailed information about desired storage identified by supplied tags. If specified storage cannot be retrieved, individual error is returned instead of storage information.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="storagedetails-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "attachments": {},
        "kind": 0,
        "life": "string",
        "owner-tag": "string",
        "persistent": true,
        "status": {
          "data": {},
          "info": "string",
          "since": "2019-08-24T14:15:22Z",
          "status": "string"
        },
        "storage-tag": "string"
      }
    }
  ]
}
```

<h3 id="storagedetails-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[StorageDetailsResults](#schemastoragedetailsresults)|

<aside class="success">
This operation does not require authentication
</aside>

## updatePool

<a id="opIdupdatePool"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /storage/updatePool \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /storage/updatePool HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "pools": [
    {
      "attrs": {},
      "name": "string",
      "provider": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/storage/updatePool',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/storage/updatePool',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/storage/updatePool', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/storage/updatePool', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/storage/updatePool");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/storage/updatePool", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /storage/updatePool`

Deletes the named pool

> Body parameter

```json
{
  "pools": [
    {
      "attrs": {},
      "name": "string",
      "provider": "string"
    }
  ]
}
```

<h3 id="updatepool-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[StoragePoolArgs](#schemastoragepoolargs)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="updatepool-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-subnets">subnets</h1>

## allZones

<a id="opIdallZones"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /subnets/allZones \
  -H 'Accept: application/json'

```

```http
GET /subnets/allZones HTTP/1.1

Accept: application/json

```

```javascript

const headers = {
  'Accept':'application/json'
};

fetch('/subnets/allZones',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/subnets/allZones',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Accept': 'application/json'
}

r = requests.get('/subnets/allZones', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/subnets/allZones', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/subnets/allZones");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/subnets/allZones", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /subnets/allZones`

Returns all availability zones known to Juju. If a zone is unusable, unavailable, or deprecated the Available field will be false.

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "available": true,
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "name": "string"
    }
  ]
}
```

<h3 id="allzones-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ZoneResults](#schemazoneresults)|

<aside class="success">
This operation does not require authentication
</aside>

## listSubnets

<a id="opIdlistSubnets"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /subnets/listSubnets \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /subnets/listSubnets HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "space-tag": "string",
  "zone": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/subnets/listSubnets',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/subnets/listSubnets',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/subnets/listSubnets', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/subnets/listSubnets', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/subnets/listSubnets");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/subnets/listSubnets", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /subnets/listSubnets`

Returns the matching subnets after applying optional filters.

> Body parameter

```json
{
  "space-tag": "string",
  "zone": "string"
}
```

<h3 id="listsubnets-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[SubnetsFilters](#schemasubnetsfilters)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "cidr": "string",
      "life": "string",
      "provider-id": "string",
      "provider-network-id": "string",
      "provider-space-id": "string",
      "space-tag": "string",
      "status": "string",
      "vlan-tag": 0,
      "zones": [
        "string"
      ]
    }
  ]
}
```

<h3 id="listsubnets-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ListSubnetsResults](#schemalistsubnetsresults)|

<aside class="success">
This operation does not require authentication
</aside>

## subnetsByCIDR

<a id="opIdsubnetsByCIDR"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /subnets/subnetsByCIDR \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /subnets/subnetsByCIDR HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "cidrs": [
    "string"
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/subnets/subnetsByCIDR',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/subnets/subnetsByCIDR',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/subnets/subnetsByCIDR', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/subnets/subnetsByCIDR', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/subnets/subnetsByCIDR");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/subnets/subnetsByCIDR", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /subnets/subnetsByCIDR`

Returns the collection of subnets matching each CIDR in the input.

> Body parameter

```json
{
  "cidrs": [
    "string"
  ]
}
```

<h3 id="subnetsbycidr-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[CIDRParams](#schemacidrparams)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "subnets": [
        {
          "Subnet": {
            "cidr": "string",
            "life": "string",
            "provider-id": "string",
            "provider-network-id": "string",
            "provider-space-id": "string",
            "space-tag": "string",
            "status": "string",
            "vlan-tag": 0,
            "zones": [
              "string"
            ]
          },
          "cidr": "string",
          "id": "string",
          "life": "string",
          "provider-id": "string",
          "provider-network-id": "string",
          "provider-space-id": "string",
          "space-tag": "string",
          "status": "string",
          "vlan-tag": 0,
          "zones": [
            "string"
          ]
        }
      ]
    }
  ]
}
```

<h3 id="subnetsbycidr-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[SubnetsResults](#schemasubnetsresults)|

<aside class="success">
This operation does not require authentication
</aside>

<h1 id="juju-client-facade-openapi-generation-usermanager">usermanager</h1>

## addUser

<a id="opIdaddUser"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /usermanager/addUser \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /usermanager/addUser HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "users": [
    {
      "display-name": "string",
      "password": "string",
      "username": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/usermanager/addUser',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/usermanager/addUser',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/usermanager/addUser', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/usermanager/addUser', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/usermanager/addUser");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/usermanager/addUser", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /usermanager/addUser`

Adds a user with a username, and either a password or a randomly generated secret key which will be returned.

> Body parameter

```json
{
  "users": [
    {
      "display-name": "string",
      "password": "string",
      "username": "string"
    }
  ]
}
```

<h3 id="adduser-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[AddUsers](#schemaaddusers)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "secret-key": [
        0
      ],
      "tag": "string"
    }
  ]
}
```

<h3 id="adduser-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[AddUserResults](#schemaadduserresults)|

<aside class="success">
This operation does not require authentication
</aside>

## disableUser

<a id="opIddisableUser"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /usermanager/disableUser \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /usermanager/disableUser HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/usermanager/disableUser',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/usermanager/disableUser',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/usermanager/disableUser', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/usermanager/disableUser', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/usermanager/disableUser");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/usermanager/disableUser", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /usermanager/disableUser`

Disables one or more users.  If the user is already disabled, the action is considered a success.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="disableuser-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="disableuser-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## enableUser

<a id="opIdenableUser"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /usermanager/enableUser \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /usermanager/enableUser HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/usermanager/enableUser',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/usermanager/enableUser',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/usermanager/enableUser', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/usermanager/enableUser', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/usermanager/enableUser");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/usermanager/enableUser", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /usermanager/enableUser`

Enables one or more users.  If the user is already enabled, the action is considered a success.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="enableuser-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="enableuser-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## modelUserInfo

<a id="opIdmodelUserInfo"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /usermanager/modelUserInfo \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /usermanager/modelUserInfo HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/usermanager/modelUserInfo',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/usermanager/modelUserInfo',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/usermanager/modelUserInfo', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/usermanager/modelUserInfo', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/usermanager/modelUserInfo");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/usermanager/modelUserInfo", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /usermanager/modelUserInfo`

Returns information on all users in the model.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="modeluserinfo-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "access": "string",
        "display-name": "string",
        "last-connection": "2019-08-24T14:15:22Z",
        "model-tag": "string",
        "user": "string"
      }
    }
  ]
}
```

<h3 id="modeluserinfo-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ModelUserInfoResults](#schemamodeluserinforesults)|

<aside class="success">
This operation does not require authentication
</aside>

## removeUser

<a id="opIdremoveUser"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /usermanager/removeUser \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /usermanager/removeUser HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/usermanager/removeUser',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/usermanager/removeUser',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/usermanager/removeUser', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/usermanager/removeUser', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/usermanager/removeUser");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/usermanager/removeUser", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /usermanager/removeUser`

Permanently removes a user from the current controller for each entity provided. While the user is permanently removed we keep it's information around for auditing purposes. TODO(redir): Add information about getting deleted user information when we add that capability.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="removeuser-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="removeuser-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## resetPassword

<a id="opIdresetPassword"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /usermanager/resetPassword \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /usermanager/resetPassword HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/usermanager/resetPassword',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/usermanager/resetPassword',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/usermanager/resetPassword', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/usermanager/resetPassword', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/usermanager/resetPassword");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/usermanager/resetPassword", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /usermanager/resetPassword`

Resets password for supplied users by invalidating current passwords (if any) and generating new random secret keys which will be returned. Users cannot reset their own password.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}
```

<h3 id="resetpassword-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Entities](#schemaentities)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "secret-key": [
        0
      ],
      "tag": "string"
    }
  ]
}
```

<h3 id="resetpassword-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[AddUserResults](#schemaadduserresults)|

<aside class="success">
This operation does not require authentication
</aside>

## setPassword

<a id="opIdsetPassword"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /usermanager/setPassword \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /usermanager/setPassword HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "changes": [
    {
      "password": "string",
      "tag": "string"
    }
  ]
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/usermanager/setPassword',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/usermanager/setPassword',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/usermanager/setPassword', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/usermanager/setPassword', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/usermanager/setPassword");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/usermanager/setPassword", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /usermanager/setPassword`

Changes the stored password for the specified users.

> Body parameter

```json
{
  "changes": [
    {
      "password": "string",
      "tag": "string"
    }
  ]
}
```

<h3 id="setpassword-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[EntityPasswords](#schemaentitypasswords)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}
```

<h3 id="setpassword-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[ErrorResults](#schemaerrorresults)|

<aside class="success">
This operation does not require authentication
</aside>

## userInfo

<a id="opIduserInfo"></a>

> Code samples

```shell
# You can also use wget
curl -X GET /usermanager/userInfo \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json'

```

```http
GET /usermanager/userInfo HTTP/1.1

Content-Type: application/json
Accept: application/json

```

```javascript
const inputBody = '{
  "entities": [
    {
      "tag": "string"
    }
  ],
  "include-disabled": true
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'application/json'
};

fetch('/usermanager/userInfo',
{
  method: 'GET',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.get '/usermanager/userInfo',
  params: {
  }, headers: headers

p JSON.parse(result)

```

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.get('/usermanager/userInfo', headers = headers)

print(r.json())

```

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','/usermanager/userInfo', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

```java
URL obj = new URL("/usermanager/userInfo");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "/usermanager/userInfo", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

`GET /usermanager/userInfo`

Returns information on a user.

> Body parameter

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ],
  "include-disabled": true
}
```

<h3 id="userinfo-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[UserInfoRequest](#schemauserinforequest)|true|none|

> Example responses

> 200 Response

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "access": "string",
        "created-by": "string",
        "date-created": "2019-08-24T14:15:22Z",
        "disabled": true,
        "display-name": "string",
        "last-connection": "2019-08-24T14:15:22Z",
        "username": "string"
      }
    }
  ]
}
```

<h3 id="userinfo-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|[UserInfoResults](#schemauserinforesults)|

<aside class="success">
This operation does not require authentication
</aside>

# Schemas

<h2 id="tocS_Action">Action</h2>
<!-- backwards compatibility -->
<a id="schemaaction"></a>
<a id="schema_Action"></a>
<a id="tocSaction"></a>
<a id="tocsaction"></a>

```json
{
  "execution-group": "string",
  "name": "string",
  "parallel": true,
  "parameters": {},
  "receiver": "string",
  "tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|execution-group|string|false|none|none|
|name|string|true|none|none|
|parallel|boolean|false|none|none|
|parameters|object|false|none|none|
|» .*|object|false|none|none|
|receiver|string|true|none|none|
|tag|string|true|none|none|

<h2 id="tocS_ActionMessage">ActionMessage</h2>
<!-- backwards compatibility -->
<a id="schemaactionmessage"></a>
<a id="schema_ActionMessage"></a>
<a id="tocSactionmessage"></a>
<a id="tocsactionmessage"></a>

```json
{
  "message": "string",
  "timestamp": "2019-08-24T14:15:22Z"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|message|string|true|none|none|
|timestamp|string(date-time)|true|none|none|

<h2 id="tocS_ActionResult">ActionResult</h2>
<!-- backwards compatibility -->
<a id="schemaactionresult"></a>
<a id="schema_ActionResult"></a>
<a id="tocSactionresult"></a>
<a id="tocsactionresult"></a>

```json
{
  "action": {
    "execution-group": "string",
    "name": "string",
    "parallel": true,
    "parameters": {},
    "receiver": "string",
    "tag": "string"
  },
  "completed": "2019-08-24T14:15:22Z",
  "enqueued": "2019-08-24T14:15:22Z",
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "log": [
    {
      "message": "string",
      "timestamp": "2019-08-24T14:15:22Z"
    }
  ],
  "message": "string",
  "output": {},
  "started": "2019-08-24T14:15:22Z",
  "status": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|action|[Action](#schemaaction)|false|none|none|
|completed|string(date-time)|false|none|none|
|enqueued|string(date-time)|false|none|none|
|error|[Error](#schemaerror)|false|none|none|
|log|[[ActionMessage](#schemaactionmessage)]|false|none|none|
|message|string|false|none|none|
|output|object|false|none|none|
|» .*|object|false|none|none|
|started|string(date-time)|false|none|none|
|status|string|false|none|none|

<h2 id="tocS_ActionResults">ActionResults</h2>
<!-- backwards compatibility -->
<a id="schemaactionresults"></a>
<a id="schema_ActionResults"></a>
<a id="tocSactionresults"></a>
<a id="tocsactionresults"></a>

```json
{
  "results": [
    {
      "action": {
        "execution-group": "string",
        "name": "string",
        "parallel": true,
        "parameters": {},
        "receiver": "string",
        "tag": "string"
      },
      "completed": "2019-08-24T14:15:22Z",
      "enqueued": "2019-08-24T14:15:22Z",
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "log": [
        {
          "message": "string",
          "timestamp": "2019-08-24T14:15:22Z"
        }
      ],
      "message": "string",
      "output": {},
      "started": "2019-08-24T14:15:22Z",
      "status": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[ActionResult](#schemaactionresult)]|false|none|none|

<h2 id="tocS_ActionSpec">ActionSpec</h2>
<!-- backwards compatibility -->
<a id="schemaactionspec"></a>
<a id="schema_ActionSpec"></a>
<a id="tocSactionspec"></a>
<a id="tocsactionspec"></a>

```json
{
  "description": "string",
  "params": {}
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|description|string|true|none|none|
|params|object|true|none|none|
|» .*|object|false|none|none|

<h2 id="tocS_Actions">Actions</h2>
<!-- backwards compatibility -->
<a id="schemaactions"></a>
<a id="schema_Actions"></a>
<a id="tocSactions"></a>
<a id="tocsactions"></a>

```json
{
  "actions": [
    {
      "execution-group": "string",
      "name": "string",
      "parallel": true,
      "parameters": {},
      "receiver": "string",
      "tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|actions|[[Action](#schemaaction)]|false|none|none|

<h2 id="tocS_ApplicationCharmActionsResult">ApplicationCharmActionsResult</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationcharmactionsresult"></a>
<a id="schema_ApplicationCharmActionsResult"></a>
<a id="tocSapplicationcharmactionsresult"></a>
<a id="tocsapplicationcharmactionsresult"></a>

```json
{
  "actions": {},
  "application-tag": "string",
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|actions|object|false|none|none|
|» .*|[ActionSpec](#schemaactionspec)|false|none|none|
|application-tag|string|false|none|none|
|error|[Error](#schemaerror)|false|none|none|

<h2 id="tocS_ApplicationsCharmActionsResults">ApplicationsCharmActionsResults</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationscharmactionsresults"></a>
<a id="schema_ApplicationsCharmActionsResults"></a>
<a id="tocSapplicationscharmactionsresults"></a>
<a id="tocsapplicationscharmactionsresults"></a>

```json
{
  "results": [
    {
      "actions": {},
      "application-tag": "string",
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[ApplicationCharmActionsResult](#schemaapplicationcharmactionsresult)]|false|none|none|

<h2 id="tocS_EnqueuedActions">EnqueuedActions</h2>
<!-- backwards compatibility -->
<a id="schemaenqueuedactions"></a>
<a id="schema_EnqueuedActions"></a>
<a id="tocSenqueuedactions"></a>
<a id="tocsenqueuedactions"></a>

```json
{
  "actions": [
    {
      "action": {
        "execution-group": "string",
        "name": "string",
        "parallel": true,
        "parameters": {},
        "receiver": "string",
        "tag": "string"
      },
      "completed": "2019-08-24T14:15:22Z",
      "enqueued": "2019-08-24T14:15:22Z",
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "log": [
        {
          "message": "string",
          "timestamp": "2019-08-24T14:15:22Z"
        }
      ],
      "message": "string",
      "output": {},
      "started": "2019-08-24T14:15:22Z",
      "status": "string"
    }
  ],
  "operation": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|actions|[[ActionResult](#schemaactionresult)]|false|none|none|
|operation|string|true|none|none|

<h2 id="tocS_Entities">Entities</h2>
<!-- backwards compatibility -->
<a id="schemaentities"></a>
<a id="schema_Entities"></a>
<a id="tocSentities"></a>
<a id="tocsentities"></a>

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|entities|[[Entity](#schemaentity)]|true|none|none|

<h2 id="tocS_Entity">Entity</h2>
<!-- backwards compatibility -->
<a id="schemaentity"></a>
<a id="schema_Entity"></a>
<a id="tocSentity"></a>
<a id="tocsentity"></a>

```json
{
  "tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|tag|string|true|none|none|

<h2 id="tocS_Error">Error</h2>
<!-- backwards compatibility -->
<a id="schemaerror"></a>
<a id="schema_Error"></a>
<a id="tocSerror"></a>
<a id="tocserror"></a>

```json
{
  "code": "string",
  "info": {},
  "message": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|code|string|true|none|none|
|info|object|false|none|none|
|» .*|object|false|none|none|
|message|string|true|none|none|

<h2 id="tocS_OperationQueryArgs">OperationQueryArgs</h2>
<!-- backwards compatibility -->
<a id="schemaoperationqueryargs"></a>
<a id="schema_OperationQueryArgs"></a>
<a id="tocSoperationqueryargs"></a>
<a id="tocsoperationqueryargs"></a>

```json
{
  "actions": [
    "string"
  ],
  "applications": [
    "string"
  ],
  "limit": 0,
  "machines": [
    "string"
  ],
  "offset": 0,
  "status": [
    "string"
  ],
  "units": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|actions|[string]|false|none|none|
|applications|[string]|false|none|none|
|limit|integer|false|none|none|
|machines|[string]|false|none|none|
|offset|integer|false|none|none|
|status|[string]|false|none|none|
|units|[string]|false|none|none|

<h2 id="tocS_OperationResult">OperationResult</h2>
<!-- backwards compatibility -->
<a id="schemaoperationresult"></a>
<a id="schema_OperationResult"></a>
<a id="tocSoperationresult"></a>
<a id="tocsoperationresult"></a>

```json
{
  "actions": [
    {
      "action": {
        "execution-group": "string",
        "name": "string",
        "parallel": true,
        "parameters": {},
        "receiver": "string",
        "tag": "string"
      },
      "completed": "2019-08-24T14:15:22Z",
      "enqueued": "2019-08-24T14:15:22Z",
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "log": [
        {
          "message": "string",
          "timestamp": "2019-08-24T14:15:22Z"
        }
      ],
      "message": "string",
      "output": {},
      "started": "2019-08-24T14:15:22Z",
      "status": "string"
    }
  ],
  "completed": "2019-08-24T14:15:22Z",
  "enqueued": "2019-08-24T14:15:22Z",
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "fail": "string",
  "operation": "string",
  "started": "2019-08-24T14:15:22Z",
  "status": "string",
  "summary": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|actions|[[ActionResult](#schemaactionresult)]|false|none|none|
|completed|string(date-time)|false|none|none|
|enqueued|string(date-time)|false|none|none|
|error|[Error](#schemaerror)|false|none|none|
|fail|string|false|none|none|
|operation|string|true|none|none|
|started|string(date-time)|false|none|none|
|status|string|false|none|none|
|summary|string|true|none|none|

<h2 id="tocS_OperationResults">OperationResults</h2>
<!-- backwards compatibility -->
<a id="schemaoperationresults"></a>
<a id="schema_OperationResults"></a>
<a id="tocSoperationresults"></a>
<a id="tocsoperationresults"></a>

```json
{
  "results": [
    {
      "actions": [
        {
          "action": {
            "execution-group": "string",
            "name": "string",
            "parallel": true,
            "parameters": {},
            "receiver": "string",
            "tag": "string"
          },
          "completed": "2019-08-24T14:15:22Z",
          "enqueued": "2019-08-24T14:15:22Z",
          "error": {
            "code": "string",
            "info": {},
            "message": "string"
          },
          "log": [
            {
              "message": "string",
              "timestamp": "2019-08-24T14:15:22Z"
            }
          ],
          "message": "string",
          "output": {},
          "started": "2019-08-24T14:15:22Z",
          "status": "string"
        }
      ],
      "completed": "2019-08-24T14:15:22Z",
      "enqueued": "2019-08-24T14:15:22Z",
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "fail": "string",
      "operation": "string",
      "started": "2019-08-24T14:15:22Z",
      "status": "string",
      "summary": "string"
    }
  ],
  "truncated": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[OperationResult](#schemaoperationresult)]|false|none|none|
|truncated|boolean|false|none|none|

<h2 id="tocS_RunParams">RunParams</h2>
<!-- backwards compatibility -->
<a id="schemarunparams"></a>
<a id="schema_RunParams"></a>
<a id="tocSrunparams"></a>
<a id="tocsrunparams"></a>

```json
{
  "applications": [
    "string"
  ],
  "commands": "string",
  "execution-group": "string",
  "machines": [
    "string"
  ],
  "parallel": true,
  "timeout": 0,
  "units": [
    "string"
  ],
  "workload-context": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|applications|[string]|false|none|none|
|commands|string|true|none|none|
|execution-group|string|false|none|none|
|machines|[string]|false|none|none|
|parallel|boolean|false|none|none|
|timeout|integer|true|none|none|
|units|[string]|false|none|none|
|workload-context|boolean|false|none|none|

<h2 id="tocS_StringsWatchResult">StringsWatchResult</h2>
<!-- backwards compatibility -->
<a id="schemastringswatchresult"></a>
<a id="schema_StringsWatchResult"></a>
<a id="tocSstringswatchresult"></a>
<a id="tocsstringswatchresult"></a>

```json
{
  "changes": [
    "string"
  ],
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "watcher-id": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|changes|[string]|false|none|none|
|error|[Error](#schemaerror)|false|none|none|
|watcher-id|string|true|none|none|

<h2 id="tocS_StringsWatchResults">StringsWatchResults</h2>
<!-- backwards compatibility -->
<a id="schemastringswatchresults"></a>
<a id="schema_StringsWatchResults"></a>
<a id="tocSstringswatchresults"></a>
<a id="tocsstringswatchresults"></a>

```json
{
  "results": [
    {
      "changes": [
        "string"
      ],
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "watcher-id": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[StringsWatchResult](#schemastringswatchresult)]|true|none|none|

<h2 id="tocS_Address">Address</h2>
<!-- backwards compatibility -->
<a id="schemaaddress"></a>
<a id="schema_Address"></a>
<a id="tocSaddress"></a>
<a id="tocsaddress"></a>

```json
{
  "cidr": "string",
  "config-type": "string",
  "is-secondary": true,
  "scope": "string",
  "space-id": "string",
  "space-name": "string",
  "type": "string",
  "value": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|cidr|string|false|none|none|
|config-type|string|false|none|none|
|is-secondary|boolean|false|none|none|
|scope|string|true|none|none|
|space-id|string|false|none|none|
|space-name|string|false|none|none|
|type|string|true|none|none|
|value|string|true|none|none|

<h2 id="tocS_AuthUserInfo">AuthUserInfo</h2>
<!-- backwards compatibility -->
<a id="schemaauthuserinfo"></a>
<a id="schema_AuthUserInfo"></a>
<a id="tocSauthuserinfo"></a>
<a id="tocsauthuserinfo"></a>

```json
{
  "controller-access": "string",
  "credentials": "string",
  "display-name": "string",
  "identity": "string",
  "last-connection": "2019-08-24T14:15:22Z",
  "model-access": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|controller-access|string|true|none|none|
|credentials|string|false|none|none|
|display-name|string|true|none|none|
|identity|string|true|none|none|
|last-connection|string(date-time)|false|none|none|
|model-access|string|true|none|none|

<h2 id="tocS_FacadeVersions">FacadeVersions</h2>
<!-- backwards compatibility -->
<a id="schemafacadeversions"></a>
<a id="schema_FacadeVersions"></a>
<a id="tocSfacadeversions"></a>
<a id="tocsfacadeversions"></a>

```json
{
  "name": "string",
  "versions": [
    0
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|name|string|true|none|none|
|versions|[integer]|true|none|none|

<h2 id="tocS_HostPort">HostPort</h2>
<!-- backwards compatibility -->
<a id="schemahostport"></a>
<a id="schema_HostPort"></a>
<a id="tocShostport"></a>
<a id="tocshostport"></a>

```json
{
  "Address": {
    "cidr": "string",
    "config-type": "string",
    "is-secondary": true,
    "scope": "string",
    "space-id": "string",
    "space-name": "string",
    "type": "string",
    "value": "string"
  },
  "cidr": "string",
  "config-type": "string",
  "is-secondary": true,
  "port": 0,
  "scope": "string",
  "space-id": "string",
  "space-name": "string",
  "type": "string",
  "value": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|Address|[Address](#schemaaddress)|true|none|none|
|cidr|string|false|none|none|
|config-type|string|false|none|none|
|is-secondary|boolean|false|none|none|
|port|integer|true|none|none|
|scope|string|true|none|none|
|space-id|string|false|none|none|
|space-name|string|false|none|none|
|type|string|true|none|none|
|value|string|true|none|none|

<h2 id="tocS_LoginRequest">LoginRequest</h2>
<!-- backwards compatibility -->
<a id="schemaloginrequest"></a>
<a id="schema_LoginRequest"></a>
<a id="tocSloginrequest"></a>
<a id="tocsloginrequest"></a>

```json
{
  "auth-tag": "string",
  "bakery-version": 0,
  "cli-args": "string",
  "client-version": "string",
  "credentials": "string",
  "macaroons": [
    [
      {}
    ]
  ],
  "nonce": "string",
  "user-data": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|auth-tag|string|true|none|none|
|bakery-version|integer|false|none|none|
|cli-args|string|false|none|none|
|client-version|string|false|none|none|
|credentials|string|true|none|none|
|macaroons|[array]|true|none|none|
|nonce|string|true|none|none|
|user-data|string|true|none|none|

<h2 id="tocS_LoginResult">LoginResult</h2>
<!-- backwards compatibility -->
<a id="schemaloginresult"></a>
<a id="schema_LoginResult"></a>
<a id="tocSloginresult"></a>
<a id="tocsloginresult"></a>

```json
{
  "bakery-discharge-required": {},
  "controller-tag": "string",
  "discharge-required": {},
  "discharge-required-error": "string",
  "facades": [
    {
      "name": "string",
      "versions": [
        0
      ]
    }
  ],
  "model-tag": "string",
  "public-dns-name": "string",
  "server-version": "string",
  "servers": [
    [
      {
        "Address": {
          "cidr": "string",
          "config-type": "string",
          "is-secondary": true,
          "scope": "string",
          "space-id": "string",
          "space-name": "string",
          "type": "string",
          "value": "string"
        },
        "cidr": "string",
        "config-type": "string",
        "is-secondary": true,
        "port": 0,
        "scope": "string",
        "space-id": "string",
        "space-name": "string",
        "type": "string",
        "value": "string"
      }
    ]
  ],
  "user-info": {
    "controller-access": "string",
    "credentials": "string",
    "display-name": "string",
    "identity": "string",
    "last-connection": "2019-08-24T14:15:22Z",
    "model-access": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|bakery-discharge-required|[Macaroon](#schemamacaroon)|false|none|none|
|controller-tag|string|false|none|none|
|discharge-required|[Macaroon](#schemamacaroon)|false|none|none|
|discharge-required-error|string|false|none|none|
|facades|[[FacadeVersions](#schemafacadeversions)]|false|none|none|
|model-tag|string|false|none|none|
|public-dns-name|string|false|none|none|
|server-version|string|false|none|none|
|servers|[array]|false|none|none|
|user-info|[AuthUserInfo](#schemaauthuserinfo)|false|none|none|

<h2 id="tocS_Macaroon">Macaroon</h2>
<!-- backwards compatibility -->
<a id="schemamacaroon"></a>
<a id="schema_Macaroon"></a>
<a id="tocSmacaroon"></a>
<a id="tocsmacaroon"></a>

```json
{}

```

### Properties

*None*

<h2 id="tocS_RedirectInfoResult">RedirectInfoResult</h2>
<!-- backwards compatibility -->
<a id="schemaredirectinforesult"></a>
<a id="schema_RedirectInfoResult"></a>
<a id="tocSredirectinforesult"></a>
<a id="tocsredirectinforesult"></a>

```json
{
  "ca-cert": "string",
  "servers": [
    [
      {
        "Address": {
          "cidr": "string",
          "config-type": "string",
          "is-secondary": true,
          "scope": "string",
          "space-id": "string",
          "space-name": "string",
          "type": "string",
          "value": "string"
        },
        "cidr": "string",
        "config-type": "string",
        "is-secondary": true,
        "port": 0,
        "scope": "string",
        "space-id": "string",
        "space-name": "string",
        "type": "string",
        "value": "string"
      }
    ]
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|ca-cert|string|true|none|none|
|servers|[array]|true|none|none|

<h2 id="tocS_AllWatcherNextResults">AllWatcherNextResults</h2>
<!-- backwards compatibility -->
<a id="schemaallwatchernextresults"></a>
<a id="schema_AllWatcherNextResults"></a>
<a id="tocSallwatchernextresults"></a>
<a id="tocsallwatchernextresults"></a>

```json
{
  "deltas": [
    {
      "entity": {},
      "removed": true
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|deltas|[[Delta](#schemadelta)]|true|none|none|

<h2 id="tocS_Delta">Delta</h2>
<!-- backwards compatibility -->
<a id="schemadelta"></a>
<a id="schema_Delta"></a>
<a id="tocSdelta"></a>
<a id="tocsdelta"></a>

```json
{
  "entity": {},
  "removed": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|entity|object|true|none|none|
|removed|boolean|true|none|none|

<h2 id="tocS_AnnotationsGetResult">AnnotationsGetResult</h2>
<!-- backwards compatibility -->
<a id="schemaannotationsgetresult"></a>
<a id="schema_AnnotationsGetResult"></a>
<a id="tocSannotationsgetresult"></a>
<a id="tocsannotationsgetresult"></a>

```json
{
  "annotations": {},
  "entity": "string",
  "error": {
    "error": {
      "code": "string",
      "info": {},
      "message": "string"
    }
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|annotations|object|true|none|none|
|» .*|string|false|none|none|
|entity|string|true|none|none|
|error|[ErrorResult](#schemaerrorresult)|false|none|none|

<h2 id="tocS_AnnotationsGetResults">AnnotationsGetResults</h2>
<!-- backwards compatibility -->
<a id="schemaannotationsgetresults"></a>
<a id="schema_AnnotationsGetResults"></a>
<a id="tocSannotationsgetresults"></a>
<a id="tocsannotationsgetresults"></a>

```json
{
  "results": [
    {
      "annotations": {},
      "entity": "string",
      "error": {
        "error": {
          "code": "string",
          "info": {},
          "message": "string"
        }
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[AnnotationsGetResult](#schemaannotationsgetresult)]|true|none|none|

<h2 id="tocS_AnnotationsSet">AnnotationsSet</h2>
<!-- backwards compatibility -->
<a id="schemaannotationsset"></a>
<a id="schema_AnnotationsSet"></a>
<a id="tocSannotationsset"></a>
<a id="tocsannotationsset"></a>

```json
{
  "annotations": [
    {
      "annotations": {},
      "entity": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|annotations|[[EntityAnnotations](#schemaentityannotations)]|true|none|none|

<h2 id="tocS_EntityAnnotations">EntityAnnotations</h2>
<!-- backwards compatibility -->
<a id="schemaentityannotations"></a>
<a id="schema_EntityAnnotations"></a>
<a id="tocSentityannotations"></a>
<a id="tocsentityannotations"></a>

```json
{
  "annotations": {},
  "entity": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|annotations|object|true|none|none|
|» .*|string|false|none|none|
|entity|string|true|none|none|

<h2 id="tocS_ErrorResult">ErrorResult</h2>
<!-- backwards compatibility -->
<a id="schemaerrorresult"></a>
<a id="schema_ErrorResult"></a>
<a id="tocSerrorresult"></a>
<a id="tocserrorresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|

<h2 id="tocS_ErrorResults">ErrorResults</h2>
<!-- backwards compatibility -->
<a id="schemaerrorresults"></a>
<a id="schema_ErrorResults"></a>
<a id="tocSerrorresults"></a>
<a id="tocserrorresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[ErrorResult](#schemaerrorresult)]|true|none|none|

<h2 id="tocS_AddApplicationUnits">AddApplicationUnits</h2>
<!-- backwards compatibility -->
<a id="schemaaddapplicationunits"></a>
<a id="schema_AddApplicationUnits"></a>
<a id="tocSaddapplicationunits"></a>
<a id="tocsaddapplicationunits"></a>

```json
{
  "application": "string",
  "attach-storage": [
    "string"
  ],
  "num-units": 0,
  "placement": [
    {
      "directive": "string",
      "scope": "string"
    }
  ],
  "policy": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|application|string|true|none|none|
|attach-storage|[string]|false|none|none|
|num-units|integer|true|none|none|
|placement|[[Placement](#schemaplacement)]|true|none|none|
|policy|string|false|none|none|

<h2 id="tocS_AddApplicationUnitsResults">AddApplicationUnitsResults</h2>
<!-- backwards compatibility -->
<a id="schemaaddapplicationunitsresults"></a>
<a id="schema_AddApplicationUnitsResults"></a>
<a id="tocSaddapplicationunitsresults"></a>
<a id="tocsaddapplicationunitsresults"></a>

```json
{
  "units": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|units|[string]|true|none|none|

<h2 id="tocS_AddRelation">AddRelation</h2>
<!-- backwards compatibility -->
<a id="schemaaddrelation"></a>
<a id="schema_AddRelation"></a>
<a id="tocSaddrelation"></a>
<a id="tocsaddrelation"></a>

```json
{
  "endpoints": [
    "string"
  ],
  "via-cidrs": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|endpoints|[string]|true|none|none|
|via-cidrs|[string]|false|none|none|

<h2 id="tocS_AddRelationResults">AddRelationResults</h2>
<!-- backwards compatibility -->
<a id="schemaaddrelationresults"></a>
<a id="schema_AddRelationResults"></a>
<a id="tocSaddrelationresults"></a>
<a id="tocsaddrelationresults"></a>

```json
{
  "endpoints": {}
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|endpoints|object|true|none|none|
|» .*|[CharmRelation](#schemacharmrelation)|false|none|none|

<h2 id="tocS_ApplicationCharmRelations">ApplicationCharmRelations</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationcharmrelations"></a>
<a id="schema_ApplicationCharmRelations"></a>
<a id="tocSapplicationcharmrelations"></a>
<a id="tocsapplicationcharmrelations"></a>

```json
{
  "application": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|application|string|true|none|none|

<h2 id="tocS_ApplicationCharmRelationsResults">ApplicationCharmRelationsResults</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationcharmrelationsresults"></a>
<a id="schema_ApplicationCharmRelationsResults"></a>
<a id="tocSapplicationcharmrelationsresults"></a>
<a id="tocsapplicationcharmrelationsresults"></a>

```json
{
  "charm-relations": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|charm-relations|[string]|true|none|none|

<h2 id="tocS_ApplicationConfigUnsetArgs">ApplicationConfigUnsetArgs</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationconfigunsetargs"></a>
<a id="schema_ApplicationConfigUnsetArgs"></a>
<a id="tocSapplicationconfigunsetargs"></a>
<a id="tocsapplicationconfigunsetargs"></a>

```json
{
  "Args": [
    {
      "application": "string",
      "branch": "string",
      "options": [
        "string"
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|Args|[[ApplicationUnset](#schemaapplicationunset)]|true|none|none|

<h2 id="tocS_ApplicationConstraint">ApplicationConstraint</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationconstraint"></a>
<a id="schema_ApplicationConstraint"></a>
<a id="tocSapplicationconstraint"></a>
<a id="tocsapplicationconstraint"></a>

```json
{
  "constraints": {
    "allocate-public-ip": true,
    "arch": "string",
    "container": "string",
    "cores": 0,
    "cpu-power": 0,
    "image-id": "string",
    "instance-role": "string",
    "instance-type": "string",
    "mem": 0,
    "root-disk": 0,
    "root-disk-source": "string",
    "spaces": [
      "string"
    ],
    "tags": [
      "string"
    ],
    "virt-type": "string",
    "zones": [
      "string"
    ]
  },
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|constraints|[Value](#schemavalue)|true|none|none|
|error|[Error](#schemaerror)|false|none|none|

<h2 id="tocS_ApplicationDeploy">ApplicationDeploy</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationdeploy"></a>
<a id="schema_ApplicationDeploy"></a>
<a id="tocSapplicationdeploy"></a>
<a id="tocsapplicationdeploy"></a>

```json
{
  "Force": true,
  "application": "string",
  "attach-storage": [
    "string"
  ],
  "channel": "string",
  "charm-origin": {
    "architecture": "string",
    "base": {
      "channel": "string",
      "name": "string"
    },
    "branch": "string",
    "hash": "string",
    "id": "string",
    "instance-key": "string",
    "revision": 0,
    "risk": "string",
    "source": "string",
    "track": "string",
    "type": "string"
  },
  "charm-url": "string",
  "config": {},
  "config-yaml": "string",
  "constraints": {
    "allocate-public-ip": true,
    "arch": "string",
    "container": "string",
    "cores": 0,
    "cpu-power": 0,
    "image-id": "string",
    "instance-role": "string",
    "instance-type": "string",
    "mem": 0,
    "root-disk": 0,
    "root-disk-source": "string",
    "spaces": [
      "string"
    ],
    "tags": [
      "string"
    ],
    "virt-type": "string",
    "zones": [
      "string"
    ]
  },
  "devices": {},
  "endpoint-bindings": {},
  "num-units": 0,
  "placement": [
    {
      "directive": "string",
      "scope": "string"
    }
  ],
  "policy": "string",
  "resources": {},
  "storage": {}
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|Force|boolean|true|none|none|
|application|string|true|none|none|
|attach-storage|[string]|false|none|none|
|channel|string|true|none|none|
|charm-origin|[CharmOrigin](#schemacharmorigin)|false|none|none|
|charm-url|string|true|none|none|
|config|object|false|none|none|
|» .*|string|false|none|none|
|config-yaml|string|true|none|none|
|constraints|[Value](#schemavalue)|true|none|none|
|devices|object|false|none|none|
|» .*|[Constraints](#schemaconstraints)|false|none|none|
|endpoint-bindings|object|false|none|none|
|» .*|string|false|none|none|
|num-units|integer|true|none|none|
|placement|[[Placement](#schemaplacement)]|false|none|none|
|policy|string|false|none|none|
|resources|object|false|none|none|
|» .*|string|false|none|none|
|storage|object|false|none|none|
|» .*|[Constraints](#schemaconstraints)|false|none|none|

<h2 id="tocS_ApplicationExpose">ApplicationExpose</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationexpose"></a>
<a id="schema_ApplicationExpose"></a>
<a id="tocSapplicationexpose"></a>
<a id="tocsapplicationexpose"></a>

```json
{
  "application": "string",
  "exposed-endpoints": {}
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|application|string|true|none|none|
|exposed-endpoints|object|false|none|none|
|» .*|[ExposedEndpoint](#schemaexposedendpoint)|false|none|none|

<h2 id="tocS_ApplicationGet">ApplicationGet</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationget"></a>
<a id="schema_ApplicationGet"></a>
<a id="tocSapplicationget"></a>
<a id="tocsapplicationget"></a>

```json
{
  "application": "string",
  "branch": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|application|string|true|none|none|
|branch|string|true|none|none|

<h2 id="tocS_ApplicationGetArgs">ApplicationGetArgs</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationgetargs"></a>
<a id="schema_ApplicationGetArgs"></a>
<a id="tocSapplicationgetargs"></a>
<a id="tocsapplicationgetargs"></a>

```json
{
  "args": [
    {
      "application": "string",
      "branch": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|args|[[ApplicationGet](#schemaapplicationget)]|true|none|none|

<h2 id="tocS_ApplicationGetConfigResults">ApplicationGetConfigResults</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationgetconfigresults"></a>
<a id="schema_ApplicationGetConfigResults"></a>
<a id="tocSapplicationgetconfigresults"></a>
<a id="tocsapplicationgetconfigresults"></a>

```json
{
  "Results": [
    {
      "config": {},
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|Results|[[ConfigResult](#schemaconfigresult)]|true|none|none|

<h2 id="tocS_ApplicationGetConstraintsResults">ApplicationGetConstraintsResults</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationgetconstraintsresults"></a>
<a id="schema_ApplicationGetConstraintsResults"></a>
<a id="tocSapplicationgetconstraintsresults"></a>
<a id="tocsapplicationgetconstraintsresults"></a>

```json
{
  "results": [
    {
      "constraints": {
        "allocate-public-ip": true,
        "arch": "string",
        "container": "string",
        "cores": 0,
        "cpu-power": 0,
        "image-id": "string",
        "instance-role": "string",
        "instance-type": "string",
        "mem": 0,
        "root-disk": 0,
        "root-disk-source": "string",
        "spaces": [
          "string"
        ],
        "tags": [
          "string"
        ],
        "virt-type": "string",
        "zones": [
          "string"
        ]
      },
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[ApplicationConstraint](#schemaapplicationconstraint)]|true|none|none|

<h2 id="tocS_ApplicationGetResults">ApplicationGetResults</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationgetresults"></a>
<a id="schema_ApplicationGetResults"></a>
<a id="tocSapplicationgetresults"></a>
<a id="tocsapplicationgetresults"></a>

```json
{
  "application": "string",
  "application-config": {},
  "base": {
    "channel": "string",
    "name": "string"
  },
  "channel": "string",
  "charm": "string",
  "config": {},
  "constraints": {
    "allocate-public-ip": true,
    "arch": "string",
    "container": "string",
    "cores": 0,
    "cpu-power": 0,
    "image-id": "string",
    "instance-role": "string",
    "instance-type": "string",
    "mem": 0,
    "root-disk": 0,
    "root-disk-source": "string",
    "spaces": [
      "string"
    ],
    "tags": [
      "string"
    ],
    "virt-type": "string",
    "zones": [
      "string"
    ]
  },
  "endpoint-bindings": {}
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|application|string|true|none|none|
|application-config|object|false|none|none|
|» .*|object|false|none|none|
|base|[Base](#schemabase)|true|none|none|
|channel|string|true|none|none|
|charm|string|true|none|none|
|config|object|true|none|none|
|» .*|object|false|none|none|
|constraints|[Value](#schemavalue)|true|none|none|
|endpoint-bindings|object|false|none|none|
|» .*|string|false|none|none|

<h2 id="tocS_ApplicationInfoResult">ApplicationInfoResult</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationinforesult"></a>
<a id="schema_ApplicationInfoResult"></a>
<a id="tocSapplicationinforesult"></a>
<a id="tocsapplicationinforesult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": {
    "base": {
      "channel": "string",
      "name": "string"
    },
    "channel": "string",
    "charm": "string",
    "constraints": {
      "allocate-public-ip": true,
      "arch": "string",
      "container": "string",
      "cores": 0,
      "cpu-power": 0,
      "image-id": "string",
      "instance-role": "string",
      "instance-type": "string",
      "mem": 0,
      "root-disk": 0,
      "root-disk-source": "string",
      "spaces": [
        "string"
      ],
      "tags": [
        "string"
      ],
      "virt-type": "string",
      "zones": [
        "string"
      ]
    },
    "endpoint-bindings": {},
    "exposed": true,
    "exposed-endpoints": {},
    "life": "string",
    "principal": true,
    "remote": true,
    "tag": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|result|[ApplicationResult](#schemaapplicationresult)|false|none|none|

<h2 id="tocS_ApplicationInfoResults">ApplicationInfoResults</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationinforesults"></a>
<a id="schema_ApplicationInfoResults"></a>
<a id="tocSapplicationinforesults"></a>
<a id="tocsapplicationinforesults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "base": {
          "channel": "string",
          "name": "string"
        },
        "channel": "string",
        "charm": "string",
        "constraints": {
          "allocate-public-ip": true,
          "arch": "string",
          "container": "string",
          "cores": 0,
          "cpu-power": 0,
          "image-id": "string",
          "instance-role": "string",
          "instance-type": "string",
          "mem": 0,
          "root-disk": 0,
          "root-disk-source": "string",
          "spaces": [
            "string"
          ],
          "tags": [
            "string"
          ],
          "virt-type": "string",
          "zones": [
            "string"
          ]
        },
        "endpoint-bindings": {},
        "exposed": true,
        "exposed-endpoints": {},
        "life": "string",
        "principal": true,
        "remote": true,
        "tag": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[ApplicationInfoResult](#schemaapplicationinforesult)]|true|none|none|

<h2 id="tocS_ApplicationMergeBindings">ApplicationMergeBindings</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationmergebindings"></a>
<a id="schema_ApplicationMergeBindings"></a>
<a id="tocSapplicationmergebindings"></a>
<a id="tocsapplicationmergebindings"></a>

```json
{
  "application-tag": "string",
  "bindings": {},
  "force": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|application-tag|string|true|none|none|
|bindings|object|true|none|none|
|» .*|string|false|none|none|
|force|boolean|true|none|none|

<h2 id="tocS_ApplicationMergeBindingsArgs">ApplicationMergeBindingsArgs</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationmergebindingsargs"></a>
<a id="schema_ApplicationMergeBindingsArgs"></a>
<a id="tocSapplicationmergebindingsargs"></a>
<a id="tocsapplicationmergebindingsargs"></a>

```json
{
  "args": [
    {
      "application-tag": "string",
      "bindings": {},
      "force": true
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|args|[[ApplicationMergeBindings](#schemaapplicationmergebindings)]|true|none|none|

<h2 id="tocS_ApplicationMetricCredential">ApplicationMetricCredential</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationmetriccredential"></a>
<a id="schema_ApplicationMetricCredential"></a>
<a id="tocSapplicationmetriccredential"></a>
<a id="tocsapplicationmetriccredential"></a>

```json
{
  "application": "string",
  "metrics-credentials": [
    0
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|application|string|true|none|none|
|metrics-credentials|[integer]|true|none|none|

<h2 id="tocS_ApplicationMetricCredentials">ApplicationMetricCredentials</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationmetriccredentials"></a>
<a id="schema_ApplicationMetricCredentials"></a>
<a id="tocSapplicationmetriccredentials"></a>
<a id="tocsapplicationmetriccredentials"></a>

```json
{
  "creds": [
    {
      "application": "string",
      "metrics-credentials": [
        0
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|creds|[[ApplicationMetricCredential](#schemaapplicationmetriccredential)]|true|none|none|

<h2 id="tocS_ApplicationOfferDetails">ApplicationOfferDetails</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationofferdetails"></a>
<a id="schema_ApplicationOfferDetails"></a>
<a id="tocSapplicationofferdetails"></a>
<a id="tocsapplicationofferdetails"></a>

```json
{
  "application-description": "string",
  "bindings": {},
  "endpoints": [
    {
      "interface": "string",
      "limit": 0,
      "name": "string",
      "role": "string"
    }
  ],
  "offer-name": "string",
  "offer-url": "string",
  "offer-uuid": "string",
  "source-model-tag": "string",
  "spaces": [
    {
      "cloud-type": "string",
      "name": "string",
      "provider-attributes": {},
      "provider-id": "string",
      "subnets": [
        {
          "cidr": "string",
          "life": "string",
          "provider-id": "string",
          "provider-network-id": "string",
          "provider-space-id": "string",
          "space-tag": "string",
          "status": "string",
          "vlan-tag": 0,
          "zones": [
            "string"
          ]
        }
      ]
    }
  ],
  "users": [
    {
      "access": "string",
      "display-name": "string",
      "user": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|application-description|string|true|none|none|
|bindings|object|false|none|none|
|» .*|string|false|none|none|
|endpoints|[[RemoteEndpoint](#schemaremoteendpoint)]|false|none|none|
|offer-name|string|true|none|none|
|offer-url|string|true|none|none|
|offer-uuid|string|true|none|none|
|source-model-tag|string|true|none|none|
|spaces|[[RemoteSpace](#schemaremotespace)]|false|none|none|
|users|[[OfferUserDetails](#schemaofferuserdetails)]|false|none|none|

<h2 id="tocS_ApplicationResult">ApplicationResult</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationresult"></a>
<a id="schema_ApplicationResult"></a>
<a id="tocSapplicationresult"></a>
<a id="tocsapplicationresult"></a>

```json
{
  "base": {
    "channel": "string",
    "name": "string"
  },
  "channel": "string",
  "charm": "string",
  "constraints": {
    "allocate-public-ip": true,
    "arch": "string",
    "container": "string",
    "cores": 0,
    "cpu-power": 0,
    "image-id": "string",
    "instance-role": "string",
    "instance-type": "string",
    "mem": 0,
    "root-disk": 0,
    "root-disk-source": "string",
    "spaces": [
      "string"
    ],
    "tags": [
      "string"
    ],
    "virt-type": "string",
    "zones": [
      "string"
    ]
  },
  "endpoint-bindings": {},
  "exposed": true,
  "exposed-endpoints": {},
  "life": "string",
  "principal": true,
  "remote": true,
  "tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|base|[Base](#schemabase)|false|none|none|
|channel|string|false|none|none|
|charm|string|false|none|none|
|constraints|[Value](#schemavalue)|false|none|none|
|endpoint-bindings|object|false|none|none|
|» .*|string|false|none|none|
|exposed|boolean|true|none|none|
|exposed-endpoints|object|false|none|none|
|» .*|[ExposedEndpoint](#schemaexposedendpoint)|false|none|none|
|life|string|true|none|none|
|principal|boolean|true|none|none|
|remote|boolean|true|none|none|
|tag|string|true|none|none|

<h2 id="tocS_ApplicationSetCharm">ApplicationSetCharm</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationsetcharm"></a>
<a id="schema_ApplicationSetCharm"></a>
<a id="tocSapplicationsetcharm"></a>
<a id="tocsapplicationsetcharm"></a>

```json
{
  "application": "string",
  "channel": "string",
  "charm-origin": {
    "architecture": "string",
    "base": {
      "channel": "string",
      "name": "string"
    },
    "branch": "string",
    "hash": "string",
    "id": "string",
    "instance-key": "string",
    "revision": 0,
    "risk": "string",
    "source": "string",
    "track": "string",
    "type": "string"
  },
  "charm-url": "string",
  "config-settings": {},
  "config-settings-yaml": "string",
  "endpoint-bindings": {},
  "force": true,
  "force-base": true,
  "force-units": true,
  "generation": "string",
  "resource-ids": {},
  "storage-constraints": {}
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|application|string|true|none|none|
|channel|string|true|none|none|
|charm-origin|[CharmOrigin](#schemacharmorigin)|false|none|none|
|charm-url|string|true|none|none|
|config-settings|object|false|none|none|
|» .*|string|false|none|none|
|config-settings-yaml|string|false|none|none|
|endpoint-bindings|object|false|none|none|
|» .*|string|false|none|none|
|force|boolean|true|none|none|
|force-base|boolean|true|none|none|
|force-units|boolean|true|none|none|
|generation|string|true|none|none|
|resource-ids|object|false|none|none|
|» .*|string|false|none|none|
|storage-constraints|object|false|none|none|
|» .*|[StorageConstraints](#schemastorageconstraints)|false|none|none|

<h2 id="tocS_ApplicationUnexpose">ApplicationUnexpose</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationunexpose"></a>
<a id="schema_ApplicationUnexpose"></a>
<a id="tocSapplicationunexpose"></a>
<a id="tocsapplicationunexpose"></a>

```json
{
  "application": "string",
  "exposed-endpoints": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|application|string|true|none|none|
|exposed-endpoints|[string]|true|none|none|

<h2 id="tocS_ApplicationUnset">ApplicationUnset</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationunset"></a>
<a id="schema_ApplicationUnset"></a>
<a id="tocSapplicationunset"></a>
<a id="tocsapplicationunset"></a>

```json
{
  "application": "string",
  "branch": "string",
  "options": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|application|string|true|none|none|
|branch|string|true|none|none|
|options|[string]|true|none|none|

<h2 id="tocS_ApplicationsDeploy">ApplicationsDeploy</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationsdeploy"></a>
<a id="schema_ApplicationsDeploy"></a>
<a id="tocSapplicationsdeploy"></a>
<a id="tocsapplicationsdeploy"></a>

```json
{
  "applications": [
    {
      "Force": true,
      "application": "string",
      "attach-storage": [
        "string"
      ],
      "channel": "string",
      "charm-origin": {
        "architecture": "string",
        "base": {
          "channel": "string",
          "name": "string"
        },
        "branch": "string",
        "hash": "string",
        "id": "string",
        "instance-key": "string",
        "revision": 0,
        "risk": "string",
        "source": "string",
        "track": "string",
        "type": "string"
      },
      "charm-url": "string",
      "config": {},
      "config-yaml": "string",
      "constraints": {
        "allocate-public-ip": true,
        "arch": "string",
        "container": "string",
        "cores": 0,
        "cpu-power": 0,
        "image-id": "string",
        "instance-role": "string",
        "instance-type": "string",
        "mem": 0,
        "root-disk": 0,
        "root-disk-source": "string",
        "spaces": [
          "string"
        ],
        "tags": [
          "string"
        ],
        "virt-type": "string",
        "zones": [
          "string"
        ]
      },
      "devices": {},
      "endpoint-bindings": {},
      "num-units": 0,
      "placement": [
        {
          "directive": "string",
          "scope": "string"
        }
      ],
      "policy": "string",
      "resources": {},
      "storage": {}
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|applications|[[ApplicationDeploy](#schemaapplicationdeploy)]|true|none|none|

<h2 id="tocS_Base">Base</h2>
<!-- backwards compatibility -->
<a id="schemabase"></a>
<a id="schema_Base"></a>
<a id="tocSbase"></a>
<a id="tocsbase"></a>

```json
{
  "channel": "string",
  "name": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|channel|string|true|none|none|
|name|string|true|none|none|

<h2 id="tocS_CharmOrigin">CharmOrigin</h2>
<!-- backwards compatibility -->
<a id="schemacharmorigin"></a>
<a id="schema_CharmOrigin"></a>
<a id="tocScharmorigin"></a>
<a id="tocscharmorigin"></a>

```json
{
  "architecture": "string",
  "base": {
    "channel": "string",
    "name": "string"
  },
  "branch": "string",
  "hash": "string",
  "id": "string",
  "instance-key": "string",
  "revision": 0,
  "risk": "string",
  "source": "string",
  "track": "string",
  "type": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|architecture|string|false|none|none|
|base|[Base](#schemabase)|false|none|none|
|branch|string|false|none|none|
|hash|string|false|none|none|
|id|string|true|none|none|
|instance-key|string|false|none|none|
|revision|integer|false|none|none|
|risk|string|false|none|none|
|source|string|true|none|none|
|track|string|false|none|none|
|type|string|true|none|none|

<h2 id="tocS_CharmRelation">CharmRelation</h2>
<!-- backwards compatibility -->
<a id="schemacharmrelation"></a>
<a id="schema_CharmRelation"></a>
<a id="tocScharmrelation"></a>
<a id="tocscharmrelation"></a>

```json
{
  "interface": "string",
  "limit": 0,
  "name": "string",
  "optional": true,
  "role": "string",
  "scope": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|interface|string|true|none|none|
|limit|integer|true|none|none|
|name|string|true|none|none|
|optional|boolean|true|none|none|
|role|string|true|none|none|
|scope|string|true|none|none|

<h2 id="tocS_CharmURLOriginResult">CharmURLOriginResult</h2>
<!-- backwards compatibility -->
<a id="schemacharmurloriginresult"></a>
<a id="schema_CharmURLOriginResult"></a>
<a id="tocScharmurloriginresult"></a>
<a id="tocscharmurloriginresult"></a>

```json
{
  "charm-origin": {
    "architecture": "string",
    "base": {
      "channel": "string",
      "name": "string"
    },
    "branch": "string",
    "hash": "string",
    "id": "string",
    "instance-key": "string",
    "revision": 0,
    "risk": "string",
    "source": "string",
    "track": "string",
    "type": "string"
  },
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "url": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|charm-origin|[CharmOrigin](#schemacharmorigin)|true|none|none|
|error|[Error](#schemaerror)|false|none|none|
|url|string|true|none|none|

<h2 id="tocS_ConfigResult">ConfigResult</h2>
<!-- backwards compatibility -->
<a id="schemaconfigresult"></a>
<a id="schema_ConfigResult"></a>
<a id="tocSconfigresult"></a>
<a id="tocsconfigresult"></a>

```json
{
  "config": {},
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|config|object|true|none|none|
|» .*|object|false|none|none|
|error|[Error](#schemaerror)|false|none|none|

<h2 id="tocS_ConfigSet">ConfigSet</h2>
<!-- backwards compatibility -->
<a id="schemaconfigset"></a>
<a id="schema_ConfigSet"></a>
<a id="tocSconfigset"></a>
<a id="tocsconfigset"></a>

```json
{
  "application": "string",
  "config": {},
  "config-yaml": "string",
  "generation": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|application|string|true|none|none|
|config|object|true|none|none|
|» .*|string|false|none|none|
|config-yaml|string|true|none|none|
|generation|string|true|none|none|

<h2 id="tocS_ConfigSetArgs">ConfigSetArgs</h2>
<!-- backwards compatibility -->
<a id="schemaconfigsetargs"></a>
<a id="schema_ConfigSetArgs"></a>
<a id="tocSconfigsetargs"></a>
<a id="tocsconfigsetargs"></a>

```json
{
  "Args": [
    {
      "application": "string",
      "config": {},
      "config-yaml": "string",
      "generation": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|Args|[[ConfigSet](#schemaconfigset)]|true|none|none|

<h2 id="tocS_Constraints">Constraints</h2>
<!-- backwards compatibility -->
<a id="schemaconstraints"></a>
<a id="schema_Constraints"></a>
<a id="tocSconstraints"></a>
<a id="tocsconstraints"></a>

```json
{
  "Count": 0,
  "Pool": "string",
  "Size": 0
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|Count|integer|true|none|none|
|Pool|string|true|none|none|
|Size|integer|true|none|none|

<h2 id="tocS_ConsumeApplicationArg">ConsumeApplicationArg</h2>
<!-- backwards compatibility -->
<a id="schemaconsumeapplicationarg"></a>
<a id="schema_ConsumeApplicationArg"></a>
<a id="tocSconsumeapplicationarg"></a>
<a id="tocsconsumeapplicationarg"></a>

```json
{
  "ApplicationOfferDetails": {
    "application-description": "string",
    "bindings": {},
    "endpoints": [
      {
        "interface": "string",
        "limit": 0,
        "name": "string",
        "role": "string"
      }
    ],
    "offer-name": "string",
    "offer-url": "string",
    "offer-uuid": "string",
    "source-model-tag": "string",
    "spaces": [
      {
        "cloud-type": "string",
        "name": "string",
        "provider-attributes": {},
        "provider-id": "string",
        "subnets": [
          {
            "cidr": "string",
            "life": "string",
            "provider-id": "string",
            "provider-network-id": "string",
            "provider-space-id": "string",
            "space-tag": "string",
            "status": "string",
            "vlan-tag": 0,
            "zones": [
              "string"
            ]
          }
        ]
      }
    ],
    "users": [
      {
        "access": "string",
        "display-name": "string",
        "user": "string"
      }
    ]
  },
  "application-alias": "string",
  "application-description": "string",
  "bindings": {},
  "endpoints": [
    {
      "interface": "string",
      "limit": 0,
      "name": "string",
      "role": "string"
    }
  ],
  "external-controller": {
    "addrs": [
      "string"
    ],
    "ca-cert": "string",
    "controller-alias": "string",
    "controller-tag": "string"
  },
  "macaroon": {},
  "offer-name": "string",
  "offer-url": "string",
  "offer-uuid": "string",
  "source-model-tag": "string",
  "spaces": [
    {
      "cloud-type": "string",
      "name": "string",
      "provider-attributes": {},
      "provider-id": "string",
      "subnets": [
        {
          "cidr": "string",
          "life": "string",
          "provider-id": "string",
          "provider-network-id": "string",
          "provider-space-id": "string",
          "space-tag": "string",
          "status": "string",
          "vlan-tag": 0,
          "zones": [
            "string"
          ]
        }
      ]
    }
  ],
  "users": [
    {
      "access": "string",
      "display-name": "string",
      "user": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|ApplicationOfferDetails|[ApplicationOfferDetails](#schemaapplicationofferdetails)|true|none|none|
|application-alias|string|false|none|none|
|application-description|string|true|none|none|
|bindings|object|false|none|none|
|» .*|string|false|none|none|
|endpoints|[[RemoteEndpoint](#schemaremoteendpoint)]|false|none|none|
|external-controller|[ExternalControllerInfo](#schemaexternalcontrollerinfo)|false|none|none|
|macaroon|[Macaroon](#schemamacaroon)|false|none|none|
|offer-name|string|true|none|none|
|offer-url|string|true|none|none|
|offer-uuid|string|true|none|none|
|source-model-tag|string|true|none|none|
|spaces|[[RemoteSpace](#schemaremotespace)]|false|none|none|
|users|[[OfferUserDetails](#schemaofferuserdetails)]|false|none|none|

<h2 id="tocS_ConsumeApplicationArgs">ConsumeApplicationArgs</h2>
<!-- backwards compatibility -->
<a id="schemaconsumeapplicationargs"></a>
<a id="schema_ConsumeApplicationArgs"></a>
<a id="tocSconsumeapplicationargs"></a>
<a id="tocsconsumeapplicationargs"></a>

```json
{
  "args": [
    {
      "ApplicationOfferDetails": {
        "application-description": "string",
        "bindings": {},
        "endpoints": [
          {
            "interface": "string",
            "limit": 0,
            "name": "string",
            "role": "string"
          }
        ],
        "offer-name": "string",
        "offer-url": "string",
        "offer-uuid": "string",
        "source-model-tag": "string",
        "spaces": [
          {
            "cloud-type": "string",
            "name": "string",
            "provider-attributes": {},
            "provider-id": "string",
            "subnets": [
              {
                "cidr": "string",
                "life": "string",
                "provider-id": "string",
                "provider-network-id": "string",
                "provider-space-id": "string",
                "space-tag": "string",
                "status": "string",
                "vlan-tag": 0,
                "zones": [
                  "string"
                ]
              }
            ]
          }
        ],
        "users": [
          {
            "access": "string",
            "display-name": "string",
            "user": "string"
          }
        ]
      },
      "application-alias": "string",
      "application-description": "string",
      "bindings": {},
      "endpoints": [
        {
          "interface": "string",
          "limit": 0,
          "name": "string",
          "role": "string"
        }
      ],
      "external-controller": {
        "addrs": [
          "string"
        ],
        "ca-cert": "string",
        "controller-alias": "string",
        "controller-tag": "string"
      },
      "macaroon": {},
      "offer-name": "string",
      "offer-url": "string",
      "offer-uuid": "string",
      "source-model-tag": "string",
      "spaces": [
        {
          "cloud-type": "string",
          "name": "string",
          "provider-attributes": {},
          "provider-id": "string",
          "subnets": [
            {
              "cidr": "string",
              "life": "string",
              "provider-id": "string",
              "provider-network-id": "string",
              "provider-space-id": "string",
              "space-tag": "string",
              "status": "string",
              "vlan-tag": 0,
              "zones": [
                "string"
              ]
            }
          ]
        }
      ],
      "users": [
        {
          "access": "string",
          "display-name": "string",
          "user": "string"
        }
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|args|[[ConsumeApplicationArg](#schemaconsumeapplicationarg)]|false|none|none|

<h2 id="tocS_DeployFromRepositoryArg">DeployFromRepositoryArg</h2>
<!-- backwards compatibility -->
<a id="schemadeployfromrepositoryarg"></a>
<a id="schema_DeployFromRepositoryArg"></a>
<a id="tocSdeployfromrepositoryarg"></a>
<a id="tocsdeployfromrepositoryarg"></a>

```json
{
  "ApplicationName": "string",
  "AttachStorage": [
    "string"
  ],
  "CharmName": "string",
  "ConfigYAML": "string",
  "Cons": {
    "allocate-public-ip": true,
    "arch": "string",
    "container": "string",
    "cores": 0,
    "cpu-power": 0,
    "image-id": "string",
    "instance-role": "string",
    "instance-type": "string",
    "mem": 0,
    "root-disk": 0,
    "root-disk-source": "string",
    "spaces": [
      "string"
    ],
    "tags": [
      "string"
    ],
    "virt-type": "string",
    "zones": [
      "string"
    ]
  },
  "Devices": {},
  "DryRun": true,
  "Placement": [
    {
      "directive": "string",
      "scope": "string"
    }
  ],
  "Storage": {},
  "Trust": true,
  "base": {
    "channel": "string",
    "name": "string"
  },
  "channel": "string",
  "endpoint-bindings": {},
  "force": true,
  "num-units": 0,
  "resources": {},
  "revision": 0
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|ApplicationName|string|true|none|none|
|AttachStorage|[string]|true|none|none|
|CharmName|string|true|none|none|
|ConfigYAML|string|true|none|none|
|Cons|[Value](#schemavalue)|true|none|none|
|Devices|object|true|none|none|
|» .*|[Constraints](#schemaconstraints)|false|none|none|
|DryRun|boolean|true|none|none|
|Placement|[[Placement](#schemaplacement)]|true|none|none|
|Storage|object|true|none|none|
|» .*|[Constraints](#schemaconstraints)|false|none|none|
|Trust|boolean|true|none|none|
|base|[Base](#schemabase)|false|none|none|
|channel|string|false|none|none|
|endpoint-bindings|object|false|none|none|
|» .*|string|false|none|none|
|force|boolean|false|none|none|
|num-units|integer|false|none|none|
|resources|object|false|none|none|
|» .*|string|false|none|none|
|revision|integer|false|none|none|

<h2 id="tocS_DeployFromRepositoryArgs">DeployFromRepositoryArgs</h2>
<!-- backwards compatibility -->
<a id="schemadeployfromrepositoryargs"></a>
<a id="schema_DeployFromRepositoryArgs"></a>
<a id="tocSdeployfromrepositoryargs"></a>
<a id="tocsdeployfromrepositoryargs"></a>

```json
{
  "Args": [
    {
      "ApplicationName": "string",
      "AttachStorage": [
        "string"
      ],
      "CharmName": "string",
      "ConfigYAML": "string",
      "Cons": {
        "allocate-public-ip": true,
        "arch": "string",
        "container": "string",
        "cores": 0,
        "cpu-power": 0,
        "image-id": "string",
        "instance-role": "string",
        "instance-type": "string",
        "mem": 0,
        "root-disk": 0,
        "root-disk-source": "string",
        "spaces": [
          "string"
        ],
        "tags": [
          "string"
        ],
        "virt-type": "string",
        "zones": [
          "string"
        ]
      },
      "Devices": {},
      "DryRun": true,
      "Placement": [
        {
          "directive": "string",
          "scope": "string"
        }
      ],
      "Storage": {},
      "Trust": true,
      "base": {
        "channel": "string",
        "name": "string"
      },
      "channel": "string",
      "endpoint-bindings": {},
      "force": true,
      "num-units": 0,
      "resources": {},
      "revision": 0
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|Args|[[DeployFromRepositoryArg](#schemadeployfromrepositoryarg)]|true|none|none|

<h2 id="tocS_DeployFromRepositoryInfo">DeployFromRepositoryInfo</h2>
<!-- backwards compatibility -->
<a id="schemadeployfromrepositoryinfo"></a>
<a id="schema_DeployFromRepositoryInfo"></a>
<a id="tocSdeployfromrepositoryinfo"></a>
<a id="tocsdeployfromrepositoryinfo"></a>

```json
{
  "architecture": "string",
  "base": {
    "channel": "string",
    "name": "string"
  },
  "channel": "string",
  "charm-url": "string",
  "effective-channel": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|architecture|string|true|none|none|
|base|[Base](#schemabase)|false|none|none|
|channel|string|false|none|none|
|charm-url|string|true|none|none|
|effective-channel|string|false|none|none|

<h2 id="tocS_DeployFromRepositoryResult">DeployFromRepositoryResult</h2>
<!-- backwards compatibility -->
<a id="schemadeployfromrepositoryresult"></a>
<a id="schema_DeployFromRepositoryResult"></a>
<a id="tocSdeployfromrepositoryresult"></a>
<a id="tocsdeployfromrepositoryresult"></a>

```json
{
  "Errors": [
    {
      "code": "string",
      "info": {},
      "message": "string"
    }
  ],
  "Info": {
    "architecture": "string",
    "base": {
      "channel": "string",
      "name": "string"
    },
    "channel": "string",
    "charm-url": "string",
    "effective-channel": "string"
  },
  "PendingResourceUploads": [
    {
      "Filename": "string",
      "Name": "string",
      "Type": "string",
      "pending-id": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|Errors|[[Error](#schemaerror)]|true|none|none|
|Info|[DeployFromRepositoryInfo](#schemadeployfromrepositoryinfo)|true|none|none|
|PendingResourceUploads|[[PendingResourceUpload](#schemapendingresourceupload)]|true|none|none|

<h2 id="tocS_DeployFromRepositoryResults">DeployFromRepositoryResults</h2>
<!-- backwards compatibility -->
<a id="schemadeployfromrepositoryresults"></a>
<a id="schema_DeployFromRepositoryResults"></a>
<a id="tocSdeployfromrepositoryresults"></a>
<a id="tocsdeployfromrepositoryresults"></a>

```json
{
  "Results": [
    {
      "Errors": [
        {
          "code": "string",
          "info": {},
          "message": "string"
        }
      ],
      "Info": {
        "architecture": "string",
        "base": {
          "channel": "string",
          "name": "string"
        },
        "channel": "string",
        "charm-url": "string",
        "effective-channel": "string"
      },
      "PendingResourceUploads": [
        {
          "Filename": "string",
          "Name": "string",
          "Type": "string",
          "pending-id": "string"
        }
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|Results|[[DeployFromRepositoryResult](#schemadeployfromrepositoryresult)]|true|none|none|

<h2 id="tocS_DestroyApplicationInfo">DestroyApplicationInfo</h2>
<!-- backwards compatibility -->
<a id="schemadestroyapplicationinfo"></a>
<a id="schema_DestroyApplicationInfo"></a>
<a id="tocSdestroyapplicationinfo"></a>
<a id="tocsdestroyapplicationinfo"></a>

```json
{
  "destroyed-storage": [
    {
      "tag": "string"
    }
  ],
  "destroyed-units": [
    {
      "tag": "string"
    }
  ],
  "detached-storage": [
    {
      "tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|destroyed-storage|[[Entity](#schemaentity)]|false|none|none|
|destroyed-units|[[Entity](#schemaentity)]|false|none|none|
|detached-storage|[[Entity](#schemaentity)]|false|none|none|

<h2 id="tocS_DestroyApplicationParams">DestroyApplicationParams</h2>
<!-- backwards compatibility -->
<a id="schemadestroyapplicationparams"></a>
<a id="schema_DestroyApplicationParams"></a>
<a id="tocSdestroyapplicationparams"></a>
<a id="tocsdestroyapplicationparams"></a>

```json
{
  "application-tag": "string",
  "destroy-storage": true,
  "dry-run": true,
  "force": true,
  "max-wait": 0
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|application-tag|string|true|none|none|
|destroy-storage|boolean|false|none|none|
|dry-run|boolean|false|none|none|
|force|boolean|true|none|none|
|max-wait|integer|false|none|none|

<h2 id="tocS_DestroyApplicationResult">DestroyApplicationResult</h2>
<!-- backwards compatibility -->
<a id="schemadestroyapplicationresult"></a>
<a id="schema_DestroyApplicationResult"></a>
<a id="tocSdestroyapplicationresult"></a>
<a id="tocsdestroyapplicationresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "info": {
    "destroyed-storage": [
      {
        "tag": "string"
      }
    ],
    "destroyed-units": [
      {
        "tag": "string"
      }
    ],
    "detached-storage": [
      {
        "tag": "string"
      }
    ]
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|info|[DestroyApplicationInfo](#schemadestroyapplicationinfo)|false|none|none|

<h2 id="tocS_DestroyApplicationResults">DestroyApplicationResults</h2>
<!-- backwards compatibility -->
<a id="schemadestroyapplicationresults"></a>
<a id="schema_DestroyApplicationResults"></a>
<a id="tocSdestroyapplicationresults"></a>
<a id="tocsdestroyapplicationresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "info": {
        "destroyed-storage": [
          {
            "tag": "string"
          }
        ],
        "destroyed-units": [
          {
            "tag": "string"
          }
        ],
        "detached-storage": [
          {
            "tag": "string"
          }
        ]
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[DestroyApplicationResult](#schemadestroyapplicationresult)]|false|none|none|

<h2 id="tocS_DestroyApplicationsParams">DestroyApplicationsParams</h2>
<!-- backwards compatibility -->
<a id="schemadestroyapplicationsparams"></a>
<a id="schema_DestroyApplicationsParams"></a>
<a id="tocSdestroyapplicationsparams"></a>
<a id="tocsdestroyapplicationsparams"></a>

```json
{
  "applications": [
    {
      "application-tag": "string",
      "destroy-storage": true,
      "dry-run": true,
      "force": true,
      "max-wait": 0
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|applications|[[DestroyApplicationParams](#schemadestroyapplicationparams)]|true|none|none|

<h2 id="tocS_DestroyConsumedApplicationParams">DestroyConsumedApplicationParams</h2>
<!-- backwards compatibility -->
<a id="schemadestroyconsumedapplicationparams"></a>
<a id="schema_DestroyConsumedApplicationParams"></a>
<a id="tocSdestroyconsumedapplicationparams"></a>
<a id="tocsdestroyconsumedapplicationparams"></a>

```json
{
  "application-tag": "string",
  "force": true,
  "max-wait": 0
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|application-tag|string|true|none|none|
|force|boolean|false|none|none|
|max-wait|integer|false|none|none|

<h2 id="tocS_DestroyConsumedApplicationsParams">DestroyConsumedApplicationsParams</h2>
<!-- backwards compatibility -->
<a id="schemadestroyconsumedapplicationsparams"></a>
<a id="schema_DestroyConsumedApplicationsParams"></a>
<a id="tocSdestroyconsumedapplicationsparams"></a>
<a id="tocsdestroyconsumedapplicationsparams"></a>

```json
{
  "applications": [
    {
      "application-tag": "string",
      "force": true,
      "max-wait": 0
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|applications|[[DestroyConsumedApplicationParams](#schemadestroyconsumedapplicationparams)]|true|none|none|

<h2 id="tocS_DestroyRelation">DestroyRelation</h2>
<!-- backwards compatibility -->
<a id="schemadestroyrelation"></a>
<a id="schema_DestroyRelation"></a>
<a id="tocSdestroyrelation"></a>
<a id="tocsdestroyrelation"></a>

```json
{
  "endpoints": [
    "string"
  ],
  "force": true,
  "max-wait": 0,
  "relation-id": 0
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|endpoints|[string]|false|none|none|
|force|boolean|false|none|none|
|max-wait|integer|false|none|none|
|relation-id|integer|true|none|none|

<h2 id="tocS_DestroyUnitInfo">DestroyUnitInfo</h2>
<!-- backwards compatibility -->
<a id="schemadestroyunitinfo"></a>
<a id="schema_DestroyUnitInfo"></a>
<a id="tocSdestroyunitinfo"></a>
<a id="tocsdestroyunitinfo"></a>

```json
{
  "destroyed-storage": [
    {
      "tag": "string"
    }
  ],
  "detached-storage": [
    {
      "tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|destroyed-storage|[[Entity](#schemaentity)]|false|none|none|
|detached-storage|[[Entity](#schemaentity)]|false|none|none|

<h2 id="tocS_DestroyUnitParams">DestroyUnitParams</h2>
<!-- backwards compatibility -->
<a id="schemadestroyunitparams"></a>
<a id="schema_DestroyUnitParams"></a>
<a id="tocSdestroyunitparams"></a>
<a id="tocsdestroyunitparams"></a>

```json
{
  "destroy-storage": true,
  "dry-run": true,
  "force": true,
  "max-wait": 0,
  "unit-tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|destroy-storage|boolean|false|none|none|
|dry-run|boolean|false|none|none|
|force|boolean|false|none|none|
|max-wait|integer|false|none|none|
|unit-tag|string|true|none|none|

<h2 id="tocS_DestroyUnitResult">DestroyUnitResult</h2>
<!-- backwards compatibility -->
<a id="schemadestroyunitresult"></a>
<a id="schema_DestroyUnitResult"></a>
<a id="tocSdestroyunitresult"></a>
<a id="tocsdestroyunitresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "info": {
    "destroyed-storage": [
      {
        "tag": "string"
      }
    ],
    "detached-storage": [
      {
        "tag": "string"
      }
    ]
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|info|[DestroyUnitInfo](#schemadestroyunitinfo)|false|none|none|

<h2 id="tocS_DestroyUnitResults">DestroyUnitResults</h2>
<!-- backwards compatibility -->
<a id="schemadestroyunitresults"></a>
<a id="schema_DestroyUnitResults"></a>
<a id="tocSdestroyunitresults"></a>
<a id="tocsdestroyunitresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "info": {
        "destroyed-storage": [
          {
            "tag": "string"
          }
        ],
        "detached-storage": [
          {
            "tag": "string"
          }
        ]
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[DestroyUnitResult](#schemadestroyunitresult)]|false|none|none|

<h2 id="tocS_DestroyUnitsParams">DestroyUnitsParams</h2>
<!-- backwards compatibility -->
<a id="schemadestroyunitsparams"></a>
<a id="schema_DestroyUnitsParams"></a>
<a id="tocSdestroyunitsparams"></a>
<a id="tocsdestroyunitsparams"></a>

```json
{
  "units": [
    {
      "destroy-storage": true,
      "dry-run": true,
      "force": true,
      "max-wait": 0,
      "unit-tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|units|[[DestroyUnitParams](#schemadestroyunitparams)]|true|none|none|

<h2 id="tocS_EndpointRelationData">EndpointRelationData</h2>
<!-- backwards compatibility -->
<a id="schemaendpointrelationdata"></a>
<a id="schema_EndpointRelationData"></a>
<a id="tocSendpointrelationdata"></a>
<a id="tocsendpointrelationdata"></a>

```json
{
  "ApplicationData": {},
  "cross-model": true,
  "endpoint": "string",
  "related-endpoint": "string",
  "relation-id": 0,
  "unit-relation-data": {}
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|ApplicationData|object|true|none|none|
|» .*|object|false|none|none|
|cross-model|boolean|true|none|none|
|endpoint|string|true|none|none|
|related-endpoint|string|true|none|none|
|relation-id|integer|true|none|none|
|unit-relation-data|object|true|none|none|
|» .*|[RelationData](#schemarelationdata)|false|none|none|

<h2 id="tocS_ExposedEndpoint">ExposedEndpoint</h2>
<!-- backwards compatibility -->
<a id="schemaexposedendpoint"></a>
<a id="schema_ExposedEndpoint"></a>
<a id="tocSexposedendpoint"></a>
<a id="tocsexposedendpoint"></a>

```json
{
  "expose-to-cidrs": [
    "string"
  ],
  "expose-to-spaces": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|expose-to-cidrs|[string]|false|none|none|
|expose-to-spaces|[string]|false|none|none|

<h2 id="tocS_ExternalControllerInfo">ExternalControllerInfo</h2>
<!-- backwards compatibility -->
<a id="schemaexternalcontrollerinfo"></a>
<a id="schema_ExternalControllerInfo"></a>
<a id="tocSexternalcontrollerinfo"></a>
<a id="tocsexternalcontrollerinfo"></a>

```json
{
  "addrs": [
    "string"
  ],
  "ca-cert": "string",
  "controller-alias": "string",
  "controller-tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|addrs|[string]|true|none|none|
|ca-cert|string|true|none|none|
|controller-alias|string|true|none|none|
|controller-tag|string|true|none|none|

<h2 id="tocS_OfferUserDetails">OfferUserDetails</h2>
<!-- backwards compatibility -->
<a id="schemaofferuserdetails"></a>
<a id="schema_OfferUserDetails"></a>
<a id="tocSofferuserdetails"></a>
<a id="tocsofferuserdetails"></a>

```json
{
  "access": "string",
  "display-name": "string",
  "user": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|access|string|true|none|none|
|display-name|string|true|none|none|
|user|string|true|none|none|

<h2 id="tocS_PendingResourceUpload">PendingResourceUpload</h2>
<!-- backwards compatibility -->
<a id="schemapendingresourceupload"></a>
<a id="schema_PendingResourceUpload"></a>
<a id="tocSpendingresourceupload"></a>
<a id="tocspendingresourceupload"></a>

```json
{
  "Filename": "string",
  "Name": "string",
  "Type": "string",
  "pending-id": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|Filename|string|true|none|none|
|Name|string|true|none|none|
|Type|string|true|none|none|
|pending-id|string|true|none|none|

<h2 id="tocS_Placement">Placement</h2>
<!-- backwards compatibility -->
<a id="schemaplacement"></a>
<a id="schema_Placement"></a>
<a id="tocSplacement"></a>
<a id="tocsplacement"></a>

```json
{
  "directive": "string",
  "scope": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|directive|string|true|none|none|
|scope|string|true|none|none|

<h2 id="tocS_RelationData">RelationData</h2>
<!-- backwards compatibility -->
<a id="schemarelationdata"></a>
<a id="schema_RelationData"></a>
<a id="tocSrelationdata"></a>
<a id="tocsrelationdata"></a>

```json
{
  "InScope": true,
  "UnitData": {}
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|InScope|boolean|true|none|none|
|UnitData|object|true|none|none|
|» .*|object|false|none|none|

<h2 id="tocS_RelationSuspendedArg">RelationSuspendedArg</h2>
<!-- backwards compatibility -->
<a id="schemarelationsuspendedarg"></a>
<a id="schema_RelationSuspendedArg"></a>
<a id="tocSrelationsuspendedarg"></a>
<a id="tocsrelationsuspendedarg"></a>

```json
{
  "message": "string",
  "relation-id": 0,
  "suspended": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|message|string|true|none|none|
|relation-id|integer|true|none|none|
|suspended|boolean|true|none|none|

<h2 id="tocS_RelationSuspendedArgs">RelationSuspendedArgs</h2>
<!-- backwards compatibility -->
<a id="schemarelationsuspendedargs"></a>
<a id="schema_RelationSuspendedArgs"></a>
<a id="tocSrelationsuspendedargs"></a>
<a id="tocsrelationsuspendedargs"></a>

```json
{
  "args": [
    {
      "message": "string",
      "relation-id": 0,
      "suspended": true
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|args|[[RelationSuspendedArg](#schemarelationsuspendedarg)]|true|none|none|

<h2 id="tocS_RemoteEndpoint">RemoteEndpoint</h2>
<!-- backwards compatibility -->
<a id="schemaremoteendpoint"></a>
<a id="schema_RemoteEndpoint"></a>
<a id="tocSremoteendpoint"></a>
<a id="tocsremoteendpoint"></a>

```json
{
  "interface": "string",
  "limit": 0,
  "name": "string",
  "role": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|interface|string|true|none|none|
|limit|integer|true|none|none|
|name|string|true|none|none|
|role|string|true|none|none|

<h2 id="tocS_RemoteSpace">RemoteSpace</h2>
<!-- backwards compatibility -->
<a id="schemaremotespace"></a>
<a id="schema_RemoteSpace"></a>
<a id="tocSremotespace"></a>
<a id="tocsremotespace"></a>

```json
{
  "cloud-type": "string",
  "name": "string",
  "provider-attributes": {},
  "provider-id": "string",
  "subnets": [
    {
      "cidr": "string",
      "life": "string",
      "provider-id": "string",
      "provider-network-id": "string",
      "provider-space-id": "string",
      "space-tag": "string",
      "status": "string",
      "vlan-tag": 0,
      "zones": [
        "string"
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|cloud-type|string|true|none|none|
|name|string|true|none|none|
|provider-attributes|object|true|none|none|
|» .*|object|false|none|none|
|provider-id|string|true|none|none|
|subnets|[[Subnet](#schemasubnet)]|true|none|none|

<h2 id="tocS_ScaleApplicationInfo">ScaleApplicationInfo</h2>
<!-- backwards compatibility -->
<a id="schemascaleapplicationinfo"></a>
<a id="schema_ScaleApplicationInfo"></a>
<a id="tocSscaleapplicationinfo"></a>
<a id="tocsscaleapplicationinfo"></a>

```json
{
  "num-units": 0
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|num-units|integer|true|none|none|

<h2 id="tocS_ScaleApplicationParams">ScaleApplicationParams</h2>
<!-- backwards compatibility -->
<a id="schemascaleapplicationparams"></a>
<a id="schema_ScaleApplicationParams"></a>
<a id="tocSscaleapplicationparams"></a>
<a id="tocsscaleapplicationparams"></a>

```json
{
  "application-tag": "string",
  "force": true,
  "scale": 0,
  "scale-change": 0
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|application-tag|string|true|none|none|
|force|boolean|true|none|none|
|scale|integer|true|none|none|
|scale-change|integer|false|none|none|

<h2 id="tocS_ScaleApplicationResult">ScaleApplicationResult</h2>
<!-- backwards compatibility -->
<a id="schemascaleapplicationresult"></a>
<a id="schema_ScaleApplicationResult"></a>
<a id="tocSscaleapplicationresult"></a>
<a id="tocsscaleapplicationresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "info": {
    "num-units": 0
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|info|[ScaleApplicationInfo](#schemascaleapplicationinfo)|false|none|none|

<h2 id="tocS_ScaleApplicationResults">ScaleApplicationResults</h2>
<!-- backwards compatibility -->
<a id="schemascaleapplicationresults"></a>
<a id="schema_ScaleApplicationResults"></a>
<a id="tocSscaleapplicationresults"></a>
<a id="tocsscaleapplicationresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "info": {
        "num-units": 0
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[ScaleApplicationResult](#schemascaleapplicationresult)]|false|none|none|

<h2 id="tocS_ScaleApplicationsParams">ScaleApplicationsParams</h2>
<!-- backwards compatibility -->
<a id="schemascaleapplicationsparams"></a>
<a id="schema_ScaleApplicationsParams"></a>
<a id="tocSscaleapplicationsparams"></a>
<a id="tocsscaleapplicationsparams"></a>

```json
{
  "applications": [
    {
      "application-tag": "string",
      "force": true,
      "scale": 0,
      "scale-change": 0
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|applications|[[ScaleApplicationParams](#schemascaleapplicationparams)]|true|none|none|

<h2 id="tocS_SetConstraints">SetConstraints</h2>
<!-- backwards compatibility -->
<a id="schemasetconstraints"></a>
<a id="schema_SetConstraints"></a>
<a id="tocSsetconstraints"></a>
<a id="tocssetconstraints"></a>

```json
{
  "application": "string",
  "constraints": {
    "allocate-public-ip": true,
    "arch": "string",
    "container": "string",
    "cores": 0,
    "cpu-power": 0,
    "image-id": "string",
    "instance-role": "string",
    "instance-type": "string",
    "mem": 0,
    "root-disk": 0,
    "root-disk-source": "string",
    "spaces": [
      "string"
    ],
    "tags": [
      "string"
    ],
    "virt-type": "string",
    "zones": [
      "string"
    ]
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|application|string|true|none|none|
|constraints|[Value](#schemavalue)|true|none|none|

<h2 id="tocS_StorageConstraints">StorageConstraints</h2>
<!-- backwards compatibility -->
<a id="schemastorageconstraints"></a>
<a id="schema_StorageConstraints"></a>
<a id="tocSstorageconstraints"></a>
<a id="tocsstorageconstraints"></a>

```json
{
  "count": 0,
  "pool": "string",
  "size": 0
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|count|integer|false|none|none|
|pool|string|false|none|none|
|size|integer|false|none|none|

<h2 id="tocS_StringResult">StringResult</h2>
<!-- backwards compatibility -->
<a id="schemastringresult"></a>
<a id="schema_StringResult"></a>
<a id="tocSstringresult"></a>
<a id="tocsstringresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|result|string|true|none|none|

<h2 id="tocS_Subnet">Subnet</h2>
<!-- backwards compatibility -->
<a id="schemasubnet"></a>
<a id="schema_Subnet"></a>
<a id="tocSsubnet"></a>
<a id="tocssubnet"></a>

```json
{
  "cidr": "string",
  "life": "string",
  "provider-id": "string",
  "provider-network-id": "string",
  "provider-space-id": "string",
  "space-tag": "string",
  "status": "string",
  "vlan-tag": 0,
  "zones": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|cidr|string|true|none|none|
|life|string|true|none|none|
|provider-id|string|false|none|none|
|provider-network-id|string|false|none|none|
|provider-space-id|string|false|none|none|
|space-tag|string|true|none|none|
|status|string|false|none|none|
|vlan-tag|integer|true|none|none|
|zones|[string]|true|none|none|

<h2 id="tocS_UnitInfoResult">UnitInfoResult</h2>
<!-- backwards compatibility -->
<a id="schemaunitinforesult"></a>
<a id="schema_UnitInfoResult"></a>
<a id="tocSunitinforesult"></a>
<a id="tocsunitinforesult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": {
    "address": "string",
    "charm": "string",
    "leader": true,
    "life": "string",
    "machine": "string",
    "opened-ports": [
      "string"
    ],
    "provider-id": "string",
    "public-address": "string",
    "relation-data": [
      {
        "ApplicationData": {},
        "cross-model": true,
        "endpoint": "string",
        "related-endpoint": "string",
        "relation-id": 0,
        "unit-relation-data": {}
      }
    ],
    "tag": "string",
    "workload-version": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|result|[UnitResult](#schemaunitresult)|false|none|none|

<h2 id="tocS_UnitInfoResults">UnitInfoResults</h2>
<!-- backwards compatibility -->
<a id="schemaunitinforesults"></a>
<a id="schema_UnitInfoResults"></a>
<a id="tocSunitinforesults"></a>
<a id="tocsunitinforesults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "address": "string",
        "charm": "string",
        "leader": true,
        "life": "string",
        "machine": "string",
        "opened-ports": [
          "string"
        ],
        "provider-id": "string",
        "public-address": "string",
        "relation-data": [
          {
            "ApplicationData": {},
            "cross-model": true,
            "endpoint": "string",
            "related-endpoint": "string",
            "relation-id": 0,
            "unit-relation-data": {}
          }
        ],
        "tag": "string",
        "workload-version": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[UnitInfoResult](#schemaunitinforesult)]|true|none|none|

<h2 id="tocS_UnitResult">UnitResult</h2>
<!-- backwards compatibility -->
<a id="schemaunitresult"></a>
<a id="schema_UnitResult"></a>
<a id="tocSunitresult"></a>
<a id="tocsunitresult"></a>

```json
{
  "address": "string",
  "charm": "string",
  "leader": true,
  "life": "string",
  "machine": "string",
  "opened-ports": [
    "string"
  ],
  "provider-id": "string",
  "public-address": "string",
  "relation-data": [
    {
      "ApplicationData": {},
      "cross-model": true,
      "endpoint": "string",
      "related-endpoint": "string",
      "relation-id": 0,
      "unit-relation-data": {}
    }
  ],
  "tag": "string",
  "workload-version": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|address|string|false|none|none|
|charm|string|true|none|none|
|leader|boolean|false|none|none|
|life|string|false|none|none|
|machine|string|false|none|none|
|opened-ports|[string]|true|none|none|
|provider-id|string|false|none|none|
|public-address|string|false|none|none|
|relation-data|[[EndpointRelationData](#schemaendpointrelationdata)]|false|none|none|
|tag|string|true|none|none|
|workload-version|string|true|none|none|

<h2 id="tocS_UnitsResolved">UnitsResolved</h2>
<!-- backwards compatibility -->
<a id="schemaunitsresolved"></a>
<a id="schema_UnitsResolved"></a>
<a id="tocSunitsresolved"></a>
<a id="tocsunitsresolved"></a>

```json
{
  "all": true,
  "retry": true,
  "tags": {
    "entities": [
      {
        "tag": "string"
      }
    ]
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|all|boolean|false|none|none|
|retry|boolean|false|none|none|
|tags|[Entities](#schemaentities)|false|none|none|

<h2 id="tocS_UpdateChannelArg">UpdateChannelArg</h2>
<!-- backwards compatibility -->
<a id="schemaupdatechannelarg"></a>
<a id="schema_UpdateChannelArg"></a>
<a id="tocSupdatechannelarg"></a>
<a id="tocsupdatechannelarg"></a>

```json
{
  "channel": "string",
  "force": true,
  "tag": {
    "tag": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|channel|string|true|none|none|
|force|boolean|true|none|none|
|tag|[Entity](#schemaentity)|true|none|none|

<h2 id="tocS_UpdateChannelArgs">UpdateChannelArgs</h2>
<!-- backwards compatibility -->
<a id="schemaupdatechannelargs"></a>
<a id="schema_UpdateChannelArgs"></a>
<a id="tocSupdatechannelargs"></a>
<a id="tocsupdatechannelargs"></a>

```json
{
  "args": [
    {
      "channel": "string",
      "force": true,
      "tag": {
        "tag": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|args|[[UpdateChannelArg](#schemaupdatechannelarg)]|true|none|none|

<h2 id="tocS_Value">Value</h2>
<!-- backwards compatibility -->
<a id="schemavalue"></a>
<a id="schema_Value"></a>
<a id="tocSvalue"></a>
<a id="tocsvalue"></a>

```json
{
  "allocate-public-ip": true,
  "arch": "string",
  "container": "string",
  "cores": 0,
  "cpu-power": 0,
  "image-id": "string",
  "instance-role": "string",
  "instance-type": "string",
  "mem": 0,
  "root-disk": 0,
  "root-disk-source": "string",
  "spaces": [
    "string"
  ],
  "tags": [
    "string"
  ],
  "virt-type": "string",
  "zones": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|allocate-public-ip|boolean|false|none|none|
|arch|string|false|none|none|
|container|string|false|none|none|
|cores|integer|false|none|none|
|cpu-power|integer|false|none|none|
|image-id|string|false|none|none|
|instance-role|string|false|none|none|
|instance-type|string|false|none|none|
|mem|integer|false|none|none|
|root-disk|integer|false|none|none|
|root-disk-source|string|false|none|none|
|spaces|[string]|false|none|none|
|tags|[string]|false|none|none|
|virt-type|string|false|none|none|
|zones|[string]|false|none|none|

<h2 id="tocS_AddApplicationOffer">AddApplicationOffer</h2>
<!-- backwards compatibility -->
<a id="schemaaddapplicationoffer"></a>
<a id="schema_AddApplicationOffer"></a>
<a id="tocSaddapplicationoffer"></a>
<a id="tocsaddapplicationoffer"></a>

```json
{
  "application-description": "string",
  "application-name": "string",
  "endpoints": {},
  "model-tag": "string",
  "offer-name": "string",
  "owner-tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|application-description|string|true|none|none|
|application-name|string|true|none|none|
|endpoints|object|true|none|none|
|» .*|string|false|none|none|
|model-tag|string|true|none|none|
|offer-name|string|true|none|none|
|owner-tag|string|false|none|none|

<h2 id="tocS_AddApplicationOffers">AddApplicationOffers</h2>
<!-- backwards compatibility -->
<a id="schemaaddapplicationoffers"></a>
<a id="schema_AddApplicationOffers"></a>
<a id="tocSaddapplicationoffers"></a>
<a id="tocsaddapplicationoffers"></a>

```json
{
  "Offers": [
    {
      "application-description": "string",
      "application-name": "string",
      "endpoints": {},
      "model-tag": "string",
      "offer-name": "string",
      "owner-tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|Offers|[[AddApplicationOffer](#schemaaddapplicationoffer)]|true|none|none|

<h2 id="tocS_ApplicationOfferAdminDetails">ApplicationOfferAdminDetails</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationofferadmindetails"></a>
<a id="schema_ApplicationOfferAdminDetails"></a>
<a id="tocSapplicationofferadmindetails"></a>
<a id="tocsapplicationofferadmindetails"></a>

```json
{
  "ApplicationOfferDetails": {
    "application-description": "string",
    "bindings": {},
    "endpoints": [
      {
        "interface": "string",
        "limit": 0,
        "name": "string",
        "role": "string"
      }
    ],
    "offer-name": "string",
    "offer-url": "string",
    "offer-uuid": "string",
    "source-model-tag": "string",
    "spaces": [
      {
        "cloud-type": "string",
        "name": "string",
        "provider-attributes": {},
        "provider-id": "string",
        "subnets": [
          {
            "cidr": "string",
            "life": "string",
            "provider-id": "string",
            "provider-network-id": "string",
            "provider-space-id": "string",
            "space-tag": "string",
            "status": "string",
            "vlan-tag": 0,
            "zones": [
              "string"
            ]
          }
        ]
      }
    ],
    "users": [
      {
        "access": "string",
        "display-name": "string",
        "user": "string"
      }
    ]
  },
  "application-description": "string",
  "application-name": "string",
  "bindings": {},
  "charm-url": "string",
  "connections": [
    {
      "endpoint": "string",
      "ingress-subnets": [
        "string"
      ],
      "relation-id": 0,
      "source-model-tag": "string",
      "status": {
        "data": {},
        "info": "string",
        "since": "2019-08-24T14:15:22Z",
        "status": "string"
      },
      "username": "string"
    }
  ],
  "endpoints": [
    {
      "interface": "string",
      "limit": 0,
      "name": "string",
      "role": "string"
    }
  ],
  "offer-name": "string",
  "offer-url": "string",
  "offer-uuid": "string",
  "source-model-tag": "string",
  "spaces": [
    {
      "cloud-type": "string",
      "name": "string",
      "provider-attributes": {},
      "provider-id": "string",
      "subnets": [
        {
          "cidr": "string",
          "life": "string",
          "provider-id": "string",
          "provider-network-id": "string",
          "provider-space-id": "string",
          "space-tag": "string",
          "status": "string",
          "vlan-tag": 0,
          "zones": [
            "string"
          ]
        }
      ]
    }
  ],
  "users": [
    {
      "access": "string",
      "display-name": "string",
      "user": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|ApplicationOfferDetails|[ApplicationOfferDetails](#schemaapplicationofferdetails)|true|none|none|
|application-description|string|true|none|none|
|application-name|string|true|none|none|
|bindings|object|false|none|none|
|» .*|string|false|none|none|
|charm-url|string|true|none|none|
|connections|[[OfferConnection](#schemaofferconnection)]|false|none|none|
|endpoints|[[RemoteEndpoint](#schemaremoteendpoint)]|false|none|none|
|offer-name|string|true|none|none|
|offer-url|string|true|none|none|
|offer-uuid|string|true|none|none|
|source-model-tag|string|true|none|none|
|spaces|[[RemoteSpace](#schemaremotespace)]|false|none|none|
|users|[[OfferUserDetails](#schemaofferuserdetails)]|false|none|none|

<h2 id="tocS_ApplicationOfferResult">ApplicationOfferResult</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationofferresult"></a>
<a id="schema_ApplicationOfferResult"></a>
<a id="tocSapplicationofferresult"></a>
<a id="tocsapplicationofferresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": {
    "ApplicationOfferDetails": {
      "application-description": "string",
      "bindings": {},
      "endpoints": [
        {
          "interface": "string",
          "limit": 0,
          "name": "string",
          "role": "string"
        }
      ],
      "offer-name": "string",
      "offer-url": "string",
      "offer-uuid": "string",
      "source-model-tag": "string",
      "spaces": [
        {
          "cloud-type": "string",
          "name": "string",
          "provider-attributes": {},
          "provider-id": "string",
          "subnets": [
            {
              "cidr": "string",
              "life": "string",
              "provider-id": "string",
              "provider-network-id": "string",
              "provider-space-id": "string",
              "space-tag": "string",
              "status": "string",
              "vlan-tag": 0,
              "zones": [
                "string"
              ]
            }
          ]
        }
      ],
      "users": [
        {
          "access": "string",
          "display-name": "string",
          "user": "string"
        }
      ]
    },
    "application-description": "string",
    "application-name": "string",
    "bindings": {},
    "charm-url": "string",
    "connections": [
      {
        "endpoint": "string",
        "ingress-subnets": [
          "string"
        ],
        "relation-id": 0,
        "source-model-tag": "string",
        "status": {
          "data": {},
          "info": "string",
          "since": "2019-08-24T14:15:22Z",
          "status": "string"
        },
        "username": "string"
      }
    ],
    "endpoints": [
      {
        "interface": "string",
        "limit": 0,
        "name": "string",
        "role": "string"
      }
    ],
    "offer-name": "string",
    "offer-url": "string",
    "offer-uuid": "string",
    "source-model-tag": "string",
    "spaces": [
      {
        "cloud-type": "string",
        "name": "string",
        "provider-attributes": {},
        "provider-id": "string",
        "subnets": [
          {
            "cidr": "string",
            "life": "string",
            "provider-id": "string",
            "provider-network-id": "string",
            "provider-space-id": "string",
            "space-tag": "string",
            "status": "string",
            "vlan-tag": 0,
            "zones": [
              "string"
            ]
          }
        ]
      }
    ],
    "users": [
      {
        "access": "string",
        "display-name": "string",
        "user": "string"
      }
    ]
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|result|[ApplicationOfferAdminDetails](#schemaapplicationofferadmindetails)|false|none|none|

<h2 id="tocS_ApplicationOffersResults">ApplicationOffersResults</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationoffersresults"></a>
<a id="schema_ApplicationOffersResults"></a>
<a id="tocSapplicationoffersresults"></a>
<a id="tocsapplicationoffersresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "ApplicationOfferDetails": {
          "application-description": "string",
          "bindings": {},
          "endpoints": [
            {
              "interface": "string",
              "limit": 0,
              "name": "string",
              "role": "string"
            }
          ],
          "offer-name": "string",
          "offer-url": "string",
          "offer-uuid": "string",
          "source-model-tag": "string",
          "spaces": [
            {
              "cloud-type": "string",
              "name": "string",
              "provider-attributes": {},
              "provider-id": "string",
              "subnets": [
                {
                  "cidr": "string",
                  "life": "string",
                  "provider-id": "string",
                  "provider-network-id": "string",
                  "provider-space-id": "string",
                  "space-tag": "string",
                  "status": "string",
                  "vlan-tag": 0,
                  "zones": [
                    "string"
                  ]
                }
              ]
            }
          ],
          "users": [
            {
              "access": "string",
              "display-name": "string",
              "user": "string"
            }
          ]
        },
        "application-description": "string",
        "application-name": "string",
        "bindings": {},
        "charm-url": "string",
        "connections": [
          {
            "endpoint": "string",
            "ingress-subnets": [
              "string"
            ],
            "relation-id": 0,
            "source-model-tag": "string",
            "status": {
              "data": {},
              "info": "string",
              "since": "2019-08-24T14:15:22Z",
              "status": "string"
            },
            "username": "string"
          }
        ],
        "endpoints": [
          {
            "interface": "string",
            "limit": 0,
            "name": "string",
            "role": "string"
          }
        ],
        "offer-name": "string",
        "offer-url": "string",
        "offer-uuid": "string",
        "source-model-tag": "string",
        "spaces": [
          {
            "cloud-type": "string",
            "name": "string",
            "provider-attributes": {},
            "provider-id": "string",
            "subnets": [
              {
                "cidr": "string",
                "life": "string",
                "provider-id": "string",
                "provider-network-id": "string",
                "provider-space-id": "string",
                "space-tag": "string",
                "status": "string",
                "vlan-tag": 0,
                "zones": [
                  "string"
                ]
              }
            ]
          }
        ],
        "users": [
          {
            "access": "string",
            "display-name": "string",
            "user": "string"
          }
        ]
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[ApplicationOfferResult](#schemaapplicationofferresult)]|false|none|none|

<h2 id="tocS_ConsumeOfferDetails">ConsumeOfferDetails</h2>
<!-- backwards compatibility -->
<a id="schemaconsumeofferdetails"></a>
<a id="schema_ConsumeOfferDetails"></a>
<a id="tocSconsumeofferdetails"></a>
<a id="tocsconsumeofferdetails"></a>

```json
{
  "external-controller": {
    "addrs": [
      "string"
    ],
    "ca-cert": "string",
    "controller-alias": "string",
    "controller-tag": "string"
  },
  "macaroon": {},
  "offer": {
    "application-description": "string",
    "bindings": {},
    "endpoints": [
      {
        "interface": "string",
        "limit": 0,
        "name": "string",
        "role": "string"
      }
    ],
    "offer-name": "string",
    "offer-url": "string",
    "offer-uuid": "string",
    "source-model-tag": "string",
    "spaces": [
      {
        "cloud-type": "string",
        "name": "string",
        "provider-attributes": {},
        "provider-id": "string",
        "subnets": [
          {
            "cidr": "string",
            "life": "string",
            "provider-id": "string",
            "provider-network-id": "string",
            "provider-space-id": "string",
            "space-tag": "string",
            "status": "string",
            "vlan-tag": 0,
            "zones": [
              "string"
            ]
          }
        ]
      }
    ],
    "users": [
      {
        "access": "string",
        "display-name": "string",
        "user": "string"
      }
    ]
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|external-controller|[ExternalControllerInfo](#schemaexternalcontrollerinfo)|false|none|none|
|macaroon|[Macaroon](#schemamacaroon)|false|none|none|
|offer|[ApplicationOfferDetails](#schemaapplicationofferdetails)|false|none|none|

<h2 id="tocS_ConsumeOfferDetailsArg">ConsumeOfferDetailsArg</h2>
<!-- backwards compatibility -->
<a id="schemaconsumeofferdetailsarg"></a>
<a id="schema_ConsumeOfferDetailsArg"></a>
<a id="tocSconsumeofferdetailsarg"></a>
<a id="tocsconsumeofferdetailsarg"></a>

```json
{
  "offer-urls": {
    "bakery-version": 0,
    "offer-urls": [
      "string"
    ]
  },
  "user-tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|offer-urls|[OfferURLs](#schemaofferurls)|true|none|none|
|user-tag|string|false|none|none|

<h2 id="tocS_ConsumeOfferDetailsResult">ConsumeOfferDetailsResult</h2>
<!-- backwards compatibility -->
<a id="schemaconsumeofferdetailsresult"></a>
<a id="schema_ConsumeOfferDetailsResult"></a>
<a id="tocSconsumeofferdetailsresult"></a>
<a id="tocsconsumeofferdetailsresult"></a>

```json
{
  "ConsumeOfferDetails": {
    "external-controller": {
      "addrs": [
        "string"
      ],
      "ca-cert": "string",
      "controller-alias": "string",
      "controller-tag": "string"
    },
    "macaroon": {},
    "offer": {
      "application-description": "string",
      "bindings": {},
      "endpoints": [
        {
          "interface": "string",
          "limit": 0,
          "name": "string",
          "role": "string"
        }
      ],
      "offer-name": "string",
      "offer-url": "string",
      "offer-uuid": "string",
      "source-model-tag": "string",
      "spaces": [
        {
          "cloud-type": "string",
          "name": "string",
          "provider-attributes": {},
          "provider-id": "string",
          "subnets": [
            {
              "cidr": "string",
              "life": "string",
              "provider-id": "string",
              "provider-network-id": "string",
              "provider-space-id": "string",
              "space-tag": "string",
              "status": "string",
              "vlan-tag": 0,
              "zones": [
                "string"
              ]
            }
          ]
        }
      ],
      "users": [
        {
          "access": "string",
          "display-name": "string",
          "user": "string"
        }
      ]
    }
  },
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "external-controller": {
    "addrs": [
      "string"
    ],
    "ca-cert": "string",
    "controller-alias": "string",
    "controller-tag": "string"
  },
  "macaroon": {},
  "offer": {
    "application-description": "string",
    "bindings": {},
    "endpoints": [
      {
        "interface": "string",
        "limit": 0,
        "name": "string",
        "role": "string"
      }
    ],
    "offer-name": "string",
    "offer-url": "string",
    "offer-uuid": "string",
    "source-model-tag": "string",
    "spaces": [
      {
        "cloud-type": "string",
        "name": "string",
        "provider-attributes": {},
        "provider-id": "string",
        "subnets": [
          {
            "cidr": "string",
            "life": "string",
            "provider-id": "string",
            "provider-network-id": "string",
            "provider-space-id": "string",
            "space-tag": "string",
            "status": "string",
            "vlan-tag": 0,
            "zones": [
              "string"
            ]
          }
        ]
      }
    ],
    "users": [
      {
        "access": "string",
        "display-name": "string",
        "user": "string"
      }
    ]
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|ConsumeOfferDetails|[ConsumeOfferDetails](#schemaconsumeofferdetails)|true|none|none|
|error|[Error](#schemaerror)|false|none|none|
|external-controller|[ExternalControllerInfo](#schemaexternalcontrollerinfo)|false|none|none|
|macaroon|[Macaroon](#schemamacaroon)|false|none|none|
|offer|[ApplicationOfferDetails](#schemaapplicationofferdetails)|false|none|none|

<h2 id="tocS_ConsumeOfferDetailsResults">ConsumeOfferDetailsResults</h2>
<!-- backwards compatibility -->
<a id="schemaconsumeofferdetailsresults"></a>
<a id="schema_ConsumeOfferDetailsResults"></a>
<a id="tocSconsumeofferdetailsresults"></a>
<a id="tocsconsumeofferdetailsresults"></a>

```json
{
  "results": [
    {
      "ConsumeOfferDetails": {
        "external-controller": {
          "addrs": [
            "string"
          ],
          "ca-cert": "string",
          "controller-alias": "string",
          "controller-tag": "string"
        },
        "macaroon": {},
        "offer": {
          "application-description": "string",
          "bindings": {},
          "endpoints": [
            {
              "interface": "string",
              "limit": 0,
              "name": "string",
              "role": "string"
            }
          ],
          "offer-name": "string",
          "offer-url": "string",
          "offer-uuid": "string",
          "source-model-tag": "string",
          "spaces": [
            {
              "cloud-type": "string",
              "name": "string",
              "provider-attributes": {},
              "provider-id": "string",
              "subnets": [
                {
                  "cidr": "string",
                  "life": "string",
                  "provider-id": "string",
                  "provider-network-id": "string",
                  "provider-space-id": "string",
                  "space-tag": "string",
                  "status": "string",
                  "vlan-tag": 0,
                  "zones": [
                    "string"
                  ]
                }
              ]
            }
          ],
          "users": [
            {
              "access": "string",
              "display-name": "string",
              "user": "string"
            }
          ]
        }
      },
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "external-controller": {
        "addrs": [
          "string"
        ],
        "ca-cert": "string",
        "controller-alias": "string",
        "controller-tag": "string"
      },
      "macaroon": {},
      "offer": {
        "application-description": "string",
        "bindings": {},
        "endpoints": [
          {
            "interface": "string",
            "limit": 0,
            "name": "string",
            "role": "string"
          }
        ],
        "offer-name": "string",
        "offer-url": "string",
        "offer-uuid": "string",
        "source-model-tag": "string",
        "spaces": [
          {
            "cloud-type": "string",
            "name": "string",
            "provider-attributes": {},
            "provider-id": "string",
            "subnets": [
              {
                "cidr": "string",
                "life": "string",
                "provider-id": "string",
                "provider-network-id": "string",
                "provider-space-id": "string",
                "space-tag": "string",
                "status": "string",
                "vlan-tag": 0,
                "zones": [
                  "string"
                ]
              }
            ]
          }
        ],
        "users": [
          {
            "access": "string",
            "display-name": "string",
            "user": "string"
          }
        ]
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[ConsumeOfferDetailsResult](#schemaconsumeofferdetailsresult)]|false|none|none|

<h2 id="tocS_DestroyApplicationOffers">DestroyApplicationOffers</h2>
<!-- backwards compatibility -->
<a id="schemadestroyapplicationoffers"></a>
<a id="schema_DestroyApplicationOffers"></a>
<a id="tocSdestroyapplicationoffers"></a>
<a id="tocsdestroyapplicationoffers"></a>

```json
{
  "force": true,
  "offer-urls": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|force|boolean|false|none|none|
|offer-urls|[string]|true|none|none|

<h2 id="tocS_EndpointFilterAttributes">EndpointFilterAttributes</h2>
<!-- backwards compatibility -->
<a id="schemaendpointfilterattributes"></a>
<a id="schema_EndpointFilterAttributes"></a>
<a id="tocSendpointfilterattributes"></a>
<a id="tocsendpointfilterattributes"></a>

```json
{
  "interface": "string",
  "name": "string",
  "role": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|interface|string|true|none|none|
|name|string|true|none|none|
|role|string|true|none|none|

<h2 id="tocS_EntityStatus">EntityStatus</h2>
<!-- backwards compatibility -->
<a id="schemaentitystatus"></a>
<a id="schema_EntityStatus"></a>
<a id="tocSentitystatus"></a>
<a id="tocsentitystatus"></a>

```json
{
  "data": {},
  "info": "string",
  "since": "2019-08-24T14:15:22Z",
  "status": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|data|object|false|none|none|
|» .*|object|false|none|none|
|info|string|true|none|none|
|since|string(date-time)|true|none|none|
|status|string|true|none|none|

<h2 id="tocS_ModifyOfferAccess">ModifyOfferAccess</h2>
<!-- backwards compatibility -->
<a id="schemamodifyofferaccess"></a>
<a id="schema_ModifyOfferAccess"></a>
<a id="tocSmodifyofferaccess"></a>
<a id="tocsmodifyofferaccess"></a>

```json
{
  "access": "string",
  "action": "string",
  "offer-url": "string",
  "user-tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|access|string|true|none|none|
|action|string|true|none|none|
|offer-url|string|true|none|none|
|user-tag|string|true|none|none|

<h2 id="tocS_ModifyOfferAccessRequest">ModifyOfferAccessRequest</h2>
<!-- backwards compatibility -->
<a id="schemamodifyofferaccessrequest"></a>
<a id="schema_ModifyOfferAccessRequest"></a>
<a id="tocSmodifyofferaccessrequest"></a>
<a id="tocsmodifyofferaccessrequest"></a>

```json
{
  "changes": [
    {
      "access": "string",
      "action": "string",
      "offer-url": "string",
      "user-tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|changes|[[ModifyOfferAccess](#schemamodifyofferaccess)]|true|none|none|

<h2 id="tocS_OfferConnection">OfferConnection</h2>
<!-- backwards compatibility -->
<a id="schemaofferconnection"></a>
<a id="schema_OfferConnection"></a>
<a id="tocSofferconnection"></a>
<a id="tocsofferconnection"></a>

```json
{
  "endpoint": "string",
  "ingress-subnets": [
    "string"
  ],
  "relation-id": 0,
  "source-model-tag": "string",
  "status": {
    "data": {},
    "info": "string",
    "since": "2019-08-24T14:15:22Z",
    "status": "string"
  },
  "username": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|endpoint|string|true|none|none|
|ingress-subnets|[string]|true|none|none|
|relation-id|integer|true|none|none|
|source-model-tag|string|true|none|none|
|status|[EntityStatus](#schemaentitystatus)|true|none|none|
|username|string|true|none|none|

<h2 id="tocS_OfferFilter">OfferFilter</h2>
<!-- backwards compatibility -->
<a id="schemaofferfilter"></a>
<a id="schema_OfferFilter"></a>
<a id="tocSofferfilter"></a>
<a id="tocsofferfilter"></a>

```json
{
  "allowed-users": [
    "string"
  ],
  "application-description": "string",
  "application-name": "string",
  "application-user": "string",
  "connected-users": [
    "string"
  ],
  "endpoints": [
    {
      "interface": "string",
      "name": "string",
      "role": "string"
    }
  ],
  "model-name": "string",
  "offer-name": "string",
  "owner-name": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|allowed-users|[string]|true|none|none|
|application-description|string|true|none|none|
|application-name|string|true|none|none|
|application-user|string|true|none|none|
|connected-users|[string]|true|none|none|
|endpoints|[[EndpointFilterAttributes](#schemaendpointfilterattributes)]|true|none|none|
|model-name|string|true|none|none|
|offer-name|string|true|none|none|
|owner-name|string|true|none|none|

<h2 id="tocS_OfferFilters">OfferFilters</h2>
<!-- backwards compatibility -->
<a id="schemaofferfilters"></a>
<a id="schema_OfferFilters"></a>
<a id="tocSofferfilters"></a>
<a id="tocsofferfilters"></a>

```json
{
  "Filters": [
    {
      "allowed-users": [
        "string"
      ],
      "application-description": "string",
      "application-name": "string",
      "application-user": "string",
      "connected-users": [
        "string"
      ],
      "endpoints": [
        {
          "interface": "string",
          "name": "string",
          "role": "string"
        }
      ],
      "model-name": "string",
      "offer-name": "string",
      "owner-name": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|Filters|[[OfferFilter](#schemaofferfilter)]|true|none|none|

<h2 id="tocS_OfferURLs">OfferURLs</h2>
<!-- backwards compatibility -->
<a id="schemaofferurls"></a>
<a id="schema_OfferURLs"></a>
<a id="tocSofferurls"></a>
<a id="tocsofferurls"></a>

```json
{
  "bakery-version": 0,
  "offer-urls": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|bakery-version|integer|false|none|none|
|offer-urls|[string]|false|none|none|

<h2 id="tocS_QueryApplicationOffersResults">QueryApplicationOffersResults</h2>
<!-- backwards compatibility -->
<a id="schemaqueryapplicationoffersresults"></a>
<a id="schema_QueryApplicationOffersResults"></a>
<a id="tocSqueryapplicationoffersresults"></a>
<a id="tocsqueryapplicationoffersresults"></a>

```json
{
  "results": [
    {
      "ApplicationOfferDetails": {
        "application-description": "string",
        "bindings": {},
        "endpoints": [
          {
            "interface": "string",
            "limit": 0,
            "name": "string",
            "role": "string"
          }
        ],
        "offer-name": "string",
        "offer-url": "string",
        "offer-uuid": "string",
        "source-model-tag": "string",
        "spaces": [
          {
            "cloud-type": "string",
            "name": "string",
            "provider-attributes": {},
            "provider-id": "string",
            "subnets": [
              {
                "cidr": "string",
                "life": "string",
                "provider-id": "string",
                "provider-network-id": "string",
                "provider-space-id": "string",
                "space-tag": "string",
                "status": "string",
                "vlan-tag": 0,
                "zones": [
                  "string"
                ]
              }
            ]
          }
        ],
        "users": [
          {
            "access": "string",
            "display-name": "string",
            "user": "string"
          }
        ]
      },
      "application-description": "string",
      "application-name": "string",
      "bindings": {},
      "charm-url": "string",
      "connections": [
        {
          "endpoint": "string",
          "ingress-subnets": [
            "string"
          ],
          "relation-id": 0,
          "source-model-tag": "string",
          "status": {
            "data": {},
            "info": "string",
            "since": "2019-08-24T14:15:22Z",
            "status": "string"
          },
          "username": "string"
        }
      ],
      "endpoints": [
        {
          "interface": "string",
          "limit": 0,
          "name": "string",
          "role": "string"
        }
      ],
      "offer-name": "string",
      "offer-url": "string",
      "offer-uuid": "string",
      "source-model-tag": "string",
      "spaces": [
        {
          "cloud-type": "string",
          "name": "string",
          "provider-attributes": {},
          "provider-id": "string",
          "subnets": [
            {
              "cidr": "string",
              "life": "string",
              "provider-id": "string",
              "provider-network-id": "string",
              "provider-space-id": "string",
              "space-tag": "string",
              "status": "string",
              "vlan-tag": 0,
              "zones": [
                "string"
              ]
            }
          ]
        }
      ],
      "users": [
        {
          "access": "string",
          "display-name": "string",
          "user": "string"
        }
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[ApplicationOfferAdminDetails](#schemaapplicationofferadmindetails)]|true|none|none|

<h2 id="tocS_RemoteApplicationInfo">RemoteApplicationInfo</h2>
<!-- backwards compatibility -->
<a id="schemaremoteapplicationinfo"></a>
<a id="schema_RemoteApplicationInfo"></a>
<a id="tocSremoteapplicationinfo"></a>
<a id="tocsremoteapplicationinfo"></a>

```json
{
  "description": "string",
  "endpoints": [
    {
      "interface": "string",
      "limit": 0,
      "name": "string",
      "role": "string"
    }
  ],
  "icon-url-path": "string",
  "model-tag": "string",
  "name": "string",
  "offer-url": "string",
  "source-model-label": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|description|string|true|none|none|
|endpoints|[[RemoteEndpoint](#schemaremoteendpoint)]|true|none|none|
|icon-url-path|string|true|none|none|
|model-tag|string|true|none|none|
|name|string|true|none|none|
|offer-url|string|true|none|none|
|source-model-label|string|false|none|none|

<h2 id="tocS_RemoteApplicationInfoResult">RemoteApplicationInfoResult</h2>
<!-- backwards compatibility -->
<a id="schemaremoteapplicationinforesult"></a>
<a id="schema_RemoteApplicationInfoResult"></a>
<a id="tocSremoteapplicationinforesult"></a>
<a id="tocsremoteapplicationinforesult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": {
    "description": "string",
    "endpoints": [
      {
        "interface": "string",
        "limit": 0,
        "name": "string",
        "role": "string"
      }
    ],
    "icon-url-path": "string",
    "model-tag": "string",
    "name": "string",
    "offer-url": "string",
    "source-model-label": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|result|[RemoteApplicationInfo](#schemaremoteapplicationinfo)|false|none|none|

<h2 id="tocS_RemoteApplicationInfoResults">RemoteApplicationInfoResults</h2>
<!-- backwards compatibility -->
<a id="schemaremoteapplicationinforesults"></a>
<a id="schema_RemoteApplicationInfoResults"></a>
<a id="tocSremoteapplicationinforesults"></a>
<a id="tocsremoteapplicationinforesults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "description": "string",
        "endpoints": [
          {
            "interface": "string",
            "limit": 0,
            "name": "string",
            "role": "string"
          }
        ],
        "icon-url-path": "string",
        "model-tag": "string",
        "name": "string",
        "offer-url": "string",
        "source-model-label": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[RemoteApplicationInfoResult](#schemaremoteapplicationinforesult)]|true|none|none|

<h2 id="tocS_BackupsCreateArgs">BackupsCreateArgs</h2>
<!-- backwards compatibility -->
<a id="schemabackupscreateargs"></a>
<a id="schema_BackupsCreateArgs"></a>
<a id="tocSbackupscreateargs"></a>
<a id="tocsbackupscreateargs"></a>

```json
{
  "no-download": true,
  "notes": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|no-download|boolean|true|none|none|
|notes|string|true|none|none|

<h2 id="tocS_BackupsMetadataResult">BackupsMetadataResult</h2>
<!-- backwards compatibility -->
<a id="schemabackupsmetadataresult"></a>
<a id="schema_BackupsMetadataResult"></a>
<a id="tocSbackupsmetadataresult"></a>
<a id="tocsbackupsmetadataresult"></a>

```json
{
  "base": "string",
  "checksum": "string",
  "checksum-format": "string",
  "controller-machine-id": "string",
  "controller-machine-inst-id": "string",
  "controller-uuid": "string",
  "filename": "string",
  "finished": "2019-08-24T14:15:22Z",
  "format-version": 0,
  "ha-nodes": 0,
  "hostname": "string",
  "id": "string",
  "machine": "string",
  "model": "string",
  "notes": "string",
  "size": 0,
  "started": "2019-08-24T14:15:22Z",
  "stored": "2019-08-24T14:15:22Z",
  "version": {
    "Build": 0,
    "Major": 0,
    "Minor": 0,
    "Patch": 0,
    "Tag": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|base|string|true|none|none|
|checksum|string|true|none|none|
|checksum-format|string|true|none|none|
|controller-machine-id|string|true|none|none|
|controller-machine-inst-id|string|true|none|none|
|controller-uuid|string|true|none|none|
|filename|string|true|none|none|
|finished|string(date-time)|true|none|none|
|format-version|integer|true|none|none|
|ha-nodes|integer|true|none|none|
|hostname|string|true|none|none|
|id|string|true|none|none|
|machine|string|true|none|none|
|model|string|true|none|none|
|notes|string|true|none|none|
|size|integer|true|none|none|
|started|string(date-time)|true|none|none|
|stored|string(date-time)|true|none|none|
|version|[Number](#schemanumber)|true|none|none|

<h2 id="tocS_Number">Number</h2>
<!-- backwards compatibility -->
<a id="schemanumber"></a>
<a id="schema_Number"></a>
<a id="tocSnumber"></a>
<a id="tocsnumber"></a>

```json
{
  "Build": 0,
  "Major": 0,
  "Minor": 0,
  "Patch": 0,
  "Tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|Build|integer|true|none|none|
|Major|integer|true|none|none|
|Minor|integer|true|none|none|
|Patch|integer|true|none|none|
|Tag|string|true|none|none|

<h2 id="tocS_Block">Block</h2>
<!-- backwards compatibility -->
<a id="schemablock"></a>
<a id="schema_Block"></a>
<a id="tocSblock"></a>
<a id="tocsblock"></a>

```json
{
  "id": "string",
  "message": "string",
  "tag": "string",
  "type": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|id|string|true|none|none|
|message|string|false|none|none|
|tag|string|true|none|none|
|type|string|true|none|none|

<h2 id="tocS_BlockResult">BlockResult</h2>
<!-- backwards compatibility -->
<a id="schemablockresult"></a>
<a id="schema_BlockResult"></a>
<a id="tocSblockresult"></a>
<a id="tocsblockresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": {
    "id": "string",
    "message": "string",
    "tag": "string",
    "type": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|result|[Block](#schemablock)|true|none|none|

<h2 id="tocS_BlockResults">BlockResults</h2>
<!-- backwards compatibility -->
<a id="schemablockresults"></a>
<a id="schema_BlockResults"></a>
<a id="tocSblockresults"></a>
<a id="tocsblockresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "id": "string",
        "message": "string",
        "tag": "string",
        "type": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[BlockResult](#schemablockresult)]|false|none|none|

<h2 id="tocS_BlockSwitchParams">BlockSwitchParams</h2>
<!-- backwards compatibility -->
<a id="schemablockswitchparams"></a>
<a id="schema_BlockSwitchParams"></a>
<a id="tocSblockswitchparams"></a>
<a id="tocsblockswitchparams"></a>

```json
{
  "message": "string",
  "type": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|message|string|false|none|none|
|type|string|true|none|none|

<h2 id="tocS_BundleChange">BundleChange</h2>
<!-- backwards compatibility -->
<a id="schemabundlechange"></a>
<a id="schema_BundleChange"></a>
<a id="tocSbundlechange"></a>
<a id="tocsbundlechange"></a>

```json
{
  "args": [
    {}
  ],
  "id": "string",
  "method": "string",
  "requires": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|args|[object]|true|none|none|
|id|string|true|none|none|
|method|string|true|none|none|
|requires|[string]|true|none|none|

<h2 id="tocS_BundleChangesMapArgs">BundleChangesMapArgs</h2>
<!-- backwards compatibility -->
<a id="schemabundlechangesmapargs"></a>
<a id="schema_BundleChangesMapArgs"></a>
<a id="tocSbundlechangesmapargs"></a>
<a id="tocsbundlechangesmapargs"></a>

```json
{
  "args": {},
  "id": "string",
  "method": "string",
  "requires": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|args|object|true|none|none|
|» .*|object|false|none|none|
|id|string|true|none|none|
|method|string|true|none|none|
|requires|[string]|true|none|none|

<h2 id="tocS_BundleChangesMapArgsResults">BundleChangesMapArgsResults</h2>
<!-- backwards compatibility -->
<a id="schemabundlechangesmapargsresults"></a>
<a id="schema_BundleChangesMapArgsResults"></a>
<a id="tocSbundlechangesmapargsresults"></a>
<a id="tocsbundlechangesmapargsresults"></a>

```json
{
  "changes": [
    {
      "args": {},
      "id": "string",
      "method": "string",
      "requires": [
        "string"
      ]
    }
  ],
  "errors": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|changes|[[BundleChangesMapArgs](#schemabundlechangesmapargs)]|false|none|none|
|errors|[string]|false|none|none|

<h2 id="tocS_BundleChangesParams">BundleChangesParams</h2>
<!-- backwards compatibility -->
<a id="schemabundlechangesparams"></a>
<a id="schema_BundleChangesParams"></a>
<a id="tocSbundlechangesparams"></a>
<a id="tocsbundlechangesparams"></a>

```json
{
  "bundleURL": "string",
  "yaml": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|bundleURL|string|true|none|none|
|yaml|string|true|none|none|

<h2 id="tocS_BundleChangesResults">BundleChangesResults</h2>
<!-- backwards compatibility -->
<a id="schemabundlechangesresults"></a>
<a id="schema_BundleChangesResults"></a>
<a id="tocSbundlechangesresults"></a>
<a id="tocsbundlechangesresults"></a>

```json
{
  "changes": [
    {
      "args": [
        {}
      ],
      "id": "string",
      "method": "string",
      "requires": [
        "string"
      ]
    }
  ],
  "errors": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|changes|[[BundleChange](#schemabundlechange)]|false|none|none|
|errors|[string]|false|none|none|

<h2 id="tocS_ExportBundleParams">ExportBundleParams</h2>
<!-- backwards compatibility -->
<a id="schemaexportbundleparams"></a>
<a id="schema_ExportBundleParams"></a>
<a id="tocSexportbundleparams"></a>
<a id="tocsexportbundleparams"></a>

```json
{
  "include-charm-defaults": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|include-charm-defaults|boolean|false|none|none|

<h2 id="tocS_AddCharmWithOrigin">AddCharmWithOrigin</h2>
<!-- backwards compatibility -->
<a id="schemaaddcharmwithorigin"></a>
<a id="schema_AddCharmWithOrigin"></a>
<a id="tocSaddcharmwithorigin"></a>
<a id="tocsaddcharmwithorigin"></a>

```json
{
  "charm-origin": {
    "architecture": "string",
    "base": {
      "channel": "string",
      "name": "string"
    },
    "branch": "string",
    "hash": "string",
    "id": "string",
    "instance-key": "string",
    "revision": 0,
    "risk": "string",
    "source": "string",
    "track": "string",
    "type": "string"
  },
  "force": true,
  "url": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|charm-origin|[CharmOrigin](#schemacharmorigin)|true|none|none|
|force|boolean|true|none|none|
|url|string|true|none|none|

<h2 id="tocS_ApplicationCharmPlacement">ApplicationCharmPlacement</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationcharmplacement"></a>
<a id="schema_ApplicationCharmPlacement"></a>
<a id="tocSapplicationcharmplacement"></a>
<a id="tocsapplicationcharmplacement"></a>

```json
{
  "application": "string",
  "charm-url": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|application|string|true|none|none|
|charm-url|string|true|none|none|

<h2 id="tocS_ApplicationCharmPlacements">ApplicationCharmPlacements</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationcharmplacements"></a>
<a id="schema_ApplicationCharmPlacements"></a>
<a id="tocSapplicationcharmplacements"></a>
<a id="tocsapplicationcharmplacements"></a>

```json
{
  "placements": [
    {
      "application": "string",
      "charm-url": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|placements|[[ApplicationCharmPlacement](#schemaapplicationcharmplacement)]|true|none|none|

<h2 id="tocS_Charm">Charm</h2>
<!-- backwards compatibility -->
<a id="schemacharm"></a>
<a id="schema_Charm"></a>
<a id="tocScharm"></a>
<a id="tocscharm"></a>

```json
{
  "actions": {
    "specs": {}
  },
  "config": {},
  "lxd-profile": {
    "config": {},
    "description": "string",
    "devices": {}
  },
  "manifest": {
    "bases": [
      {
        "architectures": [
          "string"
        ],
        "channel": "string",
        "name": "string"
      }
    ]
  },
  "meta": {
    "assumes-expr": {
      "Expression": {}
    },
    "categories": [
      "string"
    ],
    "containers": {},
    "deployment": {
      "min-version": "string",
      "mode": "string",
      "service": "string",
      "type": "string"
    },
    "description": "string",
    "devices": {},
    "extra-bindings": {},
    "min-juju-version": "string",
    "name": "string",
    "payload-classes": {},
    "peers": {},
    "provides": {},
    "requires": {},
    "resources": {},
    "series": [
      "string"
    ],
    "storage": {},
    "subordinate": true,
    "summary": "string",
    "tags": [
      "string"
    ],
    "terms": [
      "string"
    ]
  },
  "metrics": {
    "metrics": {},
    "plan": {
      "required": true
    }
  },
  "revision": 0,
  "url": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|actions|[CharmActions](#schemacharmactions)|false|none|none|
|config|object|true|none|none|
|» .*|[CharmOption](#schemacharmoption)|false|none|none|
|lxd-profile|[CharmLXDProfile](#schemacharmlxdprofile)|false|none|none|
|manifest|[CharmManifest](#schemacharmmanifest)|false|none|none|
|meta|[CharmMeta](#schemacharmmeta)|false|none|none|
|metrics|[CharmMetrics](#schemacharmmetrics)|false|none|none|
|revision|integer|true|none|none|
|url|string|true|none|none|

<h2 id="tocS_CharmActionSpec">CharmActionSpec</h2>
<!-- backwards compatibility -->
<a id="schemacharmactionspec"></a>
<a id="schema_CharmActionSpec"></a>
<a id="tocScharmactionspec"></a>
<a id="tocscharmactionspec"></a>

```json
{
  "description": "string",
  "params": {}
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|description|string|true|none|none|
|params|object|true|none|none|
|» .*|object|false|none|none|

<h2 id="tocS_CharmActions">CharmActions</h2>
<!-- backwards compatibility -->
<a id="schemacharmactions"></a>
<a id="schema_CharmActions"></a>
<a id="tocScharmactions"></a>
<a id="tocscharmactions"></a>

```json
{
  "specs": {}
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|specs|object|false|none|none|
|» .*|[CharmActionSpec](#schemacharmactionspec)|false|none|none|

<h2 id="tocS_CharmBase">CharmBase</h2>
<!-- backwards compatibility -->
<a id="schemacharmbase"></a>
<a id="schema_CharmBase"></a>
<a id="tocScharmbase"></a>
<a id="tocscharmbase"></a>

```json
{
  "architectures": [
    "string"
  ],
  "channel": "string",
  "name": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|architectures|[string]|false|none|none|
|channel|string|false|none|none|
|name|string|false|none|none|

<h2 id="tocS_CharmContainer">CharmContainer</h2>
<!-- backwards compatibility -->
<a id="schemacharmcontainer"></a>
<a id="schema_CharmContainer"></a>
<a id="tocScharmcontainer"></a>
<a id="tocscharmcontainer"></a>

```json
{
  "mounts": [
    {
      "location": "string",
      "storage": "string"
    }
  ],
  "resource": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|mounts|[[CharmMount](#schemacharmmount)]|false|none|none|
|resource|string|false|none|none|

<h2 id="tocS_CharmDeployment">CharmDeployment</h2>
<!-- backwards compatibility -->
<a id="schemacharmdeployment"></a>
<a id="schema_CharmDeployment"></a>
<a id="tocScharmdeployment"></a>
<a id="tocscharmdeployment"></a>

```json
{
  "min-version": "string",
  "mode": "string",
  "service": "string",
  "type": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|min-version|string|true|none|none|
|mode|string|true|none|none|
|service|string|true|none|none|
|type|string|true|none|none|

<h2 id="tocS_CharmDevice">CharmDevice</h2>
<!-- backwards compatibility -->
<a id="schemacharmdevice"></a>
<a id="schema_CharmDevice"></a>
<a id="tocScharmdevice"></a>
<a id="tocscharmdevice"></a>

```json
{
  "CountMax": 0,
  "CountMin": 0,
  "Description": "string",
  "Name": "string",
  "Type": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|CountMax|integer|true|none|none|
|CountMin|integer|true|none|none|
|Description|string|true|none|none|
|Name|string|true|none|none|
|Type|string|true|none|none|

<h2 id="tocS_CharmLXDProfile">CharmLXDProfile</h2>
<!-- backwards compatibility -->
<a id="schemacharmlxdprofile"></a>
<a id="schema_CharmLXDProfile"></a>
<a id="tocScharmlxdprofile"></a>
<a id="tocscharmlxdprofile"></a>

```json
{
  "config": {},
  "description": "string",
  "devices": {}
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|config|object|true|none|none|
|» .*|string|false|none|none|
|description|string|true|none|none|
|devices|object|true|none|none|
|» .*|object|false|none|none|
|»» .*|string|false|none|none|

<h2 id="tocS_CharmManifest">CharmManifest</h2>
<!-- backwards compatibility -->
<a id="schemacharmmanifest"></a>
<a id="schema_CharmManifest"></a>
<a id="tocScharmmanifest"></a>
<a id="tocscharmmanifest"></a>

```json
{
  "bases": [
    {
      "architectures": [
        "string"
      ],
      "channel": "string",
      "name": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|bases|[[CharmBase](#schemacharmbase)]|false|none|none|

<h2 id="tocS_CharmMeta">CharmMeta</h2>
<!-- backwards compatibility -->
<a id="schemacharmmeta"></a>
<a id="schema_CharmMeta"></a>
<a id="tocScharmmeta"></a>
<a id="tocscharmmeta"></a>

```json
{
  "assumes-expr": {
    "Expression": {}
  },
  "categories": [
    "string"
  ],
  "containers": {},
  "deployment": {
    "min-version": "string",
    "mode": "string",
    "service": "string",
    "type": "string"
  },
  "description": "string",
  "devices": {},
  "extra-bindings": {},
  "min-juju-version": "string",
  "name": "string",
  "payload-classes": {},
  "peers": {},
  "provides": {},
  "requires": {},
  "resources": {},
  "series": [
    "string"
  ],
  "storage": {},
  "subordinate": true,
  "summary": "string",
  "tags": [
    "string"
  ],
  "terms": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|assumes-expr|[ExpressionTree](#schemaexpressiontree)|false|none|none|
|categories|[string]|false|none|none|
|containers|object|false|none|none|
|» .*|[CharmContainer](#schemacharmcontainer)|false|none|none|
|deployment|[CharmDeployment](#schemacharmdeployment)|false|none|none|
|description|string|true|none|none|
|devices|object|false|none|none|
|» .*|[CharmDevice](#schemacharmdevice)|false|none|none|
|extra-bindings|object|false|none|none|
|» .*|string|false|none|none|
|min-juju-version|string|false|none|none|
|name|string|true|none|none|
|payload-classes|object|false|none|none|
|» .*|[CharmPayloadClass](#schemacharmpayloadclass)|false|none|none|
|peers|object|false|none|none|
|» .*|[CharmRelation](#schemacharmrelation)|false|none|none|
|provides|object|false|none|none|
|» .*|[CharmRelation](#schemacharmrelation)|false|none|none|
|requires|object|false|none|none|
|» .*|[CharmRelation](#schemacharmrelation)|false|none|none|
|resources|object|false|none|none|
|» .*|[CharmResourceMeta](#schemacharmresourcemeta)|false|none|none|
|series|[string]|false|none|none|
|storage|object|false|none|none|
|» .*|[CharmStorage](#schemacharmstorage)|false|none|none|
|subordinate|boolean|true|none|none|
|summary|string|true|none|none|
|tags|[string]|false|none|none|
|terms|[string]|false|none|none|

<h2 id="tocS_CharmMetric">CharmMetric</h2>
<!-- backwards compatibility -->
<a id="schemacharmmetric"></a>
<a id="schema_CharmMetric"></a>
<a id="tocScharmmetric"></a>
<a id="tocscharmmetric"></a>

```json
{
  "description": "string",
  "type": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|description|string|true|none|none|
|type|string|true|none|none|

<h2 id="tocS_CharmMetrics">CharmMetrics</h2>
<!-- backwards compatibility -->
<a id="schemacharmmetrics"></a>
<a id="schema_CharmMetrics"></a>
<a id="tocScharmmetrics"></a>
<a id="tocscharmmetrics"></a>

```json
{
  "metrics": {},
  "plan": {
    "required": true
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|metrics|object|true|none|none|
|» .*|[CharmMetric](#schemacharmmetric)|false|none|none|
|plan|[CharmPlan](#schemacharmplan)|true|none|none|

<h2 id="tocS_CharmMount">CharmMount</h2>
<!-- backwards compatibility -->
<a id="schemacharmmount"></a>
<a id="schema_CharmMount"></a>
<a id="tocScharmmount"></a>
<a id="tocscharmmount"></a>

```json
{
  "location": "string",
  "storage": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|location|string|false|none|none|
|storage|string|false|none|none|

<h2 id="tocS_CharmOption">CharmOption</h2>
<!-- backwards compatibility -->
<a id="schemacharmoption"></a>
<a id="schema_CharmOption"></a>
<a id="tocScharmoption"></a>
<a id="tocscharmoption"></a>

```json
{
  "default": {},
  "description": "string",
  "type": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|default|object|false|none|none|
|description|string|false|none|none|
|type|string|true|none|none|

<h2 id="tocS_CharmOriginResult">CharmOriginResult</h2>
<!-- backwards compatibility -->
<a id="schemacharmoriginresult"></a>
<a id="schema_CharmOriginResult"></a>
<a id="tocScharmoriginresult"></a>
<a id="tocscharmoriginresult"></a>

```json
{
  "charm-origin": {
    "architecture": "string",
    "base": {
      "channel": "string",
      "name": "string"
    },
    "branch": "string",
    "hash": "string",
    "id": "string",
    "instance-key": "string",
    "revision": 0,
    "risk": "string",
    "source": "string",
    "track": "string",
    "type": "string"
  },
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|charm-origin|[CharmOrigin](#schemacharmorigin)|true|none|none|
|error|[Error](#schemaerror)|false|none|none|

<h2 id="tocS_CharmPayloadClass">CharmPayloadClass</h2>
<!-- backwards compatibility -->
<a id="schemacharmpayloadclass"></a>
<a id="schema_CharmPayloadClass"></a>
<a id="tocScharmpayloadclass"></a>
<a id="tocscharmpayloadclass"></a>

```json
{
  "name": "string",
  "type": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|name|string|true|none|none|
|type|string|true|none|none|

<h2 id="tocS_CharmPlan">CharmPlan</h2>
<!-- backwards compatibility -->
<a id="schemacharmplan"></a>
<a id="schema_CharmPlan"></a>
<a id="tocScharmplan"></a>
<a id="tocscharmplan"></a>

```json
{
  "required": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|required|boolean|true|none|none|

<h2 id="tocS_CharmResource">CharmResource</h2>
<!-- backwards compatibility -->
<a id="schemacharmresource"></a>
<a id="schema_CharmResource"></a>
<a id="tocScharmresource"></a>
<a id="tocscharmresource"></a>

```json
{
  "description": "string",
  "fingerprint": [
    0
  ],
  "name": "string",
  "origin": "string",
  "path": "string",
  "revision": 0,
  "size": 0,
  "type": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|description|string|false|none|none|
|fingerprint|[integer]|true|none|none|
|name|string|true|none|none|
|origin|string|true|none|none|
|path|string|true|none|none|
|revision|integer|true|none|none|
|size|integer|true|none|none|
|type|string|true|none|none|

<h2 id="tocS_CharmResourceMeta">CharmResourceMeta</h2>
<!-- backwards compatibility -->
<a id="schemacharmresourcemeta"></a>
<a id="schema_CharmResourceMeta"></a>
<a id="tocScharmresourcemeta"></a>
<a id="tocscharmresourcemeta"></a>

```json
{
  "description": "string",
  "name": "string",
  "path": "string",
  "type": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|description|string|true|none|none|
|name|string|true|none|none|
|path|string|true|none|none|
|type|string|true|none|none|

<h2 id="tocS_CharmResourceResult">CharmResourceResult</h2>
<!-- backwards compatibility -->
<a id="schemacharmresourceresult"></a>
<a id="schema_CharmResourceResult"></a>
<a id="tocScharmresourceresult"></a>
<a id="tocscharmresourceresult"></a>

```json
{
  "CharmResource": {
    "description": "string",
    "fingerprint": [
      0
    ],
    "name": "string",
    "origin": "string",
    "path": "string",
    "revision": 0,
    "size": 0,
    "type": "string"
  },
  "ErrorResult": {
    "error": {
      "code": "string",
      "info": {},
      "message": "string"
    }
  },
  "description": "string",
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "fingerprint": [
    0
  ],
  "name": "string",
  "origin": "string",
  "path": "string",
  "revision": 0,
  "size": 0,
  "type": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|CharmResource|[CharmResource](#schemacharmresource)|true|none|none|
|ErrorResult|[ErrorResult](#schemaerrorresult)|true|none|none|
|description|string|false|none|none|
|error|[Error](#schemaerror)|false|none|none|
|fingerprint|[integer]|true|none|none|
|name|string|true|none|none|
|origin|string|true|none|none|
|path|string|true|none|none|
|revision|integer|true|none|none|
|size|integer|true|none|none|
|type|string|true|none|none|

<h2 id="tocS_CharmResourcesResults">CharmResourcesResults</h2>
<!-- backwards compatibility -->
<a id="schemacharmresourcesresults"></a>
<a id="schema_CharmResourcesResults"></a>
<a id="tocScharmresourcesresults"></a>
<a id="tocscharmresourcesresults"></a>

```json
{
  "results": [
    [
      {
        "CharmResource": {
          "description": "string",
          "fingerprint": [
            0
          ],
          "name": "string",
          "origin": "string",
          "path": "string",
          "revision": 0,
          "size": 0,
          "type": "string"
        },
        "ErrorResult": {
          "error": {
            "code": "string",
            "info": {},
            "message": "string"
          }
        },
        "description": "string",
        "error": {
          "code": "string",
          "info": {},
          "message": "string"
        },
        "fingerprint": [
          0
        ],
        "name": "string",
        "origin": "string",
        "path": "string",
        "revision": 0,
        "size": 0,
        "type": "string"
      }
    ]
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[array]|true|none|none|

<h2 id="tocS_CharmStorage">CharmStorage</h2>
<!-- backwards compatibility -->
<a id="schemacharmstorage"></a>
<a id="schema_CharmStorage"></a>
<a id="tocScharmstorage"></a>
<a id="tocscharmstorage"></a>

```json
{
  "count-max": 0,
  "count-min": 0,
  "description": "string",
  "location": "string",
  "minimum-size": 0,
  "name": "string",
  "properties": [
    "string"
  ],
  "read-only": true,
  "shared": true,
  "type": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|count-max|integer|true|none|none|
|count-min|integer|true|none|none|
|description|string|true|none|none|
|location|string|false|none|none|
|minimum-size|integer|true|none|none|
|name|string|true|none|none|
|properties|[string]|false|none|none|
|read-only|boolean|true|none|none|
|shared|boolean|true|none|none|
|type|string|true|none|none|

<h2 id="tocS_CharmURL">CharmURL</h2>
<!-- backwards compatibility -->
<a id="schemacharmurl"></a>
<a id="schema_CharmURL"></a>
<a id="tocScharmurl"></a>
<a id="tocscharmurl"></a>

```json
{
  "url": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|url|string|true|none|none|

<h2 id="tocS_CharmURLAndOrigin">CharmURLAndOrigin</h2>
<!-- backwards compatibility -->
<a id="schemacharmurlandorigin"></a>
<a id="schema_CharmURLAndOrigin"></a>
<a id="tocScharmurlandorigin"></a>
<a id="tocscharmurlandorigin"></a>

```json
{
  "charm-origin": {
    "architecture": "string",
    "base": {
      "channel": "string",
      "name": "string"
    },
    "branch": "string",
    "hash": "string",
    "id": "string",
    "instance-key": "string",
    "revision": 0,
    "risk": "string",
    "source": "string",
    "track": "string",
    "type": "string"
  },
  "charm-url": "string",
  "macaroon": {}
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|charm-origin|[CharmOrigin](#schemacharmorigin)|true|none|none|
|charm-url|string|true|none|none|
|macaroon|[Macaroon](#schemamacaroon)|false|none|none|

<h2 id="tocS_CharmURLAndOrigins">CharmURLAndOrigins</h2>
<!-- backwards compatibility -->
<a id="schemacharmurlandorigins"></a>
<a id="schema_CharmURLAndOrigins"></a>
<a id="tocScharmurlandorigins"></a>
<a id="tocscharmurlandorigins"></a>

```json
{
  "entities": [
    {
      "charm-origin": {
        "architecture": "string",
        "base": {
          "channel": "string",
          "name": "string"
        },
        "branch": "string",
        "hash": "string",
        "id": "string",
        "instance-key": "string",
        "revision": 0,
        "risk": "string",
        "source": "string",
        "track": "string",
        "type": "string"
      },
      "charm-url": "string",
      "macaroon": {}
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|entities|[[CharmURLAndOrigin](#schemacharmurlandorigin)]|true|none|none|

<h2 id="tocS_CharmsList">CharmsList</h2>
<!-- backwards compatibility -->
<a id="schemacharmslist"></a>
<a id="schema_CharmsList"></a>
<a id="tocScharmslist"></a>
<a id="tocscharmslist"></a>

```json
{
  "names": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|names|[string]|true|none|none|

<h2 id="tocS_CharmsListResult">CharmsListResult</h2>
<!-- backwards compatibility -->
<a id="schemacharmslistresult"></a>
<a id="schema_CharmsListResult"></a>
<a id="tocScharmslistresult"></a>
<a id="tocscharmslistresult"></a>

```json
{
  "charm-urls": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|charm-urls|[string]|true|none|none|

<h2 id="tocS_DownloadInfoResult">DownloadInfoResult</h2>
<!-- backwards compatibility -->
<a id="schemadownloadinforesult"></a>
<a id="schema_DownloadInfoResult"></a>
<a id="tocSdownloadinforesult"></a>
<a id="tocsdownloadinforesult"></a>

```json
{
  "charm-origin": {
    "architecture": "string",
    "base": {
      "channel": "string",
      "name": "string"
    },
    "branch": "string",
    "hash": "string",
    "id": "string",
    "instance-key": "string",
    "revision": 0,
    "risk": "string",
    "source": "string",
    "track": "string",
    "type": "string"
  },
  "url": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|charm-origin|[CharmOrigin](#schemacharmorigin)|true|none|none|
|url|string|true|none|none|

<h2 id="tocS_DownloadInfoResults">DownloadInfoResults</h2>
<!-- backwards compatibility -->
<a id="schemadownloadinforesults"></a>
<a id="schema_DownloadInfoResults"></a>
<a id="tocSdownloadinforesults"></a>
<a id="tocsdownloadinforesults"></a>

```json
{
  "results": [
    {
      "charm-origin": {
        "architecture": "string",
        "base": {
          "channel": "string",
          "name": "string"
        },
        "branch": "string",
        "hash": "string",
        "id": "string",
        "instance-key": "string",
        "revision": 0,
        "risk": "string",
        "source": "string",
        "track": "string",
        "type": "string"
      },
      "url": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[DownloadInfoResult](#schemadownloadinforesult)]|true|none|none|

<h2 id="tocS_ExpressionTree">ExpressionTree</h2>
<!-- backwards compatibility -->
<a id="schemaexpressiontree"></a>
<a id="schema_ExpressionTree"></a>
<a id="tocSexpressiontree"></a>
<a id="tocsexpressiontree"></a>

```json
{
  "Expression": {}
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|Expression|object|true|none|none|

<h2 id="tocS_IsMeteredResult">IsMeteredResult</h2>
<!-- backwards compatibility -->
<a id="schemaismeteredresult"></a>
<a id="schema_IsMeteredResult"></a>
<a id="tocSismeteredresult"></a>
<a id="tocsismeteredresult"></a>

```json
{
  "metered": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|metered|boolean|true|none|none|

<h2 id="tocS_ResolveCharmWithChannel">ResolveCharmWithChannel</h2>
<!-- backwards compatibility -->
<a id="schemaresolvecharmwithchannel"></a>
<a id="schema_ResolveCharmWithChannel"></a>
<a id="tocSresolvecharmwithchannel"></a>
<a id="tocsresolvecharmwithchannel"></a>

```json
{
  "charm-origin": {
    "architecture": "string",
    "base": {
      "channel": "string",
      "name": "string"
    },
    "branch": "string",
    "hash": "string",
    "id": "string",
    "instance-key": "string",
    "revision": 0,
    "risk": "string",
    "source": "string",
    "track": "string",
    "type": "string"
  },
  "reference": "string",
  "switch-charm": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|charm-origin|[CharmOrigin](#schemacharmorigin)|true|none|none|
|reference|string|true|none|none|
|switch-charm|boolean|false|none|none|

<h2 id="tocS_ResolveCharmWithChannelResult">ResolveCharmWithChannelResult</h2>
<!-- backwards compatibility -->
<a id="schemaresolvecharmwithchannelresult"></a>
<a id="schema_ResolveCharmWithChannelResult"></a>
<a id="tocSresolvecharmwithchannelresult"></a>
<a id="tocsresolvecharmwithchannelresult"></a>

```json
{
  "charm-origin": {
    "architecture": "string",
    "base": {
      "channel": "string",
      "name": "string"
    },
    "branch": "string",
    "hash": "string",
    "id": "string",
    "instance-key": "string",
    "revision": 0,
    "risk": "string",
    "source": "string",
    "track": "string",
    "type": "string"
  },
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "supported-series": [
    "string"
  ],
  "url": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|charm-origin|[CharmOrigin](#schemacharmorigin)|true|none|none|
|error|[Error](#schemaerror)|false|none|none|
|supported-series|[string]|true|none|none|
|url|string|true|none|none|

<h2 id="tocS_ResolveCharmWithChannelResults">ResolveCharmWithChannelResults</h2>
<!-- backwards compatibility -->
<a id="schemaresolvecharmwithchannelresults"></a>
<a id="schema_ResolveCharmWithChannelResults"></a>
<a id="tocSresolvecharmwithchannelresults"></a>
<a id="tocsresolvecharmwithchannelresults"></a>

```json
{
  "Results": [
    {
      "charm-origin": {
        "architecture": "string",
        "base": {
          "channel": "string",
          "name": "string"
        },
        "branch": "string",
        "hash": "string",
        "id": "string",
        "instance-key": "string",
        "revision": 0,
        "risk": "string",
        "source": "string",
        "track": "string",
        "type": "string"
      },
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "supported-series": [
        "string"
      ],
      "url": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|Results|[[ResolveCharmWithChannelResult](#schemaresolvecharmwithchannelresult)]|true|none|none|

<h2 id="tocS_ResolveCharmsWithChannel">ResolveCharmsWithChannel</h2>
<!-- backwards compatibility -->
<a id="schemaresolvecharmswithchannel"></a>
<a id="schema_ResolveCharmsWithChannel"></a>
<a id="tocSresolvecharmswithchannel"></a>
<a id="tocsresolvecharmswithchannel"></a>

```json
{
  "macaroon": {},
  "resolve": [
    {
      "charm-origin": {
        "architecture": "string",
        "base": {
          "channel": "string",
          "name": "string"
        },
        "branch": "string",
        "hash": "string",
        "id": "string",
        "instance-key": "string",
        "revision": 0,
        "risk": "string",
        "source": "string",
        "track": "string",
        "type": "string"
      },
      "reference": "string",
      "switch-charm": true
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|macaroon|[Macaroon](#schemamacaroon)|false|none|none|
|resolve|[[ResolveCharmWithChannel](#schemaresolvecharmwithchannel)]|true|none|none|

<h2 id="tocS_AllWatcherId">AllWatcherId</h2>
<!-- backwards compatibility -->
<a id="schemaallwatcherid"></a>
<a id="schema_AllWatcherId"></a>
<a id="tocSallwatcherid"></a>
<a id="tocsallwatcherid"></a>

```json
{
  "watcher-id": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|watcher-id|string|true|none|none|

<h2 id="tocS_ApplicationOfferStatus">ApplicationOfferStatus</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationofferstatus"></a>
<a id="schema_ApplicationOfferStatus"></a>
<a id="tocSapplicationofferstatus"></a>
<a id="tocsapplicationofferstatus"></a>

```json
{
  "active-connected-count": 0,
  "application-name": "string",
  "charm": "string",
  "endpoints": {},
  "err": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "offer-name": "string",
  "total-connected-count": 0
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|active-connected-count|integer|true|none|none|
|application-name|string|true|none|none|
|charm|string|true|none|none|
|endpoints|object|true|none|none|
|» .*|[RemoteEndpoint](#schemaremoteendpoint)|false|none|none|
|err|[Error](#schemaerror)|false|none|none|
|offer-name|string|true|none|none|
|total-connected-count|integer|true|none|none|

<h2 id="tocS_ApplicationStatus">ApplicationStatus</h2>
<!-- backwards compatibility -->
<a id="schemaapplicationstatus"></a>
<a id="schema_ApplicationStatus"></a>
<a id="tocSapplicationstatus"></a>
<a id="tocsapplicationstatus"></a>

```json
{
  "base": {
    "channel": "string",
    "name": "string"
  },
  "can-upgrade-to": "string",
  "charm": "string",
  "charm-channel": "string",
  "charm-profile": "string",
  "charm-version": "string",
  "endpoint-bindings": {},
  "err": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "exposed": true,
  "exposed-endpoints": {},
  "int": 0,
  "life": "string",
  "meter-statuses": {},
  "provider-id": "string",
  "public-address": "string",
  "relations": {},
  "status": {
    "data": {},
    "err": {
      "code": "string",
      "info": {},
      "message": "string"
    },
    "info": "string",
    "kind": "string",
    "life": "string",
    "since": "2019-08-24T14:15:22Z",
    "status": "string",
    "version": "string"
  },
  "subordinate-to": [
    "string"
  ],
  "units": {},
  "workload-version": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|base|[Base](#schemabase)|true|none|none|
|can-upgrade-to|string|true|none|none|
|charm|string|true|none|none|
|charm-channel|string|false|none|none|
|charm-profile|string|true|none|none|
|charm-version|string|true|none|none|
|endpoint-bindings|object|true|none|none|
|» .*|string|false|none|none|
|err|[Error](#schemaerror)|false|none|none|
|exposed|boolean|true|none|none|
|exposed-endpoints|object|false|none|none|
|» .*|[ExposedEndpoint](#schemaexposedendpoint)|false|none|none|
|int|integer|false|none|none|
|life|string|true|none|none|
|meter-statuses|object|true|none|none|
|» .*|[MeterStatus](#schemameterstatus)|false|none|none|
|provider-id|string|false|none|none|
|public-address|string|true|none|none|
|relations|object|true|none|none|
|» .*|[string]|false|none|none|
|status|[DetailedStatus](#schemadetailedstatus)|true|none|none|
|subordinate-to|[string]|true|none|none|
|units|object|true|none|none|
|» .*|[UnitStatus](#schemaunitstatus)|false|none|none|
|workload-version|string|true|none|none|

<h2 id="tocS_Binary">Binary</h2>
<!-- backwards compatibility -->
<a id="schemabinary"></a>
<a id="schema_Binary"></a>
<a id="tocSbinary"></a>
<a id="tocsbinary"></a>

```json
{
  "Arch": "string",
  "Build": 0,
  "Major": 0,
  "Minor": 0,
  "Number": {
    "Build": 0,
    "Major": 0,
    "Minor": 0,
    "Patch": 0,
    "Tag": "string"
  },
  "Patch": 0,
  "Release": "string",
  "Tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|Arch|string|true|none|none|
|Build|integer|true|none|none|
|Major|integer|true|none|none|
|Minor|integer|true|none|none|
|Number|[Number](#schemanumber)|true|none|none|
|Patch|integer|true|none|none|
|Release|string|true|none|none|
|Tag|string|true|none|none|

<h2 id="tocS_BranchStatus">BranchStatus</h2>
<!-- backwards compatibility -->
<a id="schemabranchstatus"></a>
<a id="schema_BranchStatus"></a>
<a id="tocSbranchstatus"></a>
<a id="tocsbranchstatus"></a>

```json
{
  "assigned-units": {},
  "created": 0,
  "created-by": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|assigned-units|object|true|none|none|
|» .*|[string]|false|none|none|
|created|integer|true|none|none|
|created-by|string|true|none|none|

<h2 id="tocS_DetailedStatus">DetailedStatus</h2>
<!-- backwards compatibility -->
<a id="schemadetailedstatus"></a>
<a id="schema_DetailedStatus"></a>
<a id="tocSdetailedstatus"></a>
<a id="tocsdetailedstatus"></a>

```json
{
  "data": {},
  "err": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "info": "string",
  "kind": "string",
  "life": "string",
  "since": "2019-08-24T14:15:22Z",
  "status": "string",
  "version": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|data|object|true|none|none|
|» .*|object|false|none|none|
|err|[Error](#schemaerror)|false|none|none|
|info|string|true|none|none|
|kind|string|true|none|none|
|life|string|true|none|none|
|since|string(date-time)|true|none|none|
|status|string|true|none|none|
|version|string|true|none|none|

<h2 id="tocS_EndpointStatus">EndpointStatus</h2>
<!-- backwards compatibility -->
<a id="schemaendpointstatus"></a>
<a id="schema_EndpointStatus"></a>
<a id="tocSendpointstatus"></a>
<a id="tocsendpointstatus"></a>

```json
{
  "application": "string",
  "name": "string",
  "role": "string",
  "subordinate": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|application|string|true|none|none|
|name|string|true|none|none|
|role|string|true|none|none|
|subordinate|boolean|true|none|none|

<h2 id="tocS_FindToolsParams">FindToolsParams</h2>
<!-- backwards compatibility -->
<a id="schemafindtoolsparams"></a>
<a id="schema_FindToolsParams"></a>
<a id="tocSfindtoolsparams"></a>
<a id="tocsfindtoolsparams"></a>

```json
{
  "agentstream": "string",
  "arch": "string",
  "major": 0,
  "number": {
    "Build": 0,
    "Major": 0,
    "Minor": 0,
    "Patch": 0,
    "Tag": "string"
  },
  "os-type": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|agentstream|string|true|none|none|
|arch|string|true|none|none|
|major|integer|true|none|none|
|number|[Number](#schemanumber)|true|none|none|
|os-type|string|true|none|none|

<h2 id="tocS_FindToolsResult">FindToolsResult</h2>
<!-- backwards compatibility -->
<a id="schemafindtoolsresult"></a>
<a id="schema_FindToolsResult"></a>
<a id="tocSfindtoolsresult"></a>
<a id="tocsfindtoolsresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "list": [
    {
      "sha256": "string",
      "size": 0,
      "url": "string",
      "version": {
        "Arch": "string",
        "Build": 0,
        "Major": 0,
        "Minor": 0,
        "Number": {
          "Build": 0,
          "Major": 0,
          "Minor": 0,
          "Patch": 0,
          "Tag": "string"
        },
        "Patch": 0,
        "Release": "string",
        "Tag": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|list|[[Tools](#schematools)]|true|none|none|

<h2 id="tocS_FullStatus">FullStatus</h2>
<!-- backwards compatibility -->
<a id="schemafullstatus"></a>
<a id="schema_FullStatus"></a>
<a id="tocSfullstatus"></a>
<a id="tocsfullstatus"></a>

```json
{
  "applications": {},
  "branches": {},
  "controller-timestamp": "2019-08-24T14:15:22Z",
  "machines": {},
  "model": {
    "available-version": "string",
    "cloud-tag": "string",
    "meter-status": {
      "color": "string",
      "message": "string"
    },
    "model-status": {
      "data": {},
      "err": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "info": "string",
      "kind": "string",
      "life": "string",
      "since": "2019-08-24T14:15:22Z",
      "status": "string",
      "version": "string"
    },
    "name": "string",
    "region": "string",
    "sla": "string",
    "type": "string",
    "version": "string"
  },
  "offers": {},
  "relations": [
    {
      "endpoints": [
        {
          "application": "string",
          "name": "string",
          "role": "string",
          "subordinate": true
        }
      ],
      "id": 0,
      "interface": "string",
      "key": "string",
      "scope": "string",
      "status": {
        "data": {},
        "err": {
          "code": "string",
          "info": {},
          "message": "string"
        },
        "info": "string",
        "kind": "string",
        "life": "string",
        "since": "2019-08-24T14:15:22Z",
        "status": "string",
        "version": "string"
      }
    }
  ],
  "remote-applications": {}
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|applications|object|true|none|none|
|» .*|[ApplicationStatus](#schemaapplicationstatus)|false|none|none|
|branches|object|true|none|none|
|» .*|[BranchStatus](#schemabranchstatus)|false|none|none|
|controller-timestamp|string(date-time)|true|none|none|
|machines|object|true|none|none|
|» .*|[MachineStatus](#schemamachinestatus)|false|none|none|
|model|[ModelStatusInfo](#schemamodelstatusinfo)|true|none|none|
|offers|object|true|none|none|
|» .*|[ApplicationOfferStatus](#schemaapplicationofferstatus)|false|none|none|
|relations|[[RelationStatus](#schemarelationstatus)]|true|none|none|
|remote-applications|object|true|none|none|
|» .*|[RemoteApplicationStatus](#schemaremoteapplicationstatus)|false|none|none|

<h2 id="tocS_History">History</h2>
<!-- backwards compatibility -->
<a id="schemahistory"></a>
<a id="schema_History"></a>
<a id="tocShistory"></a>
<a id="tocshistory"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "statuses": [
    {
      "data": {},
      "err": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "info": "string",
      "kind": "string",
      "life": "string",
      "since": "2019-08-24T14:15:22Z",
      "status": "string",
      "version": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|statuses|[[DetailedStatus](#schemadetailedstatus)]|true|none|none|

<h2 id="tocS_LXDProfile">LXDProfile</h2>
<!-- backwards compatibility -->
<a id="schemalxdprofile"></a>
<a id="schema_LXDProfile"></a>
<a id="tocSlxdprofile"></a>
<a id="tocslxdprofile"></a>

```json
{
  "config": {},
  "description": "string",
  "devices": {}
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|config|object|true|none|none|
|» .*|string|false|none|none|
|description|string|true|none|none|
|devices|object|true|none|none|
|» .*|object|false|none|none|
|»» .*|string|false|none|none|

<h2 id="tocS_MachineStatus">MachineStatus</h2>
<!-- backwards compatibility -->
<a id="schemamachinestatus"></a>
<a id="schema_MachineStatus"></a>
<a id="tocSmachinestatus"></a>
<a id="tocsmachinestatus"></a>

```json
{
  "agent-status": {
    "data": {},
    "err": {
      "code": "string",
      "info": {},
      "message": "string"
    },
    "info": "string",
    "kind": "string",
    "life": "string",
    "since": "2019-08-24T14:15:22Z",
    "status": "string",
    "version": "string"
  },
  "base": {
    "channel": "string",
    "name": "string"
  },
  "constraints": "string",
  "containers": {},
  "display-name": "string",
  "dns-name": "string",
  "hardware": "string",
  "has-vote": true,
  "hostname": "string",
  "id": "string",
  "instance-id": "string",
  "instance-status": {
    "data": {},
    "err": {
      "code": "string",
      "info": {},
      "message": "string"
    },
    "info": "string",
    "kind": "string",
    "life": "string",
    "since": "2019-08-24T14:15:22Z",
    "status": "string",
    "version": "string"
  },
  "ip-addresses": [
    "string"
  ],
  "jobs": [
    "string"
  ],
  "lxd-profiles": {},
  "modification-status": {
    "data": {},
    "err": {
      "code": "string",
      "info": {},
      "message": "string"
    },
    "info": "string",
    "kind": "string",
    "life": "string",
    "since": "2019-08-24T14:15:22Z",
    "status": "string",
    "version": "string"
  },
  "network-interfaces": {},
  "primary-controller-machine": true,
  "wants-vote": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|agent-status|[DetailedStatus](#schemadetailedstatus)|true|none|none|
|base|[Base](#schemabase)|true|none|none|
|constraints|string|true|none|none|
|containers|object|true|none|none|
|» .*|[MachineStatus](#schemamachinestatus)|false|none|none|
|display-name|string|true|none|none|
|dns-name|string|true|none|none|
|hardware|string|true|none|none|
|has-vote|boolean|true|none|none|
|hostname|string|false|none|none|
|id|string|true|none|none|
|instance-id|string|true|none|none|
|instance-status|[DetailedStatus](#schemadetailedstatus)|true|none|none|
|ip-addresses|[string]|false|none|none|
|jobs|[string]|true|none|none|
|lxd-profiles|object|false|none|none|
|» .*|[LXDProfile](#schemalxdprofile)|false|none|none|
|modification-status|[DetailedStatus](#schemadetailedstatus)|true|none|none|
|network-interfaces|object|false|none|none|
|» .*|[NetworkInterface](#schemanetworkinterface)|false|none|none|
|primary-controller-machine|boolean|false|none|none|
|wants-vote|boolean|true|none|none|

<h2 id="tocS_MeterStatus">MeterStatus</h2>
<!-- backwards compatibility -->
<a id="schemameterstatus"></a>
<a id="schema_MeterStatus"></a>
<a id="tocSmeterstatus"></a>
<a id="tocsmeterstatus"></a>

```json
{
  "color": "string",
  "message": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|color|string|true|none|none|
|message|string|true|none|none|

<h2 id="tocS_ModelStatusInfo">ModelStatusInfo</h2>
<!-- backwards compatibility -->
<a id="schemamodelstatusinfo"></a>
<a id="schema_ModelStatusInfo"></a>
<a id="tocSmodelstatusinfo"></a>
<a id="tocsmodelstatusinfo"></a>

```json
{
  "available-version": "string",
  "cloud-tag": "string",
  "meter-status": {
    "color": "string",
    "message": "string"
  },
  "model-status": {
    "data": {},
    "err": {
      "code": "string",
      "info": {},
      "message": "string"
    },
    "info": "string",
    "kind": "string",
    "life": "string",
    "since": "2019-08-24T14:15:22Z",
    "status": "string",
    "version": "string"
  },
  "name": "string",
  "region": "string",
  "sla": "string",
  "type": "string",
  "version": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|available-version|string|true|none|none|
|cloud-tag|string|true|none|none|
|meter-status|[MeterStatus](#schemameterstatus)|true|none|none|
|model-status|[DetailedStatus](#schemadetailedstatus)|true|none|none|
|name|string|true|none|none|
|region|string|false|none|none|
|sla|string|true|none|none|
|type|string|true|none|none|
|version|string|true|none|none|

<h2 id="tocS_NetworkInterface">NetworkInterface</h2>
<!-- backwards compatibility -->
<a id="schemanetworkinterface"></a>
<a id="schema_NetworkInterface"></a>
<a id="tocSnetworkinterface"></a>
<a id="tocsnetworkinterface"></a>

```json
{
  "dns-nameservers": [
    "string"
  ],
  "gateway": "string",
  "ip-addresses": [
    "string"
  ],
  "is-up": true,
  "mac-address": "string",
  "space": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|dns-nameservers|[string]|false|none|none|
|gateway|string|false|none|none|
|ip-addresses|[string]|true|none|none|
|is-up|boolean|true|none|none|
|mac-address|string|true|none|none|
|space|string|false|none|none|

<h2 id="tocS_RelationStatus">RelationStatus</h2>
<!-- backwards compatibility -->
<a id="schemarelationstatus"></a>
<a id="schema_RelationStatus"></a>
<a id="tocSrelationstatus"></a>
<a id="tocsrelationstatus"></a>

```json
{
  "endpoints": [
    {
      "application": "string",
      "name": "string",
      "role": "string",
      "subordinate": true
    }
  ],
  "id": 0,
  "interface": "string",
  "key": "string",
  "scope": "string",
  "status": {
    "data": {},
    "err": {
      "code": "string",
      "info": {},
      "message": "string"
    },
    "info": "string",
    "kind": "string",
    "life": "string",
    "since": "2019-08-24T14:15:22Z",
    "status": "string",
    "version": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|endpoints|[[EndpointStatus](#schemaendpointstatus)]|true|none|none|
|id|integer|true|none|none|
|interface|string|true|none|none|
|key|string|true|none|none|
|scope|string|true|none|none|
|status|[DetailedStatus](#schemadetailedstatus)|true|none|none|

<h2 id="tocS_RemoteApplicationStatus">RemoteApplicationStatus</h2>
<!-- backwards compatibility -->
<a id="schemaremoteapplicationstatus"></a>
<a id="schema_RemoteApplicationStatus"></a>
<a id="tocSremoteapplicationstatus"></a>
<a id="tocsremoteapplicationstatus"></a>

```json
{
  "endpoints": [
    {
      "interface": "string",
      "limit": 0,
      "name": "string",
      "role": "string"
    }
  ],
  "err": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "life": "string",
  "offer-name": "string",
  "offer-url": "string",
  "relations": {},
  "status": {
    "data": {},
    "err": {
      "code": "string",
      "info": {},
      "message": "string"
    },
    "info": "string",
    "kind": "string",
    "life": "string",
    "since": "2019-08-24T14:15:22Z",
    "status": "string",
    "version": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|endpoints|[[RemoteEndpoint](#schemaremoteendpoint)]|true|none|none|
|err|[Error](#schemaerror)|false|none|none|
|life|string|true|none|none|
|offer-name|string|true|none|none|
|offer-url|string|true|none|none|
|relations|object|true|none|none|
|» .*|[string]|false|none|none|
|status|[DetailedStatus](#schemadetailedstatus)|true|none|none|

<h2 id="tocS_StatusHistoryFilter">StatusHistoryFilter</h2>
<!-- backwards compatibility -->
<a id="schemastatushistoryfilter"></a>
<a id="schema_StatusHistoryFilter"></a>
<a id="tocSstatushistoryfilter"></a>
<a id="tocsstatushistoryfilter"></a>

```json
{
  "date": "2019-08-24T14:15:22Z",
  "delta": 0,
  "exclude": [
    "string"
  ],
  "size": 0
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|date|string(date-time)|true|none|none|
|delta|integer|true|none|none|
|exclude|[string]|true|none|none|
|size|integer|true|none|none|

<h2 id="tocS_StatusHistoryRequest">StatusHistoryRequest</h2>
<!-- backwards compatibility -->
<a id="schemastatushistoryrequest"></a>
<a id="schema_StatusHistoryRequest"></a>
<a id="tocSstatushistoryrequest"></a>
<a id="tocsstatushistoryrequest"></a>

```json
{
  "filter": {
    "date": "2019-08-24T14:15:22Z",
    "delta": 0,
    "exclude": [
      "string"
    ],
    "size": 0
  },
  "historyKind": "string",
  "size": 0,
  "tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|filter|[StatusHistoryFilter](#schemastatushistoryfilter)|true|none|none|
|historyKind|string|true|none|none|
|size|integer|true|none|none|
|tag|string|true|none|none|

<h2 id="tocS_StatusHistoryRequests">StatusHistoryRequests</h2>
<!-- backwards compatibility -->
<a id="schemastatushistoryrequests"></a>
<a id="schema_StatusHistoryRequests"></a>
<a id="tocSstatushistoryrequests"></a>
<a id="tocsstatushistoryrequests"></a>

```json
{
  "requests": [
    {
      "filter": {
        "date": "2019-08-24T14:15:22Z",
        "delta": 0,
        "exclude": [
          "string"
        ],
        "size": 0
      },
      "historyKind": "string",
      "size": 0,
      "tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|requests|[[StatusHistoryRequest](#schemastatushistoryrequest)]|true|none|none|

<h2 id="tocS_StatusHistoryResult">StatusHistoryResult</h2>
<!-- backwards compatibility -->
<a id="schemastatushistoryresult"></a>
<a id="schema_StatusHistoryResult"></a>
<a id="tocSstatushistoryresult"></a>
<a id="tocsstatushistoryresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "history": {
    "error": {
      "code": "string",
      "info": {},
      "message": "string"
    },
    "statuses": [
      {
        "data": {},
        "err": {
          "code": "string",
          "info": {},
          "message": "string"
        },
        "info": "string",
        "kind": "string",
        "life": "string",
        "since": "2019-08-24T14:15:22Z",
        "status": "string",
        "version": "string"
      }
    ]
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|history|[History](#schemahistory)|true|none|none|

<h2 id="tocS_StatusHistoryResults">StatusHistoryResults</h2>
<!-- backwards compatibility -->
<a id="schemastatushistoryresults"></a>
<a id="schema_StatusHistoryResults"></a>
<a id="tocSstatushistoryresults"></a>
<a id="tocsstatushistoryresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "history": {
        "error": {
          "code": "string",
          "info": {},
          "message": "string"
        },
        "statuses": [
          {
            "data": {},
            "err": {
              "code": "string",
              "info": {},
              "message": "string"
            },
            "info": "string",
            "kind": "string",
            "life": "string",
            "since": "2019-08-24T14:15:22Z",
            "status": "string",
            "version": "string"
          }
        ]
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[StatusHistoryResult](#schemastatushistoryresult)]|true|none|none|

<h2 id="tocS_StatusParams">StatusParams</h2>
<!-- backwards compatibility -->
<a id="schemastatusparams"></a>
<a id="schema_StatusParams"></a>
<a id="tocSstatusparams"></a>
<a id="tocsstatusparams"></a>

```json
{
  "patterns": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|patterns|[string]|true|none|none|

<h2 id="tocS_Tools">Tools</h2>
<!-- backwards compatibility -->
<a id="schematools"></a>
<a id="schema_Tools"></a>
<a id="tocStools"></a>
<a id="tocstools"></a>

```json
{
  "sha256": "string",
  "size": 0,
  "url": "string",
  "version": {
    "Arch": "string",
    "Build": 0,
    "Major": 0,
    "Minor": 0,
    "Number": {
      "Build": 0,
      "Major": 0,
      "Minor": 0,
      "Patch": 0,
      "Tag": "string"
    },
    "Patch": 0,
    "Release": "string",
    "Tag": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|sha256|string|false|none|none|
|size|integer|true|none|none|
|url|string|true|none|none|
|version|[Binary](#schemabinary)|true|none|none|

<h2 id="tocS_UnitStatus">UnitStatus</h2>
<!-- backwards compatibility -->
<a id="schemaunitstatus"></a>
<a id="schema_UnitStatus"></a>
<a id="tocSunitstatus"></a>
<a id="tocsunitstatus"></a>

```json
{
  "address": "string",
  "agent-status": {
    "data": {},
    "err": {
      "code": "string",
      "info": {},
      "message": "string"
    },
    "info": "string",
    "kind": "string",
    "life": "string",
    "since": "2019-08-24T14:15:22Z",
    "status": "string",
    "version": "string"
  },
  "charm": "string",
  "leader": true,
  "machine": "string",
  "opened-ports": [
    "string"
  ],
  "provider-id": "string",
  "public-address": "string",
  "subordinates": {},
  "workload-status": {
    "data": {},
    "err": {
      "code": "string",
      "info": {},
      "message": "string"
    },
    "info": "string",
    "kind": "string",
    "life": "string",
    "since": "2019-08-24T14:15:22Z",
    "status": "string",
    "version": "string"
  },
  "workload-version": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|address|string|false|none|none|
|agent-status|[DetailedStatus](#schemadetailedstatus)|true|none|none|
|charm|string|true|none|none|
|leader|boolean|false|none|none|
|machine|string|true|none|none|
|opened-ports|[string]|true|none|none|
|provider-id|string|false|none|none|
|public-address|string|true|none|none|
|subordinates|object|true|none|none|
|» .*|[UnitStatus](#schemaunitstatus)|false|none|none|
|workload-status|[DetailedStatus](#schemadetailedstatus)|true|none|none|
|workload-version|string|true|none|none|

<h2 id="tocS_AddCloudArgs">AddCloudArgs</h2>
<!-- backwards compatibility -->
<a id="schemaaddcloudargs"></a>
<a id="schema_AddCloudArgs"></a>
<a id="tocSaddcloudargs"></a>
<a id="tocsaddcloudargs"></a>

```json
{
  "cloud": {
    "auth-types": [
      "string"
    ],
    "ca-certificates": [
      "string"
    ],
    "config": {},
    "endpoint": "string",
    "host-cloud-region": "string",
    "identity-endpoint": "string",
    "is-controller-cloud": true,
    "region-config": {},
    "regions": [
      {
        "endpoint": "string",
        "identity-endpoint": "string",
        "name": "string",
        "storage-endpoint": "string"
      }
    ],
    "skip-tls-verify": true,
    "storage-endpoint": "string",
    "type": "string"
  },
  "force": true,
  "name": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|cloud|[Cloud](#schemacloud)|true|none|none|
|force|boolean|false|none|none|
|name|string|true|none|none|

<h2 id="tocS_Cloud">Cloud</h2>
<!-- backwards compatibility -->
<a id="schemacloud"></a>
<a id="schema_Cloud"></a>
<a id="tocScloud"></a>
<a id="tocscloud"></a>

```json
{
  "auth-types": [
    "string"
  ],
  "ca-certificates": [
    "string"
  ],
  "config": {},
  "endpoint": "string",
  "host-cloud-region": "string",
  "identity-endpoint": "string",
  "is-controller-cloud": true,
  "region-config": {},
  "regions": [
    {
      "endpoint": "string",
      "identity-endpoint": "string",
      "name": "string",
      "storage-endpoint": "string"
    }
  ],
  "skip-tls-verify": true,
  "storage-endpoint": "string",
  "type": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|auth-types|[string]|false|none|none|
|ca-certificates|[string]|false|none|none|
|config|object|false|none|none|
|» .*|object|false|none|none|
|endpoint|string|false|none|none|
|host-cloud-region|string|false|none|none|
|identity-endpoint|string|false|none|none|
|is-controller-cloud|boolean|false|none|none|
|region-config|object|false|none|none|
|» .*|object|false|none|none|
|»» .*|object|false|none|none|
|regions|[[CloudRegion](#schemacloudregion)]|false|none|none|
|skip-tls-verify|boolean|false|none|none|
|storage-endpoint|string|false|none|none|
|type|string|true|none|none|

<h2 id="tocS_CloudCredential">CloudCredential</h2>
<!-- backwards compatibility -->
<a id="schemacloudcredential"></a>
<a id="schema_CloudCredential"></a>
<a id="tocScloudcredential"></a>
<a id="tocscloudcredential"></a>

```json
{
  "attrs": {},
  "auth-type": "string",
  "redacted": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|attrs|object|false|none|none|
|» .*|string|false|none|none|
|auth-type|string|true|none|none|
|redacted|[string]|false|none|none|

<h2 id="tocS_CloudCredentialArg">CloudCredentialArg</h2>
<!-- backwards compatibility -->
<a id="schemacloudcredentialarg"></a>
<a id="schema_CloudCredentialArg"></a>
<a id="tocScloudcredentialarg"></a>
<a id="tocscloudcredentialarg"></a>

```json
{
  "cloud-name": "string",
  "credential-name": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|cloud-name|string|true|none|none|
|credential-name|string|true|none|none|

<h2 id="tocS_CloudCredentialArgs">CloudCredentialArgs</h2>
<!-- backwards compatibility -->
<a id="schemacloudcredentialargs"></a>
<a id="schema_CloudCredentialArgs"></a>
<a id="tocScloudcredentialargs"></a>
<a id="tocscloudcredentialargs"></a>

```json
{
  "credentials": [
    {
      "cloud-name": "string",
      "credential-name": "string"
    }
  ],
  "include-secrets": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|credentials|[[CloudCredentialArg](#schemacloudcredentialarg)]|false|none|none|
|include-secrets|boolean|true|none|none|

<h2 id="tocS_CloudCredentialResult">CloudCredentialResult</h2>
<!-- backwards compatibility -->
<a id="schemacloudcredentialresult"></a>
<a id="schema_CloudCredentialResult"></a>
<a id="tocScloudcredentialresult"></a>
<a id="tocscloudcredentialresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": {
    "attrs": {},
    "auth-type": "string",
    "redacted": [
      "string"
    ]
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|result|[CloudCredential](#schemacloudcredential)|false|none|none|

<h2 id="tocS_CloudCredentialResults">CloudCredentialResults</h2>
<!-- backwards compatibility -->
<a id="schemacloudcredentialresults"></a>
<a id="schema_CloudCredentialResults"></a>
<a id="tocScloudcredentialresults"></a>
<a id="tocscloudcredentialresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "attrs": {},
        "auth-type": "string",
        "redacted": [
          "string"
        ]
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[CloudCredentialResult](#schemacloudcredentialresult)]|false|none|none|

<h2 id="tocS_CloudDetails">CloudDetails</h2>
<!-- backwards compatibility -->
<a id="schemaclouddetails"></a>
<a id="schema_CloudDetails"></a>
<a id="tocSclouddetails"></a>
<a id="tocsclouddetails"></a>

```json
{
  "auth-types": [
    "string"
  ],
  "endpoint": "string",
  "identity-endpoint": "string",
  "regions": [
    {
      "endpoint": "string",
      "identity-endpoint": "string",
      "name": "string",
      "storage-endpoint": "string"
    }
  ],
  "storage-endpoint": "string",
  "type": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|auth-types|[string]|false|none|none|
|endpoint|string|false|none|none|
|identity-endpoint|string|false|none|none|
|regions|[[CloudRegion](#schemacloudregion)]|false|none|none|
|storage-endpoint|string|false|none|none|
|type|string|true|none|none|

<h2 id="tocS_CloudInfo">CloudInfo</h2>
<!-- backwards compatibility -->
<a id="schemacloudinfo"></a>
<a id="schema_CloudInfo"></a>
<a id="tocScloudinfo"></a>
<a id="tocscloudinfo"></a>

```json
{
  "CloudDetails": {
    "auth-types": [
      "string"
    ],
    "endpoint": "string",
    "identity-endpoint": "string",
    "regions": [
      {
        "endpoint": "string",
        "identity-endpoint": "string",
        "name": "string",
        "storage-endpoint": "string"
      }
    ],
    "storage-endpoint": "string",
    "type": "string"
  },
  "users": [
    {
      "access": "string",
      "display-name": "string",
      "user": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|CloudDetails|[CloudDetails](#schemaclouddetails)|true|none|none|
|users|[[CloudUserInfo](#schemaclouduserinfo)]|true|none|none|

<h2 id="tocS_CloudInfoResult">CloudInfoResult</h2>
<!-- backwards compatibility -->
<a id="schemacloudinforesult"></a>
<a id="schema_CloudInfoResult"></a>
<a id="tocScloudinforesult"></a>
<a id="tocscloudinforesult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": {
    "CloudDetails": {
      "auth-types": [
        "string"
      ],
      "endpoint": "string",
      "identity-endpoint": "string",
      "regions": [
        {
          "endpoint": "string",
          "identity-endpoint": "string",
          "name": "string",
          "storage-endpoint": "string"
        }
      ],
      "storage-endpoint": "string",
      "type": "string"
    },
    "users": [
      {
        "access": "string",
        "display-name": "string",
        "user": "string"
      }
    ]
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|result|[CloudInfo](#schemacloudinfo)|false|none|none|

<h2 id="tocS_CloudInfoResults">CloudInfoResults</h2>
<!-- backwards compatibility -->
<a id="schemacloudinforesults"></a>
<a id="schema_CloudInfoResults"></a>
<a id="tocScloudinforesults"></a>
<a id="tocscloudinforesults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "CloudDetails": {
          "auth-types": [
            "string"
          ],
          "endpoint": "string",
          "identity-endpoint": "string",
          "regions": [
            {
              "endpoint": "string",
              "identity-endpoint": "string",
              "name": "string",
              "storage-endpoint": "string"
            }
          ],
          "storage-endpoint": "string",
          "type": "string"
        },
        "users": [
          {
            "access": "string",
            "display-name": "string",
            "user": "string"
          }
        ]
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[CloudInfoResult](#schemacloudinforesult)]|true|none|none|

<h2 id="tocS_CloudInstanceTypesConstraint">CloudInstanceTypesConstraint</h2>
<!-- backwards compatibility -->
<a id="schemacloudinstancetypesconstraint"></a>
<a id="schema_CloudInstanceTypesConstraint"></a>
<a id="tocScloudinstancetypesconstraint"></a>
<a id="tocscloudinstancetypesconstraint"></a>

```json
{
  "cloud-tag": "string",
  "constraints": {
    "allocate-public-ip": true,
    "arch": "string",
    "container": "string",
    "cores": 0,
    "cpu-power": 0,
    "image-id": "string",
    "instance-role": "string",
    "instance-type": "string",
    "mem": 0,
    "root-disk": 0,
    "root-disk-source": "string",
    "spaces": [
      "string"
    ],
    "tags": [
      "string"
    ],
    "virt-type": "string",
    "zones": [
      "string"
    ]
  },
  "region": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|cloud-tag|string|true|none|none|
|constraints|[Value](#schemavalue)|false|none|none|
|region|string|true|none|none|

<h2 id="tocS_CloudInstanceTypesConstraints">CloudInstanceTypesConstraints</h2>
<!-- backwards compatibility -->
<a id="schemacloudinstancetypesconstraints"></a>
<a id="schema_CloudInstanceTypesConstraints"></a>
<a id="tocScloudinstancetypesconstraints"></a>
<a id="tocscloudinstancetypesconstraints"></a>

```json
{
  "constraints": [
    {
      "cloud-tag": "string",
      "constraints": {
        "allocate-public-ip": true,
        "arch": "string",
        "container": "string",
        "cores": 0,
        "cpu-power": 0,
        "image-id": "string",
        "instance-role": "string",
        "instance-type": "string",
        "mem": 0,
        "root-disk": 0,
        "root-disk-source": "string",
        "spaces": [
          "string"
        ],
        "tags": [
          "string"
        ],
        "virt-type": "string",
        "zones": [
          "string"
        ]
      },
      "region": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|constraints|[[CloudInstanceTypesConstraint](#schemacloudinstancetypesconstraint)]|true|none|none|

<h2 id="tocS_CloudRegion">CloudRegion</h2>
<!-- backwards compatibility -->
<a id="schemacloudregion"></a>
<a id="schema_CloudRegion"></a>
<a id="tocScloudregion"></a>
<a id="tocscloudregion"></a>

```json
{
  "endpoint": "string",
  "identity-endpoint": "string",
  "name": "string",
  "storage-endpoint": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|endpoint|string|false|none|none|
|identity-endpoint|string|false|none|none|
|name|string|true|none|none|
|storage-endpoint|string|false|none|none|

<h2 id="tocS_CloudResult">CloudResult</h2>
<!-- backwards compatibility -->
<a id="schemacloudresult"></a>
<a id="schema_CloudResult"></a>
<a id="tocScloudresult"></a>
<a id="tocscloudresult"></a>

```json
{
  "cloud": {
    "auth-types": [
      "string"
    ],
    "ca-certificates": [
      "string"
    ],
    "config": {},
    "endpoint": "string",
    "host-cloud-region": "string",
    "identity-endpoint": "string",
    "is-controller-cloud": true,
    "region-config": {},
    "regions": [
      {
        "endpoint": "string",
        "identity-endpoint": "string",
        "name": "string",
        "storage-endpoint": "string"
      }
    ],
    "skip-tls-verify": true,
    "storage-endpoint": "string",
    "type": "string"
  },
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|cloud|[Cloud](#schemacloud)|false|none|none|
|error|[Error](#schemaerror)|false|none|none|

<h2 id="tocS_CloudResults">CloudResults</h2>
<!-- backwards compatibility -->
<a id="schemacloudresults"></a>
<a id="schema_CloudResults"></a>
<a id="tocScloudresults"></a>
<a id="tocscloudresults"></a>

```json
{
  "results": [
    {
      "cloud": {
        "auth-types": [
          "string"
        ],
        "ca-certificates": [
          "string"
        ],
        "config": {},
        "endpoint": "string",
        "host-cloud-region": "string",
        "identity-endpoint": "string",
        "is-controller-cloud": true,
        "region-config": {},
        "regions": [
          {
            "endpoint": "string",
            "identity-endpoint": "string",
            "name": "string",
            "storage-endpoint": "string"
          }
        ],
        "skip-tls-verify": true,
        "storage-endpoint": "string",
        "type": "string"
      },
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[CloudResult](#schemacloudresult)]|false|none|none|

<h2 id="tocS_CloudUserInfo">CloudUserInfo</h2>
<!-- backwards compatibility -->
<a id="schemaclouduserinfo"></a>
<a id="schema_CloudUserInfo"></a>
<a id="tocSclouduserinfo"></a>
<a id="tocsclouduserinfo"></a>

```json
{
  "access": "string",
  "display-name": "string",
  "user": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|access|string|true|none|none|
|display-name|string|true|none|none|
|user|string|true|none|none|

<h2 id="tocS_CloudsResult">CloudsResult</h2>
<!-- backwards compatibility -->
<a id="schemacloudsresult"></a>
<a id="schema_CloudsResult"></a>
<a id="tocScloudsresult"></a>
<a id="tocscloudsresult"></a>

```json
{
  "clouds": {}
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|clouds|object|false|none|none|
|» .*|[Cloud](#schemacloud)|false|none|none|

<h2 id="tocS_ControllerCredentialInfo">ControllerCredentialInfo</h2>
<!-- backwards compatibility -->
<a id="schemacontrollercredentialinfo"></a>
<a id="schema_ControllerCredentialInfo"></a>
<a id="tocScontrollercredentialinfo"></a>
<a id="tocscontrollercredentialinfo"></a>

```json
{
  "content": {
    "attrs": {},
    "auth-type": "string",
    "cloud": "string",
    "name": "string",
    "valid": true
  },
  "models": [
    {
      "access": "string",
      "model": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|content|[CredentialContent](#schemacredentialcontent)|false|none|none|
|models|[[ModelAccess](#schemamodelaccess)]|false|none|none|

<h2 id="tocS_CredentialContent">CredentialContent</h2>
<!-- backwards compatibility -->
<a id="schemacredentialcontent"></a>
<a id="schema_CredentialContent"></a>
<a id="tocScredentialcontent"></a>
<a id="tocscredentialcontent"></a>

```json
{
  "attrs": {},
  "auth-type": "string",
  "cloud": "string",
  "name": "string",
  "valid": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|attrs|object|false|none|none|
|» .*|string|false|none|none|
|auth-type|string|true|none|none|
|cloud|string|true|none|none|
|name|string|true|none|none|
|valid|boolean|false|none|none|

<h2 id="tocS_CredentialContentResult">CredentialContentResult</h2>
<!-- backwards compatibility -->
<a id="schemacredentialcontentresult"></a>
<a id="schema_CredentialContentResult"></a>
<a id="tocScredentialcontentresult"></a>
<a id="tocscredentialcontentresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": {
    "content": {
      "attrs": {},
      "auth-type": "string",
      "cloud": "string",
      "name": "string",
      "valid": true
    },
    "models": [
      {
        "access": "string",
        "model": "string"
      }
    ]
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|result|[ControllerCredentialInfo](#schemacontrollercredentialinfo)|false|none|none|

<h2 id="tocS_CredentialContentResults">CredentialContentResults</h2>
<!-- backwards compatibility -->
<a id="schemacredentialcontentresults"></a>
<a id="schema_CredentialContentResults"></a>
<a id="tocScredentialcontentresults"></a>
<a id="tocscredentialcontentresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "content": {
          "attrs": {},
          "auth-type": "string",
          "cloud": "string",
          "name": "string",
          "valid": true
        },
        "models": [
          {
            "access": "string",
            "model": "string"
          }
        ]
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[CredentialContentResult](#schemacredentialcontentresult)]|false|none|none|

<h2 id="tocS_InstanceType">InstanceType</h2>
<!-- backwards compatibility -->
<a id="schemainstancetype"></a>
<a id="schema_InstanceType"></a>
<a id="tocSinstancetype"></a>
<a id="tocsinstancetype"></a>

```json
{
  "arches": [
    "string"
  ],
  "cost": 0,
  "cpu-cores": 0,
  "deprecated": true,
  "memory": 0,
  "name": "string",
  "root-disk": 0,
  "virt-type": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|arches|[string]|true|none|none|
|cost|integer|false|none|none|
|cpu-cores|integer|true|none|none|
|deprecated|boolean|false|none|none|
|memory|integer|true|none|none|
|name|string|false|none|none|
|root-disk|integer|false|none|none|
|virt-type|string|false|none|none|

<h2 id="tocS_InstanceTypesResult">InstanceTypesResult</h2>
<!-- backwards compatibility -->
<a id="schemainstancetypesresult"></a>
<a id="schema_InstanceTypesResult"></a>
<a id="tocSinstancetypesresult"></a>
<a id="tocsinstancetypesresult"></a>

```json
{
  "cost-currency": "string",
  "cost-divisor": 0,
  "cost-unit": "string",
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "instance-types": [
    {
      "arches": [
        "string"
      ],
      "cost": 0,
      "cpu-cores": 0,
      "deprecated": true,
      "memory": 0,
      "name": "string",
      "root-disk": 0,
      "virt-type": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|cost-currency|string|false|none|none|
|cost-divisor|integer|false|none|none|
|cost-unit|string|false|none|none|
|error|[Error](#schemaerror)|false|none|none|
|instance-types|[[InstanceType](#schemainstancetype)]|false|none|none|

<h2 id="tocS_InstanceTypesResults">InstanceTypesResults</h2>
<!-- backwards compatibility -->
<a id="schemainstancetypesresults"></a>
<a id="schema_InstanceTypesResults"></a>
<a id="tocSinstancetypesresults"></a>
<a id="tocsinstancetypesresults"></a>

```json
{
  "results": [
    {
      "cost-currency": "string",
      "cost-divisor": 0,
      "cost-unit": "string",
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "instance-types": [
        {
          "arches": [
            "string"
          ],
          "cost": 0,
          "cpu-cores": 0,
          "deprecated": true,
          "memory": 0,
          "name": "string",
          "root-disk": 0,
          "virt-type": "string"
        }
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[InstanceTypesResult](#schemainstancetypesresult)]|true|none|none|

<h2 id="tocS_ListCloudInfo">ListCloudInfo</h2>
<!-- backwards compatibility -->
<a id="schemalistcloudinfo"></a>
<a id="schema_ListCloudInfo"></a>
<a id="tocSlistcloudinfo"></a>
<a id="tocslistcloudinfo"></a>

```json
{
  "CloudDetails": {
    "auth-types": [
      "string"
    ],
    "endpoint": "string",
    "identity-endpoint": "string",
    "regions": [
      {
        "endpoint": "string",
        "identity-endpoint": "string",
        "name": "string",
        "storage-endpoint": "string"
      }
    ],
    "storage-endpoint": "string",
    "type": "string"
  },
  "user-access": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|CloudDetails|[CloudDetails](#schemaclouddetails)|true|none|none|
|user-access|string|true|none|none|

<h2 id="tocS_ListCloudInfoResult">ListCloudInfoResult</h2>
<!-- backwards compatibility -->
<a id="schemalistcloudinforesult"></a>
<a id="schema_ListCloudInfoResult"></a>
<a id="tocSlistcloudinforesult"></a>
<a id="tocslistcloudinforesult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": {
    "CloudDetails": {
      "auth-types": [
        "string"
      ],
      "endpoint": "string",
      "identity-endpoint": "string",
      "regions": [
        {
          "endpoint": "string",
          "identity-endpoint": "string",
          "name": "string",
          "storage-endpoint": "string"
        }
      ],
      "storage-endpoint": "string",
      "type": "string"
    },
    "user-access": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|result|[ListCloudInfo](#schemalistcloudinfo)|false|none|none|

<h2 id="tocS_ListCloudInfoResults">ListCloudInfoResults</h2>
<!-- backwards compatibility -->
<a id="schemalistcloudinforesults"></a>
<a id="schema_ListCloudInfoResults"></a>
<a id="tocSlistcloudinforesults"></a>
<a id="tocslistcloudinforesults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "CloudDetails": {
          "auth-types": [
            "string"
          ],
          "endpoint": "string",
          "identity-endpoint": "string",
          "regions": [
            {
              "endpoint": "string",
              "identity-endpoint": "string",
              "name": "string",
              "storage-endpoint": "string"
            }
          ],
          "storage-endpoint": "string",
          "type": "string"
        },
        "user-access": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[ListCloudInfoResult](#schemalistcloudinforesult)]|true|none|none|

<h2 id="tocS_ListCloudsRequest">ListCloudsRequest</h2>
<!-- backwards compatibility -->
<a id="schemalistcloudsrequest"></a>
<a id="schema_ListCloudsRequest"></a>
<a id="tocSlistcloudsrequest"></a>
<a id="tocslistcloudsrequest"></a>

```json
{
  "all": true,
  "user-tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|all|boolean|false|none|none|
|user-tag|string|true|none|none|

<h2 id="tocS_ModelAccess">ModelAccess</h2>
<!-- backwards compatibility -->
<a id="schemamodelaccess"></a>
<a id="schema_ModelAccess"></a>
<a id="tocSmodelaccess"></a>
<a id="tocsmodelaccess"></a>

```json
{
  "access": "string",
  "model": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|access|string|false|none|none|
|model|string|false|none|none|

<h2 id="tocS_ModifyCloudAccess">ModifyCloudAccess</h2>
<!-- backwards compatibility -->
<a id="schemamodifycloudaccess"></a>
<a id="schema_ModifyCloudAccess"></a>
<a id="tocSmodifycloudaccess"></a>
<a id="tocsmodifycloudaccess"></a>

```json
{
  "access": "string",
  "action": "string",
  "cloud-tag": "string",
  "user-tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|access|string|true|none|none|
|action|string|true|none|none|
|cloud-tag|string|true|none|none|
|user-tag|string|true|none|none|

<h2 id="tocS_ModifyCloudAccessRequest">ModifyCloudAccessRequest</h2>
<!-- backwards compatibility -->
<a id="schemamodifycloudaccessrequest"></a>
<a id="schema_ModifyCloudAccessRequest"></a>
<a id="tocSmodifycloudaccessrequest"></a>
<a id="tocsmodifycloudaccessrequest"></a>

```json
{
  "changes": [
    {
      "access": "string",
      "action": "string",
      "cloud-tag": "string",
      "user-tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|changes|[[ModifyCloudAccess](#schemamodifycloudaccess)]|true|none|none|

<h2 id="tocS_RevokeCredentialArg">RevokeCredentialArg</h2>
<!-- backwards compatibility -->
<a id="schemarevokecredentialarg"></a>
<a id="schema_RevokeCredentialArg"></a>
<a id="tocSrevokecredentialarg"></a>
<a id="tocsrevokecredentialarg"></a>

```json
{
  "force": true,
  "tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|force|boolean|true|none|none|
|tag|string|true|none|none|

<h2 id="tocS_RevokeCredentialArgs">RevokeCredentialArgs</h2>
<!-- backwards compatibility -->
<a id="schemarevokecredentialargs"></a>
<a id="schema_RevokeCredentialArgs"></a>
<a id="tocSrevokecredentialargs"></a>
<a id="tocsrevokecredentialargs"></a>

```json
{
  "credentials": [
    {
      "force": true,
      "tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|credentials|[[RevokeCredentialArg](#schemarevokecredentialarg)]|true|none|none|

<h2 id="tocS_StringsResult">StringsResult</h2>
<!-- backwards compatibility -->
<a id="schemastringsresult"></a>
<a id="schema_StringsResult"></a>
<a id="tocSstringsresult"></a>
<a id="tocsstringsresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|result|[string]|false|none|none|

<h2 id="tocS_StringsResults">StringsResults</h2>
<!-- backwards compatibility -->
<a id="schemastringsresults"></a>
<a id="schema_StringsResults"></a>
<a id="tocSstringsresults"></a>
<a id="tocsstringsresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": [
        "string"
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[StringsResult](#schemastringsresult)]|true|none|none|

<h2 id="tocS_TaggedCredential">TaggedCredential</h2>
<!-- backwards compatibility -->
<a id="schemataggedcredential"></a>
<a id="schema_TaggedCredential"></a>
<a id="tocStaggedcredential"></a>
<a id="tocstaggedcredential"></a>

```json
{
  "credential": {
    "attrs": {},
    "auth-type": "string",
    "redacted": [
      "string"
    ]
  },
  "tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|credential|[CloudCredential](#schemacloudcredential)|true|none|none|
|tag|string|true|none|none|

<h2 id="tocS_TaggedCredentials">TaggedCredentials</h2>
<!-- backwards compatibility -->
<a id="schemataggedcredentials"></a>
<a id="schema_TaggedCredentials"></a>
<a id="tocStaggedcredentials"></a>
<a id="tocstaggedcredentials"></a>

```json
{
  "credentials": [
    {
      "credential": {
        "attrs": {},
        "auth-type": "string",
        "redacted": [
          "string"
        ]
      },
      "tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|credentials|[[TaggedCredential](#schemataggedcredential)]|false|none|none|

<h2 id="tocS_UpdateCloudArgs">UpdateCloudArgs</h2>
<!-- backwards compatibility -->
<a id="schemaupdatecloudargs"></a>
<a id="schema_UpdateCloudArgs"></a>
<a id="tocSupdatecloudargs"></a>
<a id="tocsupdatecloudargs"></a>

```json
{
  "clouds": [
    {
      "cloud": {
        "auth-types": [
          "string"
        ],
        "ca-certificates": [
          "string"
        ],
        "config": {},
        "endpoint": "string",
        "host-cloud-region": "string",
        "identity-endpoint": "string",
        "is-controller-cloud": true,
        "region-config": {},
        "regions": [
          {
            "endpoint": "string",
            "identity-endpoint": "string",
            "name": "string",
            "storage-endpoint": "string"
          }
        ],
        "skip-tls-verify": true,
        "storage-endpoint": "string",
        "type": "string"
      },
      "force": true,
      "name": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|clouds|[[AddCloudArgs](#schemaaddcloudargs)]|true|none|none|

<h2 id="tocS_UpdateCredentialArgs">UpdateCredentialArgs</h2>
<!-- backwards compatibility -->
<a id="schemaupdatecredentialargs"></a>
<a id="schema_UpdateCredentialArgs"></a>
<a id="tocSupdatecredentialargs"></a>
<a id="tocsupdatecredentialargs"></a>

```json
{
  "credentials": [
    {
      "credential": {
        "attrs": {},
        "auth-type": "string",
        "redacted": [
          "string"
        ]
      },
      "tag": "string"
    }
  ],
  "force": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|credentials|[[TaggedCredential](#schemataggedcredential)]|true|none|none|
|force|boolean|true|none|none|

<h2 id="tocS_UpdateCredentialModelResult">UpdateCredentialModelResult</h2>
<!-- backwards compatibility -->
<a id="schemaupdatecredentialmodelresult"></a>
<a id="schema_UpdateCredentialModelResult"></a>
<a id="tocSupdatecredentialmodelresult"></a>
<a id="tocsupdatecredentialmodelresult"></a>

```json
{
  "errors": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ],
  "name": "string",
  "uuid": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|errors|[[ErrorResult](#schemaerrorresult)]|false|none|none|
|name|string|true|none|none|
|uuid|string|true|none|none|

<h2 id="tocS_UpdateCredentialResult">UpdateCredentialResult</h2>
<!-- backwards compatibility -->
<a id="schemaupdatecredentialresult"></a>
<a id="schema_UpdateCredentialResult"></a>
<a id="tocSupdatecredentialresult"></a>
<a id="tocsupdatecredentialresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "models": [
    {
      "errors": [
        {
          "error": {
            "code": "string",
            "info": {},
            "message": "string"
          }
        }
      ],
      "name": "string",
      "uuid": "string"
    }
  ],
  "tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|models|[[UpdateCredentialModelResult](#schemaupdatecredentialmodelresult)]|false|none|none|
|tag|string|true|none|none|

<h2 id="tocS_UpdateCredentialResults">UpdateCredentialResults</h2>
<!-- backwards compatibility -->
<a id="schemaupdatecredentialresults"></a>
<a id="schema_UpdateCredentialResults"></a>
<a id="tocSupdatecredentialresults"></a>
<a id="tocsupdatecredentialresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "models": [
        {
          "errors": [
            {
              "error": {
                "code": "string",
                "info": {},
                "message": "string"
              }
            }
          ],
          "name": "string",
          "uuid": "string"
        }
      ],
      "tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[UpdateCredentialResult](#schemaupdatecredentialresult)]|false|none|none|

<h2 id="tocS_UserCloud">UserCloud</h2>
<!-- backwards compatibility -->
<a id="schemausercloud"></a>
<a id="schema_UserCloud"></a>
<a id="tocSusercloud"></a>
<a id="tocsusercloud"></a>

```json
{
  "cloud-tag": "string",
  "user-tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|cloud-tag|string|true|none|none|
|user-tag|string|true|none|none|

<h2 id="tocS_UserClouds">UserClouds</h2>
<!-- backwards compatibility -->
<a id="schemauserclouds"></a>
<a id="schema_UserClouds"></a>
<a id="tocSuserclouds"></a>
<a id="tocsuserclouds"></a>

```json
{
  "user-clouds": [
    {
      "cloud-tag": "string",
      "user-tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|user-clouds|[[UserCloud](#schemausercloud)]|false|none|none|

<h2 id="tocS_CloudSpec">CloudSpec</h2>
<!-- backwards compatibility -->
<a id="schemacloudspec"></a>
<a id="schema_CloudSpec"></a>
<a id="tocScloudspec"></a>
<a id="tocscloudspec"></a>

```json
{
  "cacertificates": [
    "string"
  ],
  "credential": {
    "attrs": {},
    "auth-type": "string",
    "redacted": [
      "string"
    ]
  },
  "endpoint": "string",
  "identity-endpoint": "string",
  "is-controller-cloud": true,
  "name": "string",
  "region": "string",
  "skip-tls-verify": true,
  "storage-endpoint": "string",
  "type": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|cacertificates|[string]|false|none|none|
|credential|[CloudCredential](#schemacloudcredential)|false|none|none|
|endpoint|string|false|none|none|
|identity-endpoint|string|false|none|none|
|is-controller-cloud|boolean|false|none|none|
|name|string|true|none|none|
|region|string|false|none|none|
|skip-tls-verify|boolean|false|none|none|
|storage-endpoint|string|false|none|none|
|type|string|true|none|none|

<h2 id="tocS_CloudSpecResult">CloudSpecResult</h2>
<!-- backwards compatibility -->
<a id="schemacloudspecresult"></a>
<a id="schema_CloudSpecResult"></a>
<a id="tocScloudspecresult"></a>
<a id="tocscloudspecresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": {
    "cacertificates": [
      "string"
    ],
    "credential": {
      "attrs": {},
      "auth-type": "string",
      "redacted": [
        "string"
      ]
    },
    "endpoint": "string",
    "identity-endpoint": "string",
    "is-controller-cloud": true,
    "name": "string",
    "region": "string",
    "skip-tls-verify": true,
    "storage-endpoint": "string",
    "type": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|result|[CloudSpec](#schemacloudspec)|false|none|none|

<h2 id="tocS_CloudSpecResults">CloudSpecResults</h2>
<!-- backwards compatibility -->
<a id="schemacloudspecresults"></a>
<a id="schema_CloudSpecResults"></a>
<a id="tocScloudspecresults"></a>
<a id="tocscloudspecresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "cacertificates": [
          "string"
        ],
        "credential": {
          "attrs": {},
          "auth-type": "string",
          "redacted": [
            "string"
          ]
        },
        "endpoint": "string",
        "identity-endpoint": "string",
        "is-controller-cloud": true,
        "name": "string",
        "region": "string",
        "skip-tls-verify": true,
        "storage-endpoint": "string",
        "type": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[CloudSpecResult](#schemacloudspecresult)]|false|none|none|

<h2 id="tocS_ConfigValue">ConfigValue</h2>
<!-- backwards compatibility -->
<a id="schemaconfigvalue"></a>
<a id="schema_ConfigValue"></a>
<a id="tocSconfigvalue"></a>
<a id="tocsconfigvalue"></a>

```json
{
  "source": "string",
  "value": {}
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|source|string|true|none|none|
|value|object|true|none|none|

<h2 id="tocS_ControllerAPIInfoResult">ControllerAPIInfoResult</h2>
<!-- backwards compatibility -->
<a id="schemacontrollerapiinforesult"></a>
<a id="schema_ControllerAPIInfoResult"></a>
<a id="tocScontrollerapiinforesult"></a>
<a id="tocscontrollerapiinforesult"></a>

```json
{
  "addresses": [
    "string"
  ],
  "cacert": "string",
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|addresses|[string]|true|none|none|
|cacert|string|true|none|none|
|error|[Error](#schemaerror)|false|none|none|

<h2 id="tocS_ControllerAPIInfoResults">ControllerAPIInfoResults</h2>
<!-- backwards compatibility -->
<a id="schemacontrollerapiinforesults"></a>
<a id="schema_ControllerAPIInfoResults"></a>
<a id="tocScontrollerapiinforesults"></a>
<a id="tocscontrollerapiinforesults"></a>

```json
{
  "results": [
    {
      "addresses": [
        "string"
      ],
      "cacert": "string",
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[ControllerAPIInfoResult](#schemacontrollerapiinforesult)]|true|none|none|

<h2 id="tocS_ControllerConfigResult">ControllerConfigResult</h2>
<!-- backwards compatibility -->
<a id="schemacontrollerconfigresult"></a>
<a id="schema_ControllerConfigResult"></a>
<a id="tocScontrollerconfigresult"></a>
<a id="tocscontrollerconfigresult"></a>

```json
{
  "config": {}
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|config|object|true|none|none|
|» .*|object|false|none|none|

<h2 id="tocS_ControllerConfigSet">ControllerConfigSet</h2>
<!-- backwards compatibility -->
<a id="schemacontrollerconfigset"></a>
<a id="schema_ControllerConfigSet"></a>
<a id="tocScontrollerconfigset"></a>
<a id="tocscontrollerconfigset"></a>

```json
{
  "config": {}
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|config|object|true|none|none|
|» .*|object|false|none|none|

<h2 id="tocS_ControllerVersionResults">ControllerVersionResults</h2>
<!-- backwards compatibility -->
<a id="schemacontrollerversionresults"></a>
<a id="schema_ControllerVersionResults"></a>
<a id="tocScontrollerversionresults"></a>
<a id="tocscontrollerversionresults"></a>

```json
{
  "git-commit": "string",
  "version": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|git-commit|string|true|none|none|
|version|string|true|none|none|

<h2 id="tocS_DashboardConnectionInfo">DashboardConnectionInfo</h2>
<!-- backwards compatibility -->
<a id="schemadashboardconnectioninfo"></a>
<a id="schema_DashboardConnectionInfo"></a>
<a id="tocSdashboardconnectioninfo"></a>
<a id="tocsdashboardconnectioninfo"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "proxy-connection": {
    "config": {},
    "type": "string"
  },
  "ssh-connection": {
    "entity": "string",
    "host": "string",
    "model": "string",
    "port": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|proxy-connection|[Proxy](#schemaproxy)|true|none|none|
|ssh-connection|[DashboardConnectionSSHTunnel](#schemadashboardconnectionsshtunnel)|true|none|none|

<h2 id="tocS_DashboardConnectionSSHTunnel">DashboardConnectionSSHTunnel</h2>
<!-- backwards compatibility -->
<a id="schemadashboardconnectionsshtunnel"></a>
<a id="schema_DashboardConnectionSSHTunnel"></a>
<a id="tocSdashboardconnectionsshtunnel"></a>
<a id="tocsdashboardconnectionsshtunnel"></a>

```json
{
  "entity": "string",
  "host": "string",
  "model": "string",
  "port": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|entity|string|false|none|none|
|host|string|true|none|none|
|model|string|false|none|none|
|port|string|true|none|none|

<h2 id="tocS_DestroyControllerArgs">DestroyControllerArgs</h2>
<!-- backwards compatibility -->
<a id="schemadestroycontrollerargs"></a>
<a id="schema_DestroyControllerArgs"></a>
<a id="tocSdestroycontrollerargs"></a>
<a id="tocsdestroycontrollerargs"></a>

```json
{
  "destroy-models": true,
  "destroy-storage": true,
  "force": true,
  "max-wait": 0,
  "model-timeout": 0
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|destroy-models|boolean|true|none|none|
|destroy-storage|boolean|false|none|none|
|force|boolean|false|none|none|
|max-wait|integer|false|none|none|
|model-timeout|integer|false|none|none|

<h2 id="tocS_HostedModelConfig">HostedModelConfig</h2>
<!-- backwards compatibility -->
<a id="schemahostedmodelconfig"></a>
<a id="schema_HostedModelConfig"></a>
<a id="tocShostedmodelconfig"></a>
<a id="tocshostedmodelconfig"></a>

```json
{
  "cloud-spec": {
    "cacertificates": [
      "string"
    ],
    "credential": {
      "attrs": {},
      "auth-type": "string",
      "redacted": [
        "string"
      ]
    },
    "endpoint": "string",
    "identity-endpoint": "string",
    "is-controller-cloud": true,
    "name": "string",
    "region": "string",
    "skip-tls-verify": true,
    "storage-endpoint": "string",
    "type": "string"
  },
  "config": {},
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "name": "string",
  "owner": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|cloud-spec|[CloudSpec](#schemacloudspec)|false|none|none|
|config|object|false|none|none|
|» .*|object|false|none|none|
|error|[Error](#schemaerror)|false|none|none|
|name|string|true|none|none|
|owner|string|true|none|none|

<h2 id="tocS_HostedModelConfigsResults">HostedModelConfigsResults</h2>
<!-- backwards compatibility -->
<a id="schemahostedmodelconfigsresults"></a>
<a id="schema_HostedModelConfigsResults"></a>
<a id="tocShostedmodelconfigsresults"></a>
<a id="tocshostedmodelconfigsresults"></a>

```json
{
  "models": [
    {
      "cloud-spec": {
        "cacertificates": [
          "string"
        ],
        "credential": {
          "attrs": {},
          "auth-type": "string",
          "redacted": [
            "string"
          ]
        },
        "endpoint": "string",
        "identity-endpoint": "string",
        "is-controller-cloud": true,
        "name": "string",
        "region": "string",
        "skip-tls-verify": true,
        "storage-endpoint": "string",
        "type": "string"
      },
      "config": {},
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "name": "string",
      "owner": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|models|[[HostedModelConfig](#schemahostedmodelconfig)]|true|none|none|

<h2 id="tocS_InitiateMigrationArgs">InitiateMigrationArgs</h2>
<!-- backwards compatibility -->
<a id="schemainitiatemigrationargs"></a>
<a id="schema_InitiateMigrationArgs"></a>
<a id="tocSinitiatemigrationargs"></a>
<a id="tocsinitiatemigrationargs"></a>

```json
{
  "specs": [
    {
      "model-tag": "string",
      "target-info": {
        "addrs": [
          "string"
        ],
        "auth-tag": "string",
        "ca-cert": "string",
        "controller-alias": "string",
        "controller-tag": "string",
        "macaroons": "string",
        "password": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|specs|[[MigrationSpec](#schemamigrationspec)]|true|none|none|

<h2 id="tocS_InitiateMigrationResult">InitiateMigrationResult</h2>
<!-- backwards compatibility -->
<a id="schemainitiatemigrationresult"></a>
<a id="schema_InitiateMigrationResult"></a>
<a id="tocSinitiatemigrationresult"></a>
<a id="tocsinitiatemigrationresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "migration-id": "string",
  "model-tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|migration-id|string|true|none|none|
|model-tag|string|true|none|none|

<h2 id="tocS_InitiateMigrationResults">InitiateMigrationResults</h2>
<!-- backwards compatibility -->
<a id="schemainitiatemigrationresults"></a>
<a id="schema_InitiateMigrationResults"></a>
<a id="tocSinitiatemigrationresults"></a>
<a id="tocsinitiatemigrationresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "migration-id": "string",
      "model-tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[InitiateMigrationResult](#schemainitiatemigrationresult)]|true|none|none|

<h2 id="tocS_MachineHardware">MachineHardware</h2>
<!-- backwards compatibility -->
<a id="schemamachinehardware"></a>
<a id="schema_MachineHardware"></a>
<a id="tocSmachinehardware"></a>
<a id="tocsmachinehardware"></a>

```json
{
  "arch": "string",
  "availability-zone": "string",
  "cores": 0,
  "cpu-power": 0,
  "mem": 0,
  "root-disk": 0,
  "tags": [
    "string"
  ],
  "virt-type": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|arch|string|false|none|none|
|availability-zone|string|false|none|none|
|cores|integer|false|none|none|
|cpu-power|integer|false|none|none|
|mem|integer|false|none|none|
|root-disk|integer|false|none|none|
|tags|[string]|false|none|none|
|virt-type|string|false|none|none|

<h2 id="tocS_MigrationSpec">MigrationSpec</h2>
<!-- backwards compatibility -->
<a id="schemamigrationspec"></a>
<a id="schema_MigrationSpec"></a>
<a id="tocSmigrationspec"></a>
<a id="tocsmigrationspec"></a>

```json
{
  "model-tag": "string",
  "target-info": {
    "addrs": [
      "string"
    ],
    "auth-tag": "string",
    "ca-cert": "string",
    "controller-alias": "string",
    "controller-tag": "string",
    "macaroons": "string",
    "password": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|model-tag|string|true|none|none|
|target-info|[MigrationTargetInfo](#schemamigrationtargetinfo)|true|none|none|

<h2 id="tocS_MigrationTargetInfo">MigrationTargetInfo</h2>
<!-- backwards compatibility -->
<a id="schemamigrationtargetinfo"></a>
<a id="schema_MigrationTargetInfo"></a>
<a id="tocSmigrationtargetinfo"></a>
<a id="tocsmigrationtargetinfo"></a>

```json
{
  "addrs": [
    "string"
  ],
  "auth-tag": "string",
  "ca-cert": "string",
  "controller-alias": "string",
  "controller-tag": "string",
  "macaroons": "string",
  "password": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|addrs|[string]|true|none|none|
|auth-tag|string|true|none|none|
|ca-cert|string|true|none|none|
|controller-alias|string|false|none|none|
|controller-tag|string|true|none|none|
|macaroons|string|false|none|none|
|password|string|false|none|none|

<h2 id="tocS_Model">Model</h2>
<!-- backwards compatibility -->
<a id="schemamodel"></a>
<a id="schema_Model"></a>
<a id="tocSmodel"></a>
<a id="tocsmodel"></a>

```json
{
  "name": "string",
  "owner-tag": "string",
  "type": "string",
  "uuid": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|name|string|true|none|none|
|owner-tag|string|true|none|none|
|type|string|true|none|none|
|uuid|string|true|none|none|

<h2 id="tocS_ModelApplicationInfo">ModelApplicationInfo</h2>
<!-- backwards compatibility -->
<a id="schemamodelapplicationinfo"></a>
<a id="schema_ModelApplicationInfo"></a>
<a id="tocSmodelapplicationinfo"></a>
<a id="tocsmodelapplicationinfo"></a>

```json
{
  "name": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|name|string|true|none|none|

<h2 id="tocS_ModelBlockInfo">ModelBlockInfo</h2>
<!-- backwards compatibility -->
<a id="schemamodelblockinfo"></a>
<a id="schema_ModelBlockInfo"></a>
<a id="tocSmodelblockinfo"></a>
<a id="tocsmodelblockinfo"></a>

```json
{
  "blocks": [
    "string"
  ],
  "model-uuid": "string",
  "name": "string",
  "owner-tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|blocks|[string]|true|none|none|
|model-uuid|string|true|none|none|
|name|string|true|none|none|
|owner-tag|string|true|none|none|

<h2 id="tocS_ModelBlockInfoList">ModelBlockInfoList</h2>
<!-- backwards compatibility -->
<a id="schemamodelblockinfolist"></a>
<a id="schema_ModelBlockInfoList"></a>
<a id="tocSmodelblockinfolist"></a>
<a id="tocsmodelblockinfolist"></a>

```json
{
  "models": [
    {
      "blocks": [
        "string"
      ],
      "model-uuid": "string",
      "name": "string",
      "owner-tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|models|[[ModelBlockInfo](#schemamodelblockinfo)]|false|none|none|

<h2 id="tocS_ModelConfigResults">ModelConfigResults</h2>
<!-- backwards compatibility -->
<a id="schemamodelconfigresults"></a>
<a id="schema_ModelConfigResults"></a>
<a id="tocSmodelconfigresults"></a>
<a id="tocsmodelconfigresults"></a>

```json
{
  "config": {}
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|config|object|true|none|none|
|» .*|[ConfigValue](#schemaconfigvalue)|false|none|none|

<h2 id="tocS_ModelFilesystemInfo">ModelFilesystemInfo</h2>
<!-- backwards compatibility -->
<a id="schemamodelfilesysteminfo"></a>
<a id="schema_ModelFilesystemInfo"></a>
<a id="tocSmodelfilesysteminfo"></a>
<a id="tocsmodelfilesysteminfo"></a>

```json
{
  "detachable": true,
  "id": "string",
  "message": "string",
  "provider-id": "string",
  "status": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|detachable|boolean|false|none|none|
|id|string|true|none|none|
|message|string|false|none|none|
|provider-id|string|false|none|none|
|status|string|false|none|none|

<h2 id="tocS_ModelMachineInfo">ModelMachineInfo</h2>
<!-- backwards compatibility -->
<a id="schemamodelmachineinfo"></a>
<a id="schema_ModelMachineInfo"></a>
<a id="tocSmodelmachineinfo"></a>
<a id="tocsmodelmachineinfo"></a>

```json
{
  "display-name": "string",
  "ha-primary": true,
  "hardware": {
    "arch": "string",
    "availability-zone": "string",
    "cores": 0,
    "cpu-power": 0,
    "mem": 0,
    "root-disk": 0,
    "tags": [
      "string"
    ],
    "virt-type": "string"
  },
  "has-vote": true,
  "id": "string",
  "instance-id": "string",
  "message": "string",
  "status": "string",
  "wants-vote": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|display-name|string|false|none|none|
|ha-primary|boolean|false|none|none|
|hardware|[MachineHardware](#schemamachinehardware)|false|none|none|
|has-vote|boolean|false|none|none|
|id|string|true|none|none|
|instance-id|string|false|none|none|
|message|string|false|none|none|
|status|string|false|none|none|
|wants-vote|boolean|false|none|none|

<h2 id="tocS_ModelStatus">ModelStatus</h2>
<!-- backwards compatibility -->
<a id="schemamodelstatus"></a>
<a id="schema_ModelStatus"></a>
<a id="tocSmodelstatus"></a>
<a id="tocsmodelstatus"></a>

```json
{
  "application-count": 0,
  "applications": [
    {
      "name": "string"
    }
  ],
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "filesystems": [
    {
      "detachable": true,
      "id": "string",
      "message": "string",
      "provider-id": "string",
      "status": "string"
    }
  ],
  "hosted-machine-count": 0,
  "life": "string",
  "machines": [
    {
      "display-name": "string",
      "ha-primary": true,
      "hardware": {
        "arch": "string",
        "availability-zone": "string",
        "cores": 0,
        "cpu-power": 0,
        "mem": 0,
        "root-disk": 0,
        "tags": [
          "string"
        ],
        "virt-type": "string"
      },
      "has-vote": true,
      "id": "string",
      "instance-id": "string",
      "message": "string",
      "status": "string",
      "wants-vote": true
    }
  ],
  "model-tag": "string",
  "owner-tag": "string",
  "type": "string",
  "unit-count": 0,
  "volumes": [
    {
      "detachable": true,
      "id": "string",
      "message": "string",
      "provider-id": "string",
      "status": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|application-count|integer|true|none|none|
|applications|[[ModelApplicationInfo](#schemamodelapplicationinfo)]|false|none|none|
|error|[Error](#schemaerror)|false|none|none|
|filesystems|[[ModelFilesystemInfo](#schemamodelfilesysteminfo)]|false|none|none|
|hosted-machine-count|integer|true|none|none|
|life|string|true|none|none|
|machines|[[ModelMachineInfo](#schemamodelmachineinfo)]|false|none|none|
|model-tag|string|true|none|none|
|owner-tag|string|true|none|none|
|type|string|true|none|none|
|unit-count|integer|true|none|none|
|volumes|[[ModelVolumeInfo](#schemamodelvolumeinfo)]|false|none|none|

<h2 id="tocS_ModelStatusResults">ModelStatusResults</h2>
<!-- backwards compatibility -->
<a id="schemamodelstatusresults"></a>
<a id="schema_ModelStatusResults"></a>
<a id="tocSmodelstatusresults"></a>
<a id="tocsmodelstatusresults"></a>

```json
{
  "models": [
    {
      "application-count": 0,
      "applications": [
        {
          "name": "string"
        }
      ],
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "filesystems": [
        {
          "detachable": true,
          "id": "string",
          "message": "string",
          "provider-id": "string",
          "status": "string"
        }
      ],
      "hosted-machine-count": 0,
      "life": "string",
      "machines": [
        {
          "display-name": "string",
          "ha-primary": true,
          "hardware": {
            "arch": "string",
            "availability-zone": "string",
            "cores": 0,
            "cpu-power": 0,
            "mem": 0,
            "root-disk": 0,
            "tags": [
              "string"
            ],
            "virt-type": "string"
          },
          "has-vote": true,
          "id": "string",
          "instance-id": "string",
          "message": "string",
          "status": "string",
          "wants-vote": true
        }
      ],
      "model-tag": "string",
      "owner-tag": "string",
      "type": "string",
      "unit-count": 0,
      "volumes": [
        {
          "detachable": true,
          "id": "string",
          "message": "string",
          "provider-id": "string",
          "status": "string"
        }
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|models|[[ModelStatus](#schemamodelstatus)]|true|none|none|

<h2 id="tocS_ModelTag">ModelTag</h2>
<!-- backwards compatibility -->
<a id="schemamodeltag"></a>
<a id="schema_ModelTag"></a>
<a id="tocSmodeltag"></a>
<a id="tocsmodeltag"></a>

```json
{}

```

### Properties

*None*

<h2 id="tocS_ModelVolumeInfo">ModelVolumeInfo</h2>
<!-- backwards compatibility -->
<a id="schemamodelvolumeinfo"></a>
<a id="schema_ModelVolumeInfo"></a>
<a id="tocSmodelvolumeinfo"></a>
<a id="tocsmodelvolumeinfo"></a>

```json
{
  "detachable": true,
  "id": "string",
  "message": "string",
  "provider-id": "string",
  "status": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|detachable|boolean|false|none|none|
|id|string|true|none|none|
|message|string|false|none|none|
|provider-id|string|false|none|none|
|status|string|false|none|none|

<h2 id="tocS_ModifyControllerAccess">ModifyControllerAccess</h2>
<!-- backwards compatibility -->
<a id="schemamodifycontrolleraccess"></a>
<a id="schema_ModifyControllerAccess"></a>
<a id="tocSmodifycontrolleraccess"></a>
<a id="tocsmodifycontrolleraccess"></a>

```json
{
  "access": "string",
  "action": "string",
  "user-tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|access|string|true|none|none|
|action|string|true|none|none|
|user-tag|string|true|none|none|

<h2 id="tocS_ModifyControllerAccessRequest">ModifyControllerAccessRequest</h2>
<!-- backwards compatibility -->
<a id="schemamodifycontrolleraccessrequest"></a>
<a id="schema_ModifyControllerAccessRequest"></a>
<a id="tocSmodifycontrolleraccessrequest"></a>
<a id="tocsmodifycontrolleraccessrequest"></a>

```json
{
  "changes": [
    {
      "access": "string",
      "action": "string",
      "user-tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|changes|[[ModifyControllerAccess](#schemamodifycontrolleraccess)]|true|none|none|

<h2 id="tocS_NotifyWatchResult">NotifyWatchResult</h2>
<!-- backwards compatibility -->
<a id="schemanotifywatchresult"></a>
<a id="schema_NotifyWatchResult"></a>
<a id="tocSnotifywatchresult"></a>
<a id="tocsnotifywatchresult"></a>

```json
{
  "NotifyWatcherId": "string",
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|NotifyWatcherId|string|true|none|none|
|error|[Error](#schemaerror)|false|none|none|

<h2 id="tocS_NotifyWatchResults">NotifyWatchResults</h2>
<!-- backwards compatibility -->
<a id="schemanotifywatchresults"></a>
<a id="schema_NotifyWatchResults"></a>
<a id="tocSnotifywatchresults"></a>
<a id="tocsnotifywatchresults"></a>

```json
{
  "results": [
    {
      "NotifyWatcherId": "string",
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[NotifyWatchResult](#schemanotifywatchresult)]|true|none|none|

<h2 id="tocS_Proxy">Proxy</h2>
<!-- backwards compatibility -->
<a id="schemaproxy"></a>
<a id="schema_Proxy"></a>
<a id="tocSproxy"></a>
<a id="tocsproxy"></a>

```json
{
  "config": {},
  "type": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|config|object|true|none|none|
|» .*|object|false|none|none|
|type|string|true|none|none|

<h2 id="tocS_RemoveBlocksArgs">RemoveBlocksArgs</h2>
<!-- backwards compatibility -->
<a id="schemaremoveblocksargs"></a>
<a id="schema_RemoveBlocksArgs"></a>
<a id="tocSremoveblocksargs"></a>
<a id="tocsremoveblocksargs"></a>

```json
{
  "all": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|all|boolean|true|none|none|

<h2 id="tocS_SummaryWatcherID">SummaryWatcherID</h2>
<!-- backwards compatibility -->
<a id="schemasummarywatcherid"></a>
<a id="schema_SummaryWatcherID"></a>
<a id="tocSsummarywatcherid"></a>
<a id="tocssummarywatcherid"></a>

```json
{
  "watcher-id": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|watcher-id|string|true|none|none|

<h2 id="tocS_UserAccess">UserAccess</h2>
<!-- backwards compatibility -->
<a id="schemauseraccess"></a>
<a id="schema_UserAccess"></a>
<a id="tocSuseraccess"></a>
<a id="tocsuseraccess"></a>

```json
{
  "access": "string",
  "user-tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|access|string|true|none|none|
|user-tag|string|true|none|none|

<h2 id="tocS_UserAccessResult">UserAccessResult</h2>
<!-- backwards compatibility -->
<a id="schemauseraccessresult"></a>
<a id="schema_UserAccessResult"></a>
<a id="tocSuseraccessresult"></a>
<a id="tocsuseraccessresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": {
    "access": "string",
    "user-tag": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|result|[UserAccess](#schemauseraccess)|false|none|none|

<h2 id="tocS_UserAccessResults">UserAccessResults</h2>
<!-- backwards compatibility -->
<a id="schemauseraccessresults"></a>
<a id="schema_UserAccessResults"></a>
<a id="tocSuseraccessresults"></a>
<a id="tocsuseraccessresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "access": "string",
        "user-tag": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[UserAccessResult](#schemauseraccessresult)]|false|none|none|

<h2 id="tocS_UserModel">UserModel</h2>
<!-- backwards compatibility -->
<a id="schemausermodel"></a>
<a id="schema_UserModel"></a>
<a id="tocSusermodel"></a>
<a id="tocsusermodel"></a>

```json
{
  "last-connection": "2019-08-24T14:15:22Z",
  "model": {
    "name": "string",
    "owner-tag": "string",
    "type": "string",
    "uuid": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|last-connection|string(date-time)|true|none|none|
|model|[Model](#schemamodel)|true|none|none|

<h2 id="tocS_UserModelList">UserModelList</h2>
<!-- backwards compatibility -->
<a id="schemausermodellist"></a>
<a id="schema_UserModelList"></a>
<a id="tocSusermodellist"></a>
<a id="tocsusermodellist"></a>

```json
{
  "user-models": [
    {
      "last-connection": "2019-08-24T14:15:22Z",
      "model": {
        "name": "string",
        "owner-tag": "string",
        "type": "string",
        "uuid": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|user-models|[[UserModel](#schemausermodel)]|true|none|none|

<h2 id="tocS_InvalidateCredentialArg">InvalidateCredentialArg</h2>
<!-- backwards compatibility -->
<a id="schemainvalidatecredentialarg"></a>
<a id="schema_InvalidateCredentialArg"></a>
<a id="tocSinvalidatecredentialarg"></a>
<a id="tocsinvalidatecredentialarg"></a>

```json
{
  "reason": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|reason|string|false|none|none|

<h2 id="tocS_FirewallRule">FirewallRule</h2>
<!-- backwards compatibility -->
<a id="schemafirewallrule"></a>
<a id="schema_FirewallRule"></a>
<a id="tocSfirewallrule"></a>
<a id="tocsfirewallrule"></a>

```json
{
  "known-service": "string",
  "whitelist-cidrs": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|known-service|string|true|none|none|
|whitelist-cidrs|[string]|false|none|none|

<h2 id="tocS_FirewallRuleArgs">FirewallRuleArgs</h2>
<!-- backwards compatibility -->
<a id="schemafirewallruleargs"></a>
<a id="schema_FirewallRuleArgs"></a>
<a id="tocSfirewallruleargs"></a>
<a id="tocsfirewallruleargs"></a>

```json
{
  "args": [
    {
      "known-service": "string",
      "whitelist-cidrs": [
        "string"
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|args|[[FirewallRule](#schemafirewallrule)]|true|none|none|

<h2 id="tocS_ListFirewallRulesResults">ListFirewallRulesResults</h2>
<!-- backwards compatibility -->
<a id="schemalistfirewallrulesresults"></a>
<a id="schema_ListFirewallRulesResults"></a>
<a id="tocSlistfirewallrulesresults"></a>
<a id="tocslistfirewallrulesresults"></a>

```json
{
  "Rules": [
    {
      "known-service": "string",
      "whitelist-cidrs": [
        "string"
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|Rules|[[FirewallRule](#schemafirewallrule)]|true|none|none|

<h2 id="tocS_ControllersChangeResult">ControllersChangeResult</h2>
<!-- backwards compatibility -->
<a id="schemacontrollerschangeresult"></a>
<a id="schema_ControllersChangeResult"></a>
<a id="tocScontrollerschangeresult"></a>
<a id="tocscontrollerschangeresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": {
    "added": [
      "string"
    ],
    "converted": [
      "string"
    ],
    "maintained": [
      "string"
    ],
    "removed": [
      "string"
    ]
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|result|[ControllersChanges](#schemacontrollerschanges)|true|none|none|

<h2 id="tocS_ControllersChangeResults">ControllersChangeResults</h2>
<!-- backwards compatibility -->
<a id="schemacontrollerschangeresults"></a>
<a id="schema_ControllersChangeResults"></a>
<a id="tocScontrollerschangeresults"></a>
<a id="tocscontrollerschangeresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "added": [
          "string"
        ],
        "converted": [
          "string"
        ],
        "maintained": [
          "string"
        ],
        "removed": [
          "string"
        ]
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[ControllersChangeResult](#schemacontrollerschangeresult)]|true|none|none|

<h2 id="tocS_ControllersChanges">ControllersChanges</h2>
<!-- backwards compatibility -->
<a id="schemacontrollerschanges"></a>
<a id="schema_ControllersChanges"></a>
<a id="tocScontrollerschanges"></a>
<a id="tocscontrollerschanges"></a>

```json
{
  "added": [
    "string"
  ],
  "converted": [
    "string"
  ],
  "maintained": [
    "string"
  ],
  "removed": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|added|[string]|false|none|none|
|converted|[string]|false|none|none|
|maintained|[string]|false|none|none|
|removed|[string]|false|none|none|

<h2 id="tocS_ControllersSpec">ControllersSpec</h2>
<!-- backwards compatibility -->
<a id="schemacontrollersspec"></a>
<a id="schema_ControllersSpec"></a>
<a id="tocScontrollersspec"></a>
<a id="tocscontrollersspec"></a>

```json
{
  "constraints": {
    "allocate-public-ip": true,
    "arch": "string",
    "container": "string",
    "cores": 0,
    "cpu-power": 0,
    "image-id": "string",
    "instance-role": "string",
    "instance-type": "string",
    "mem": 0,
    "root-disk": 0,
    "root-disk-source": "string",
    "spaces": [
      "string"
    ],
    "tags": [
      "string"
    ],
    "virt-type": "string",
    "zones": [
      "string"
    ]
  },
  "num-controllers": 0,
  "placement": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|constraints|[Value](#schemavalue)|false|none|none|
|num-controllers|integer|true|none|none|
|placement|[string]|false|none|none|

<h2 id="tocS_ControllersSpecs">ControllersSpecs</h2>
<!-- backwards compatibility -->
<a id="schemacontrollersspecs"></a>
<a id="schema_ControllersSpecs"></a>
<a id="tocScontrollersspecs"></a>
<a id="tocscontrollersspecs"></a>

```json
{
  "specs": [
    {
      "constraints": {
        "allocate-public-ip": true,
        "arch": "string",
        "container": "string",
        "cores": 0,
        "cpu-power": 0,
        "image-id": "string",
        "instance-role": "string",
        "instance-type": "string",
        "mem": 0,
        "root-disk": 0,
        "root-disk-source": "string",
        "spaces": [
          "string"
        ],
        "tags": [
          "string"
        ],
        "virt-type": "string",
        "zones": [
          "string"
        ]
      },
      "num-controllers": 0,
      "placement": [
        "string"
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|specs|[[ControllersSpec](#schemacontrollersspec)]|true|none|none|

<h2 id="tocS_CloudImageMetadata">CloudImageMetadata</h2>
<!-- backwards compatibility -->
<a id="schemacloudimagemetadata"></a>
<a id="schema_CloudImageMetadata"></a>
<a id="tocScloudimagemetadata"></a>
<a id="tocscloudimagemetadata"></a>

```json
{
  "arch": "string",
  "image-id": "string",
  "priority": 0,
  "region": "string",
  "root-storage-size": 0,
  "root-storage-type": "string",
  "source": "string",
  "stream": "string",
  "version": "string",
  "virt-type": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|arch|string|true|none|none|
|image-id|string|true|none|none|
|priority|integer|true|none|none|
|region|string|true|none|none|
|root-storage-size|integer|false|none|none|
|root-storage-type|string|false|none|none|
|source|string|true|none|none|
|stream|string|false|none|none|
|version|string|true|none|none|
|virt-type|string|false|none|none|

<h2 id="tocS_CloudImageMetadataList">CloudImageMetadataList</h2>
<!-- backwards compatibility -->
<a id="schemacloudimagemetadatalist"></a>
<a id="schema_CloudImageMetadataList"></a>
<a id="tocScloudimagemetadatalist"></a>
<a id="tocscloudimagemetadatalist"></a>

```json
{
  "metadata": [
    {
      "arch": "string",
      "image-id": "string",
      "priority": 0,
      "region": "string",
      "root-storage-size": 0,
      "root-storage-type": "string",
      "source": "string",
      "stream": "string",
      "version": "string",
      "virt-type": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|metadata|[[CloudImageMetadata](#schemacloudimagemetadata)]|false|none|none|

<h2 id="tocS_ImageMetadataFilter">ImageMetadataFilter</h2>
<!-- backwards compatibility -->
<a id="schemaimagemetadatafilter"></a>
<a id="schema_ImageMetadataFilter"></a>
<a id="tocSimagemetadatafilter"></a>
<a id="tocsimagemetadatafilter"></a>

```json
{
  "arches": [
    "string"
  ],
  "region": "string",
  "root-storage-type": "string",
  "stream": "string",
  "versions": [
    "string"
  ],
  "virt-type": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|arches|[string]|false|none|none|
|region|string|false|none|none|
|root-storage-type|string|false|none|none|
|stream|string|false|none|none|
|versions|[string]|false|none|none|
|virt-type|string|false|none|none|

<h2 id="tocS_ListCloudImageMetadataResult">ListCloudImageMetadataResult</h2>
<!-- backwards compatibility -->
<a id="schemalistcloudimagemetadataresult"></a>
<a id="schema_ListCloudImageMetadataResult"></a>
<a id="tocSlistcloudimagemetadataresult"></a>
<a id="tocslistcloudimagemetadataresult"></a>

```json
{
  "result": [
    {
      "arch": "string",
      "image-id": "string",
      "priority": 0,
      "region": "string",
      "root-storage-size": 0,
      "root-storage-type": "string",
      "source": "string",
      "stream": "string",
      "version": "string",
      "virt-type": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|result|[[CloudImageMetadata](#schemacloudimagemetadata)]|true|none|none|

<h2 id="tocS_MetadataImageIds">MetadataImageIds</h2>
<!-- backwards compatibility -->
<a id="schemametadataimageids"></a>
<a id="schema_MetadataImageIds"></a>
<a id="tocSmetadataimageids"></a>
<a id="tocsmetadataimageids"></a>

```json
{
  "image-ids": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|image-ids|[string]|true|none|none|

<h2 id="tocS_MetadataSaveParams">MetadataSaveParams</h2>
<!-- backwards compatibility -->
<a id="schemametadatasaveparams"></a>
<a id="schema_MetadataSaveParams"></a>
<a id="tocSmetadatasaveparams"></a>
<a id="tocsmetadatasaveparams"></a>

```json
{
  "metadata": [
    {
      "metadata": [
        {
          "arch": "string",
          "image-id": "string",
          "priority": 0,
          "region": "string",
          "root-storage-size": 0,
          "root-storage-type": "string",
          "source": "string",
          "stream": "string",
          "version": "string",
          "virt-type": "string"
        }
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|metadata|[[CloudImageMetadataList](#schemacloudimagemetadatalist)]|false|none|none|

<h2 id="tocS_ListSSHKeys">ListSSHKeys</h2>
<!-- backwards compatibility -->
<a id="schemalistsshkeys"></a>
<a id="schema_ListSSHKeys"></a>
<a id="tocSlistsshkeys"></a>
<a id="tocslistsshkeys"></a>

```json
{
  "entities": {
    "entities": [
      {
        "tag": "string"
      }
    ]
  },
  "mode": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|entities|[Entities](#schemaentities)|true|none|none|
|mode|boolean|true|none|none|

<h2 id="tocS_ModifyUserSSHKeys">ModifyUserSSHKeys</h2>
<!-- backwards compatibility -->
<a id="schemamodifyusersshkeys"></a>
<a id="schema_ModifyUserSSHKeys"></a>
<a id="tocSmodifyusersshkeys"></a>
<a id="tocsmodifyusersshkeys"></a>

```json
{
  "ssh-keys": [
    "string"
  ],
  "user": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|ssh-keys|[string]|true|none|none|
|user|string|true|none|none|

<h2 id="tocS_AddMachineParams">AddMachineParams</h2>
<!-- backwards compatibility -->
<a id="schemaaddmachineparams"></a>
<a id="schema_AddMachineParams"></a>
<a id="tocSaddmachineparams"></a>
<a id="tocsaddmachineparams"></a>

```json
{
  "addresses": [
    {
      "cidr": "string",
      "config-type": "string",
      "is-secondary": true,
      "scope": "string",
      "space-id": "string",
      "space-name": "string",
      "type": "string",
      "value": "string"
    }
  ],
  "base": {
    "channel": "string",
    "name": "string"
  },
  "constraints": {
    "allocate-public-ip": true,
    "arch": "string",
    "container": "string",
    "cores": 0,
    "cpu-power": 0,
    "image-id": "string",
    "instance-role": "string",
    "instance-type": "string",
    "mem": 0,
    "root-disk": 0,
    "root-disk-source": "string",
    "spaces": [
      "string"
    ],
    "tags": [
      "string"
    ],
    "virt-type": "string",
    "zones": [
      "string"
    ]
  },
  "container-type": "string",
  "disks": [
    {
      "Count": 0,
      "Pool": "string",
      "Size": 0
    }
  ],
  "hardware-characteristics": {
    "arch": "string",
    "availability-zone": "string",
    "cpu-cores": 0,
    "cpu-power": 0,
    "mem": 0,
    "root-disk": 0,
    "root-disk-source": "string",
    "tags": [
      "string"
    ],
    "virt-type": "string"
  },
  "instance-id": "string",
  "jobs": [
    "string"
  ],
  "nonce": "string",
  "parent-id": "string",
  "placement": {
    "directive": "string",
    "scope": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|addresses|[[Address](#schemaaddress)]|true|none|none|
|base|[Base](#schemabase)|false|none|none|
|constraints|[Value](#schemavalue)|true|none|none|
|container-type|string|true|none|none|
|disks|[[Constraints](#schemaconstraints)]|false|none|none|
|hardware-characteristics|[HardwareCharacteristics](#schemahardwarecharacteristics)|true|none|none|
|instance-id|string|true|none|none|
|jobs|[string]|true|none|none|
|nonce|string|true|none|none|
|parent-id|string|true|none|none|
|placement|[Placement](#schemaplacement)|false|none|none|

<h2 id="tocS_AddMachines">AddMachines</h2>
<!-- backwards compatibility -->
<a id="schemaaddmachines"></a>
<a id="schema_AddMachines"></a>
<a id="tocSaddmachines"></a>
<a id="tocsaddmachines"></a>

```json
{
  "params": [
    {
      "addresses": [
        {
          "cidr": "string",
          "config-type": "string",
          "is-secondary": true,
          "scope": "string",
          "space-id": "string",
          "space-name": "string",
          "type": "string",
          "value": "string"
        }
      ],
      "base": {
        "channel": "string",
        "name": "string"
      },
      "constraints": {
        "allocate-public-ip": true,
        "arch": "string",
        "container": "string",
        "cores": 0,
        "cpu-power": 0,
        "image-id": "string",
        "instance-role": "string",
        "instance-type": "string",
        "mem": 0,
        "root-disk": 0,
        "root-disk-source": "string",
        "spaces": [
          "string"
        ],
        "tags": [
          "string"
        ],
        "virt-type": "string",
        "zones": [
          "string"
        ]
      },
      "container-type": "string",
      "disks": [
        {
          "Count": 0,
          "Pool": "string",
          "Size": 0
        }
      ],
      "hardware-characteristics": {
        "arch": "string",
        "availability-zone": "string",
        "cpu-cores": 0,
        "cpu-power": 0,
        "mem": 0,
        "root-disk": 0,
        "root-disk-source": "string",
        "tags": [
          "string"
        ],
        "virt-type": "string"
      },
      "instance-id": "string",
      "jobs": [
        "string"
      ],
      "nonce": "string",
      "parent-id": "string",
      "placement": {
        "directive": "string",
        "scope": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|params|[[AddMachineParams](#schemaaddmachineparams)]|true|none|none|

<h2 id="tocS_AddMachinesResult">AddMachinesResult</h2>
<!-- backwards compatibility -->
<a id="schemaaddmachinesresult"></a>
<a id="schema_AddMachinesResult"></a>
<a id="tocSaddmachinesresult"></a>
<a id="tocsaddmachinesresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "machine": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|machine|string|true|none|none|

<h2 id="tocS_AddMachinesResults">AddMachinesResults</h2>
<!-- backwards compatibility -->
<a id="schemaaddmachinesresults"></a>
<a id="schema_AddMachinesResults"></a>
<a id="tocSaddmachinesresults"></a>
<a id="tocsaddmachinesresults"></a>

```json
{
  "machines": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "machine": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|machines|[[AddMachinesResult](#schemaaddmachinesresult)]|true|none|none|

<h2 id="tocS_DestroyMachineInfo">DestroyMachineInfo</h2>
<!-- backwards compatibility -->
<a id="schemadestroymachineinfo"></a>
<a id="schema_DestroyMachineInfo"></a>
<a id="tocSdestroymachineinfo"></a>
<a id="tocsdestroymachineinfo"></a>

```json
{
  "destroyed-containers": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "info": {
        "destroyed-containers": [],
        "destroyed-storage": [
          {
            "tag": "string"
          }
        ],
        "destroyed-units": [
          {
            "tag": "string"
          }
        ],
        "detached-storage": [
          {
            "tag": "string"
          }
        ],
        "machine-id": "string"
      }
    }
  ],
  "destroyed-storage": [
    {
      "tag": "string"
    }
  ],
  "destroyed-units": [
    {
      "tag": "string"
    }
  ],
  "detached-storage": [
    {
      "tag": "string"
    }
  ],
  "machine-id": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|destroyed-containers|[[DestroyMachineResult](#schemadestroymachineresult)]|false|none|none|
|destroyed-storage|[[Entity](#schemaentity)]|false|none|none|
|destroyed-units|[[Entity](#schemaentity)]|false|none|none|
|detached-storage|[[Entity](#schemaentity)]|false|none|none|
|machine-id|string|true|none|none|

<h2 id="tocS_DestroyMachineResult">DestroyMachineResult</h2>
<!-- backwards compatibility -->
<a id="schemadestroymachineresult"></a>
<a id="schema_DestroyMachineResult"></a>
<a id="tocSdestroymachineresult"></a>
<a id="tocsdestroymachineresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "info": {
    "destroyed-containers": [
      {
        "error": {
          "code": "string",
          "info": {},
          "message": "string"
        },
        "info": {}
      }
    ],
    "destroyed-storage": [
      {
        "tag": "string"
      }
    ],
    "destroyed-units": [
      {
        "tag": "string"
      }
    ],
    "detached-storage": [
      {
        "tag": "string"
      }
    ],
    "machine-id": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|info|[DestroyMachineInfo](#schemadestroymachineinfo)|false|none|none|

<h2 id="tocS_DestroyMachineResults">DestroyMachineResults</h2>
<!-- backwards compatibility -->
<a id="schemadestroymachineresults"></a>
<a id="schema_DestroyMachineResults"></a>
<a id="tocSdestroymachineresults"></a>
<a id="tocsdestroymachineresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "info": {
        "destroyed-containers": [
          {}
        ],
        "destroyed-storage": [
          {
            "tag": "string"
          }
        ],
        "destroyed-units": [
          {
            "tag": "string"
          }
        ],
        "detached-storage": [
          {
            "tag": "string"
          }
        ],
        "machine-id": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[DestroyMachineResult](#schemadestroymachineresult)]|false|none|none|

<h2 id="tocS_DestroyMachinesParams">DestroyMachinesParams</h2>
<!-- backwards compatibility -->
<a id="schemadestroymachinesparams"></a>
<a id="schema_DestroyMachinesParams"></a>
<a id="tocSdestroymachinesparams"></a>
<a id="tocsdestroymachinesparams"></a>

```json
{
  "dry-run": true,
  "force": true,
  "keep": true,
  "machine-tags": [
    "string"
  ],
  "max-wait": 0
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|dry-run|boolean|false|none|none|
|force|boolean|false|none|none|
|keep|boolean|false|none|none|
|machine-tags|[string]|true|none|none|
|max-wait|integer|false|none|none|

<h2 id="tocS_HardwareCharacteristics">HardwareCharacteristics</h2>
<!-- backwards compatibility -->
<a id="schemahardwarecharacteristics"></a>
<a id="schema_HardwareCharacteristics"></a>
<a id="tocShardwarecharacteristics"></a>
<a id="tocshardwarecharacteristics"></a>

```json
{
  "arch": "string",
  "availability-zone": "string",
  "cpu-cores": 0,
  "cpu-power": 0,
  "mem": 0,
  "root-disk": 0,
  "root-disk-source": "string",
  "tags": [
    "string"
  ],
  "virt-type": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|arch|string|false|none|none|
|availability-zone|string|false|none|none|
|cpu-cores|integer|false|none|none|
|cpu-power|integer|false|none|none|
|mem|integer|false|none|none|
|root-disk|integer|false|none|none|
|root-disk-source|string|false|none|none|
|tags|[string]|false|none|none|
|virt-type|string|false|none|none|

<h2 id="tocS_ModelInstanceTypesConstraint">ModelInstanceTypesConstraint</h2>
<!-- backwards compatibility -->
<a id="schemamodelinstancetypesconstraint"></a>
<a id="schema_ModelInstanceTypesConstraint"></a>
<a id="tocSmodelinstancetypesconstraint"></a>
<a id="tocsmodelinstancetypesconstraint"></a>

```json
{
  "value": {
    "allocate-public-ip": true,
    "arch": "string",
    "container": "string",
    "cores": 0,
    "cpu-power": 0,
    "image-id": "string",
    "instance-role": "string",
    "instance-type": "string",
    "mem": 0,
    "root-disk": 0,
    "root-disk-source": "string",
    "spaces": [
      "string"
    ],
    "tags": [
      "string"
    ],
    "virt-type": "string",
    "zones": [
      "string"
    ]
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|value|[Value](#schemavalue)|false|none|none|

<h2 id="tocS_ModelInstanceTypesConstraints">ModelInstanceTypesConstraints</h2>
<!-- backwards compatibility -->
<a id="schemamodelinstancetypesconstraints"></a>
<a id="schema_ModelInstanceTypesConstraints"></a>
<a id="tocSmodelinstancetypesconstraints"></a>
<a id="tocsmodelinstancetypesconstraints"></a>

```json
{
  "constraints": [
    {
      "value": {
        "allocate-public-ip": true,
        "arch": "string",
        "container": "string",
        "cores": 0,
        "cpu-power": 0,
        "image-id": "string",
        "instance-role": "string",
        "instance-type": "string",
        "mem": 0,
        "root-disk": 0,
        "root-disk-source": "string",
        "spaces": [
          "string"
        ],
        "tags": [
          "string"
        ],
        "virt-type": "string",
        "zones": [
          "string"
        ]
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|constraints|[[ModelInstanceTypesConstraint](#schemamodelinstancetypesconstraint)]|true|none|none|

<h2 id="tocS_ProvisioningScriptParams">ProvisioningScriptParams</h2>
<!-- backwards compatibility -->
<a id="schemaprovisioningscriptparams"></a>
<a id="schema_ProvisioningScriptParams"></a>
<a id="tocSprovisioningscriptparams"></a>
<a id="tocsprovisioningscriptparams"></a>

```json
{
  "data-dir": "string",
  "disable-package-commands": true,
  "machine-id": "string",
  "nonce": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|data-dir|string|true|none|none|
|disable-package-commands|boolean|true|none|none|
|machine-id|string|true|none|none|
|nonce|string|true|none|none|

<h2 id="tocS_ProvisioningScriptResult">ProvisioningScriptResult</h2>
<!-- backwards compatibility -->
<a id="schemaprovisioningscriptresult"></a>
<a id="schema_ProvisioningScriptResult"></a>
<a id="tocSprovisioningscriptresult"></a>
<a id="tocsprovisioningscriptresult"></a>

```json
{
  "script": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|script|string|true|none|none|

<h2 id="tocS_RetryProvisioningArgs">RetryProvisioningArgs</h2>
<!-- backwards compatibility -->
<a id="schemaretryprovisioningargs"></a>
<a id="schema_RetryProvisioningArgs"></a>
<a id="tocSretryprovisioningargs"></a>
<a id="tocsretryprovisioningargs"></a>

```json
{
  "all": true,
  "machines": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|all|boolean|true|none|none|
|machines|[string]|false|none|none|

<h2 id="tocS_UpgradeSeriesNotificationParam">UpgradeSeriesNotificationParam</h2>
<!-- backwards compatibility -->
<a id="schemaupgradeseriesnotificationparam"></a>
<a id="schema_UpgradeSeriesNotificationParam"></a>
<a id="tocSupgradeseriesnotificationparam"></a>
<a id="tocsupgradeseriesnotificationparam"></a>

```json
{
  "entity": {
    "tag": "string"
  },
  "watcher-id": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|entity|[Entity](#schemaentity)|true|none|none|
|watcher-id|string|true|none|none|

<h2 id="tocS_UpgradeSeriesNotificationParams">UpgradeSeriesNotificationParams</h2>
<!-- backwards compatibility -->
<a id="schemaupgradeseriesnotificationparams"></a>
<a id="schema_UpgradeSeriesNotificationParams"></a>
<a id="tocSupgradeseriesnotificationparams"></a>
<a id="tocsupgradeseriesnotificationparams"></a>

```json
{
  "params": [
    {
      "entity": {
        "tag": "string"
      },
      "watcher-id": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|params|[[UpgradeSeriesNotificationParam](#schemaupgradeseriesnotificationparam)]|true|none|none|

<h2 id="tocS_UpgradeSeriesUnitsResult">UpgradeSeriesUnitsResult</h2>
<!-- backwards compatibility -->
<a id="schemaupgradeseriesunitsresult"></a>
<a id="schema_UpgradeSeriesUnitsResult"></a>
<a id="tocSupgradeseriesunitsresult"></a>
<a id="tocsupgradeseriesunitsresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "unit-names": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|unit-names|[string]|true|none|none|

<h2 id="tocS_UpgradeSeriesUnitsResults">UpgradeSeriesUnitsResults</h2>
<!-- backwards compatibility -->
<a id="schemaupgradeseriesunitsresults"></a>
<a id="schema_UpgradeSeriesUnitsResults"></a>
<a id="tocSupgradeseriesunitsresults"></a>
<a id="tocsupgradeseriesunitsresults"></a>

```json
{
  "Results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "unit-names": [
        "string"
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|Results|[[UpgradeSeriesUnitsResult](#schemaupgradeseriesunitsresult)]|true|none|none|

<h2 id="tocS_EntityMetrics">EntityMetrics</h2>
<!-- backwards compatibility -->
<a id="schemaentitymetrics"></a>
<a id="schema_EntityMetrics"></a>
<a id="tocSentitymetrics"></a>
<a id="tocsentitymetrics"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "metrics": [
    {
      "key": "string",
      "labels": {},
      "time": "2019-08-24T14:15:22Z",
      "unit": "string",
      "value": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|metrics|[[MetricResult](#schemametricresult)]|false|none|none|

<h2 id="tocS_MeterStatusParam">MeterStatusParam</h2>
<!-- backwards compatibility -->
<a id="schemameterstatusparam"></a>
<a id="schema_MeterStatusParam"></a>
<a id="tocSmeterstatusparam"></a>
<a id="tocsmeterstatusparam"></a>

```json
{
  "code": "string",
  "info": "string",
  "tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|code|string|true|none|none|
|info|string|false|none|none|
|tag|string|true|none|none|

<h2 id="tocS_MeterStatusParams">MeterStatusParams</h2>
<!-- backwards compatibility -->
<a id="schemameterstatusparams"></a>
<a id="schema_MeterStatusParams"></a>
<a id="tocSmeterstatusparams"></a>
<a id="tocsmeterstatusparams"></a>

```json
{
  "statues": [
    {
      "code": "string",
      "info": "string",
      "tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|statues|[[MeterStatusParam](#schemameterstatusparam)]|true|none|none|

<h2 id="tocS_MetricResult">MetricResult</h2>
<!-- backwards compatibility -->
<a id="schemametricresult"></a>
<a id="schema_MetricResult"></a>
<a id="tocSmetricresult"></a>
<a id="tocsmetricresult"></a>

```json
{
  "key": "string",
  "labels": {},
  "time": "2019-08-24T14:15:22Z",
  "unit": "string",
  "value": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|key|string|true|none|none|
|labels|object|true|none|none|
|» .*|string|false|none|none|
|time|string(date-time)|true|none|none|
|unit|string|true|none|none|
|value|string|true|none|none|

<h2 id="tocS_MetricResults">MetricResults</h2>
<!-- backwards compatibility -->
<a id="schemametricresults"></a>
<a id="schema_MetricResults"></a>
<a id="tocSmetricresults"></a>
<a id="tocsmetricresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "metrics": [
        {
          "key": "string",
          "labels": {},
          "time": "2019-08-24T14:15:22Z",
          "unit": "string",
          "value": "string"
        }
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[EntityMetrics](#schemaentitymetrics)]|true|none|none|

<h2 id="tocS_GetConstraintsResults">GetConstraintsResults</h2>
<!-- backwards compatibility -->
<a id="schemagetconstraintsresults"></a>
<a id="schema_GetConstraintsResults"></a>
<a id="tocSgetconstraintsresults"></a>
<a id="tocsgetconstraintsresults"></a>

```json
{
  "constraints": {
    "allocate-public-ip": true,
    "arch": "string",
    "container": "string",
    "cores": 0,
    "cpu-power": 0,
    "image-id": "string",
    "instance-role": "string",
    "instance-type": "string",
    "mem": 0,
    "root-disk": 0,
    "root-disk-source": "string",
    "spaces": [
      "string"
    ],
    "tags": [
      "string"
    ],
    "virt-type": "string",
    "zones": [
      "string"
    ]
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|constraints|[Value](#schemavalue)|true|none|none|

<h2 id="tocS_ModelSLA">ModelSLA</h2>
<!-- backwards compatibility -->
<a id="schemamodelsla"></a>
<a id="schema_ModelSLA"></a>
<a id="tocSmodelsla"></a>
<a id="tocsmodelsla"></a>

```json
{
  "ModelSLAInfo": {
    "level": "string",
    "owner": "string"
  },
  "creds": [
    0
  ],
  "level": "string",
  "owner": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|ModelSLAInfo|[ModelSLAInfo](#schemamodelslainfo)|true|none|none|
|creds|[integer]|true|none|none|
|level|string|true|none|none|
|owner|string|true|none|none|

<h2 id="tocS_ModelSLAInfo">ModelSLAInfo</h2>
<!-- backwards compatibility -->
<a id="schemamodelslainfo"></a>
<a id="schema_ModelSLAInfo"></a>
<a id="tocSmodelslainfo"></a>
<a id="tocsmodelslainfo"></a>

```json
{
  "level": "string",
  "owner": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|level|string|true|none|none|
|owner|string|true|none|none|

<h2 id="tocS_ModelSequencesResult">ModelSequencesResult</h2>
<!-- backwards compatibility -->
<a id="schemamodelsequencesresult"></a>
<a id="schema_ModelSequencesResult"></a>
<a id="tocSmodelsequencesresult"></a>
<a id="tocsmodelsequencesresult"></a>

```json
{
  "sequences": {}
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|sequences|object|true|none|none|
|» .*|integer|false|none|none|

<h2 id="tocS_ModelSet">ModelSet</h2>
<!-- backwards compatibility -->
<a id="schemamodelset"></a>
<a id="schema_ModelSet"></a>
<a id="tocSmodelset"></a>
<a id="tocsmodelset"></a>

```json
{
  "config": {}
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|config|object|true|none|none|
|» .*|object|false|none|none|

<h2 id="tocS_ModelUnset">ModelUnset</h2>
<!-- backwards compatibility -->
<a id="schemamodelunset"></a>
<a id="schema_ModelUnset"></a>
<a id="tocSmodelunset"></a>
<a id="tocsmodelunset"></a>

```json
{
  "keys": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|keys|[string]|true|none|none|

<h2 id="tocS_BoolResult">BoolResult</h2>
<!-- backwards compatibility -->
<a id="schemaboolresult"></a>
<a id="schema_BoolResult"></a>
<a id="tocSboolresult"></a>
<a id="tocsboolresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|result|boolean|true|none|none|

<h2 id="tocS_BranchArg">BranchArg</h2>
<!-- backwards compatibility -->
<a id="schemabrancharg"></a>
<a id="schema_BranchArg"></a>
<a id="tocSbrancharg"></a>
<a id="tocsbrancharg"></a>

```json
{
  "branch": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|branch|string|true|none|none|

<h2 id="tocS_BranchInfoArgs">BranchInfoArgs</h2>
<!-- backwards compatibility -->
<a id="schemabranchinfoargs"></a>
<a id="schema_BranchInfoArgs"></a>
<a id="tocSbranchinfoargs"></a>
<a id="tocsbranchinfoargs"></a>

```json
{
  "branches": [
    "string"
  ],
  "detailed": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|branches|[string]|true|none|none|
|detailed|boolean|true|none|none|

<h2 id="tocS_BranchResults">BranchResults</h2>
<!-- backwards compatibility -->
<a id="schemabranchresults"></a>
<a id="schema_BranchResults"></a>
<a id="tocSbranchresults"></a>
<a id="tocsbranchresults"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "generations": [
    {
      "applications": [
        {
          "application": "string",
          "config": {},
          "pending": [
            "string"
          ],
          "progress": "string",
          "tracking": [
            "string"
          ]
        }
      ],
      "branch": "string",
      "completed": 0,
      "completed-by": "string",
      "created": 0,
      "created-by": "string",
      "generation-id": 0
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|generations|[[Generation](#schemageneration)]|true|none|none|

<h2 id="tocS_BranchTrackArg">BranchTrackArg</h2>
<!-- backwards compatibility -->
<a id="schemabranchtrackarg"></a>
<a id="schema_BranchTrackArg"></a>
<a id="tocSbranchtrackarg"></a>
<a id="tocsbranchtrackarg"></a>

```json
{
  "branch": "string",
  "entities": [
    {
      "tag": "string"
    }
  ],
  "num-units": 0
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|branch|string|true|none|none|
|entities|[[Entity](#schemaentity)]|true|none|none|
|num-units|integer|false|none|none|

<h2 id="tocS_Generation">Generation</h2>
<!-- backwards compatibility -->
<a id="schemageneration"></a>
<a id="schema_Generation"></a>
<a id="tocSgeneration"></a>
<a id="tocsgeneration"></a>

```json
{
  "applications": [
    {
      "application": "string",
      "config": {},
      "pending": [
        "string"
      ],
      "progress": "string",
      "tracking": [
        "string"
      ]
    }
  ],
  "branch": "string",
  "completed": 0,
  "completed-by": "string",
  "created": 0,
  "created-by": "string",
  "generation-id": 0
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|applications|[[GenerationApplication](#schemagenerationapplication)]|true|none|none|
|branch|string|true|none|none|
|completed|integer|false|none|none|
|completed-by|string|false|none|none|
|created|integer|true|none|none|
|created-by|string|true|none|none|
|generation-id|integer|false|none|none|

<h2 id="tocS_GenerationApplication">GenerationApplication</h2>
<!-- backwards compatibility -->
<a id="schemagenerationapplication"></a>
<a id="schema_GenerationApplication"></a>
<a id="tocSgenerationapplication"></a>
<a id="tocsgenerationapplication"></a>

```json
{
  "application": "string",
  "config": {},
  "pending": [
    "string"
  ],
  "progress": "string",
  "tracking": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|application|string|true|none|none|
|config|object|true|none|none|
|» .*|object|false|none|none|
|pending|[string]|false|none|none|
|progress|string|true|none|none|
|tracking|[string]|false|none|none|

<h2 id="tocS_GenerationId">GenerationId</h2>
<!-- backwards compatibility -->
<a id="schemagenerationid"></a>
<a id="schema_GenerationId"></a>
<a id="tocSgenerationid"></a>
<a id="tocsgenerationid"></a>

```json
{
  "generation-id": 0
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|generation-id|integer|true|none|none|

<h2 id="tocS_GenerationResult">GenerationResult</h2>
<!-- backwards compatibility -->
<a id="schemagenerationresult"></a>
<a id="schema_GenerationResult"></a>
<a id="tocSgenerationresult"></a>
<a id="tocsgenerationresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "generation": {
    "applications": [
      {
        "application": "string",
        "config": {},
        "pending": [
          "string"
        ],
        "progress": "string",
        "tracking": [
          "string"
        ]
      }
    ],
    "branch": "string",
    "completed": 0,
    "completed-by": "string",
    "created": 0,
    "created-by": "string",
    "generation-id": 0
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|generation|[Generation](#schemageneration)|true|none|none|

<h2 id="tocS_IntResult">IntResult</h2>
<!-- backwards compatibility -->
<a id="schemaintresult"></a>
<a id="schema_IntResult"></a>
<a id="tocSintresult"></a>
<a id="tocsintresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": 0
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|result|integer|true|none|none|

<h2 id="tocS_ChangeModelCredentialParams">ChangeModelCredentialParams</h2>
<!-- backwards compatibility -->
<a id="schemachangemodelcredentialparams"></a>
<a id="schema_ChangeModelCredentialParams"></a>
<a id="tocSchangemodelcredentialparams"></a>
<a id="tocschangemodelcredentialparams"></a>

```json
{
  "credential-tag": "string",
  "model-tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|credential-tag|string|true|none|none|
|model-tag|string|true|none|none|

<h2 id="tocS_ChangeModelCredentialsParams">ChangeModelCredentialsParams</h2>
<!-- backwards compatibility -->
<a id="schemachangemodelcredentialsparams"></a>
<a id="schema_ChangeModelCredentialsParams"></a>
<a id="tocSchangemodelcredentialsparams"></a>
<a id="tocschangemodelcredentialsparams"></a>

```json
{
  "model-credentials": [
    {
      "credential-tag": "string",
      "model-tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|model-credentials|[[ChangeModelCredentialParams](#schemachangemodelcredentialparams)]|true|none|none|

<h2 id="tocS_DestroyModelParams">DestroyModelParams</h2>
<!-- backwards compatibility -->
<a id="schemadestroymodelparams"></a>
<a id="schema_DestroyModelParams"></a>
<a id="tocSdestroymodelparams"></a>
<a id="tocsdestroymodelparams"></a>

```json
{
  "destroy-storage": true,
  "force": true,
  "max-wait": 0,
  "model-tag": "string",
  "timeout": 0
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|destroy-storage|boolean|false|none|none|
|force|boolean|false|none|none|
|max-wait|integer|false|none|none|
|model-tag|string|true|none|none|
|timeout|integer|false|none|none|

<h2 id="tocS_DestroyModelsParams">DestroyModelsParams</h2>
<!-- backwards compatibility -->
<a id="schemadestroymodelsparams"></a>
<a id="schema_DestroyModelsParams"></a>
<a id="tocSdestroymodelsparams"></a>
<a id="tocsdestroymodelsparams"></a>

```json
{
  "models": [
    {
      "destroy-storage": true,
      "force": true,
      "max-wait": 0,
      "model-tag": "string",
      "timeout": 0
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|models|[[DestroyModelParams](#schemadestroymodelparams)]|true|none|none|

<h2 id="tocS_DumpModelRequest">DumpModelRequest</h2>
<!-- backwards compatibility -->
<a id="schemadumpmodelrequest"></a>
<a id="schema_DumpModelRequest"></a>
<a id="tocSdumpmodelrequest"></a>
<a id="tocsdumpmodelrequest"></a>

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ],
  "simplified": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|entities|[[Entity](#schemaentity)]|true|none|none|
|simplified|boolean|true|none|none|

<h2 id="tocS_MapResult">MapResult</h2>
<!-- backwards compatibility -->
<a id="schemamapresult"></a>
<a id="schema_MapResult"></a>
<a id="tocSmapresult"></a>
<a id="tocsmapresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": {}
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|result|object|true|none|none|
|» .*|object|false|none|none|

<h2 id="tocS_MapResults">MapResults</h2>
<!-- backwards compatibility -->
<a id="schemamapresults"></a>
<a id="schema_MapResults"></a>
<a id="tocSmapresults"></a>
<a id="tocsmapresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {}
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[MapResult](#schemamapresult)]|true|none|none|

<h2 id="tocS_ModelCreateArgs">ModelCreateArgs</h2>
<!-- backwards compatibility -->
<a id="schemamodelcreateargs"></a>
<a id="schema_ModelCreateArgs"></a>
<a id="tocSmodelcreateargs"></a>
<a id="tocsmodelcreateargs"></a>

```json
{
  "cloud-tag": "string",
  "config": {},
  "credential": "string",
  "name": "string",
  "owner-tag": "string",
  "region": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|cloud-tag|string|false|none|none|
|config|object|false|none|none|
|» .*|object|false|none|none|
|credential|string|false|none|none|
|name|string|true|none|none|
|owner-tag|string|true|none|none|
|region|string|false|none|none|

<h2 id="tocS_ModelDefaultValues">ModelDefaultValues</h2>
<!-- backwards compatibility -->
<a id="schemamodeldefaultvalues"></a>
<a id="schema_ModelDefaultValues"></a>
<a id="tocSmodeldefaultvalues"></a>
<a id="tocsmodeldefaultvalues"></a>

```json
{
  "cloud-region": "string",
  "cloud-tag": "string",
  "config": {}
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|cloud-region|string|false|none|none|
|cloud-tag|string|false|none|none|
|config|object|true|none|none|
|» .*|object|false|none|none|

<h2 id="tocS_ModelDefaults">ModelDefaults</h2>
<!-- backwards compatibility -->
<a id="schemamodeldefaults"></a>
<a id="schema_ModelDefaults"></a>
<a id="tocSmodeldefaults"></a>
<a id="tocsmodeldefaults"></a>

```json
{
  "controller": {},
  "default": {},
  "regions": [
    {
      "region-name": "string",
      "value": {}
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|controller|object|false|none|none|
|default|object|false|none|none|
|regions|[[RegionDefaults](#schemaregiondefaults)]|false|none|none|

<h2 id="tocS_ModelDefaultsResult">ModelDefaultsResult</h2>
<!-- backwards compatibility -->
<a id="schemamodeldefaultsresult"></a>
<a id="schema_ModelDefaultsResult"></a>
<a id="tocSmodeldefaultsresult"></a>
<a id="tocsmodeldefaultsresult"></a>

```json
{
  "config": {},
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|config|object|true|none|none|
|» .*|[ModelDefaults](#schemamodeldefaults)|false|none|none|
|error|[Error](#schemaerror)|false|none|none|

<h2 id="tocS_ModelDefaultsResults">ModelDefaultsResults</h2>
<!-- backwards compatibility -->
<a id="schemamodeldefaultsresults"></a>
<a id="schema_ModelDefaultsResults"></a>
<a id="tocSmodeldefaultsresults"></a>
<a id="tocsmodeldefaultsresults"></a>

```json
{
  "results": [
    {
      "config": {},
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[ModelDefaultsResult](#schemamodeldefaultsresult)]|true|none|none|

<h2 id="tocS_ModelEntityCount">ModelEntityCount</h2>
<!-- backwards compatibility -->
<a id="schemamodelentitycount"></a>
<a id="schema_ModelEntityCount"></a>
<a id="tocSmodelentitycount"></a>
<a id="tocsmodelentitycount"></a>

```json
{
  "count": 0,
  "entity": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|count|integer|true|none|none|
|entity|string|true|none|none|

<h2 id="tocS_ModelInfo">ModelInfo</h2>
<!-- backwards compatibility -->
<a id="schemamodelinfo"></a>
<a id="schema_ModelInfo"></a>
<a id="tocSmodelinfo"></a>
<a id="tocsmodelinfo"></a>

```json
{
  "agent-version": {
    "Build": 0,
    "Major": 0,
    "Minor": 0,
    "Patch": 0,
    "Tag": "string"
  },
  "cloud-credential-tag": "string",
  "cloud-credential-validity": true,
  "cloud-region": "string",
  "cloud-tag": "string",
  "controller-uuid": "string",
  "default-base": "string",
  "default-series": "string",
  "is-controller": true,
  "life": "string",
  "machines": [
    {
      "display-name": "string",
      "ha-primary": true,
      "hardware": {
        "arch": "string",
        "availability-zone": "string",
        "cores": 0,
        "cpu-power": 0,
        "mem": 0,
        "root-disk": 0,
        "tags": [
          "string"
        ],
        "virt-type": "string"
      },
      "has-vote": true,
      "id": "string",
      "instance-id": "string",
      "message": "string",
      "status": "string",
      "wants-vote": true
    }
  ],
  "migration": {
    "end": "2019-08-24T14:15:22Z",
    "start": "2019-08-24T14:15:22Z",
    "status": "string"
  },
  "name": "string",
  "owner-tag": "string",
  "provider-type": "string",
  "secret-backends": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "id": "string",
      "message": "string",
      "num-secrets": 0,
      "result": {
        "backend-type": "string",
        "config": {},
        "name": "string",
        "token-rotate-interval": 0
      },
      "status": "string"
    }
  ],
  "sla": {
    "level": "string",
    "owner": "string"
  },
  "status": {
    "data": {},
    "info": "string",
    "since": "2019-08-24T14:15:22Z",
    "status": "string"
  },
  "supported-features": [
    {
      "description": "string",
      "name": "string",
      "version": "string"
    }
  ],
  "type": "string",
  "users": [
    {
      "access": "string",
      "display-name": "string",
      "last-connection": "2019-08-24T14:15:22Z",
      "model-tag": "string",
      "user": "string"
    }
  ],
  "uuid": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|agent-version|[Number](#schemanumber)|true|none|none|
|cloud-credential-tag|string|false|none|none|
|cloud-credential-validity|boolean|false|none|none|
|cloud-region|string|false|none|none|
|cloud-tag|string|true|none|none|
|controller-uuid|string|true|none|none|
|default-base|string|false|none|none|
|default-series|string|false|none|none|
|is-controller|boolean|true|none|none|
|life|string|true|none|none|
|machines|[[ModelMachineInfo](#schemamodelmachineinfo)]|true|none|none|
|migration|[ModelMigrationStatus](#schemamodelmigrationstatus)|false|none|none|
|name|string|true|none|none|
|owner-tag|string|true|none|none|
|provider-type|string|false|none|none|
|secret-backends|[[SecretBackendResult](#schemasecretbackendresult)]|true|none|none|
|sla|[ModelSLAInfo](#schemamodelslainfo)|true|none|none|
|status|[EntityStatus](#schemaentitystatus)|false|none|none|
|supported-features|[[SupportedFeature](#schemasupportedfeature)]|false|none|none|
|type|string|true|none|none|
|users|[[ModelUserInfo](#schemamodeluserinfo)]|true|none|none|
|uuid|string|true|none|none|

<h2 id="tocS_ModelInfoResult">ModelInfoResult</h2>
<!-- backwards compatibility -->
<a id="schemamodelinforesult"></a>
<a id="schema_ModelInfoResult"></a>
<a id="tocSmodelinforesult"></a>
<a id="tocsmodelinforesult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": {
    "agent-version": {
      "Build": 0,
      "Major": 0,
      "Minor": 0,
      "Patch": 0,
      "Tag": "string"
    },
    "cloud-credential-tag": "string",
    "cloud-credential-validity": true,
    "cloud-region": "string",
    "cloud-tag": "string",
    "controller-uuid": "string",
    "default-base": "string",
    "default-series": "string",
    "is-controller": true,
    "life": "string",
    "machines": [
      {
        "display-name": "string",
        "ha-primary": true,
        "hardware": {
          "arch": "string",
          "availability-zone": "string",
          "cores": 0,
          "cpu-power": 0,
          "mem": 0,
          "root-disk": 0,
          "tags": [
            "string"
          ],
          "virt-type": "string"
        },
        "has-vote": true,
        "id": "string",
        "instance-id": "string",
        "message": "string",
        "status": "string",
        "wants-vote": true
      }
    ],
    "migration": {
      "end": "2019-08-24T14:15:22Z",
      "start": "2019-08-24T14:15:22Z",
      "status": "string"
    },
    "name": "string",
    "owner-tag": "string",
    "provider-type": "string",
    "secret-backends": [
      {
        "error": {
          "code": "string",
          "info": {},
          "message": "string"
        },
        "id": "string",
        "message": "string",
        "num-secrets": 0,
        "result": {
          "backend-type": "string",
          "config": {},
          "name": "string",
          "token-rotate-interval": 0
        },
        "status": "string"
      }
    ],
    "sla": {
      "level": "string",
      "owner": "string"
    },
    "status": {
      "data": {},
      "info": "string",
      "since": "2019-08-24T14:15:22Z",
      "status": "string"
    },
    "supported-features": [
      {
        "description": "string",
        "name": "string",
        "version": "string"
      }
    ],
    "type": "string",
    "users": [
      {
        "access": "string",
        "display-name": "string",
        "last-connection": "2019-08-24T14:15:22Z",
        "model-tag": "string",
        "user": "string"
      }
    ],
    "uuid": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|result|[ModelInfo](#schemamodelinfo)|false|none|none|

<h2 id="tocS_ModelInfoResults">ModelInfoResults</h2>
<!-- backwards compatibility -->
<a id="schemamodelinforesults"></a>
<a id="schema_ModelInfoResults"></a>
<a id="tocSmodelinforesults"></a>
<a id="tocsmodelinforesults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "agent-version": {
          "Build": 0,
          "Major": 0,
          "Minor": 0,
          "Patch": 0,
          "Tag": "string"
        },
        "cloud-credential-tag": "string",
        "cloud-credential-validity": true,
        "cloud-region": "string",
        "cloud-tag": "string",
        "controller-uuid": "string",
        "default-base": "string",
        "default-series": "string",
        "is-controller": true,
        "life": "string",
        "machines": [
          {
            "display-name": "string",
            "ha-primary": true,
            "hardware": {
              "arch": "string",
              "availability-zone": "string",
              "cores": 0,
              "cpu-power": 0,
              "mem": 0,
              "root-disk": 0,
              "tags": [
                "string"
              ],
              "virt-type": "string"
            },
            "has-vote": true,
            "id": "string",
            "instance-id": "string",
            "message": "string",
            "status": "string",
            "wants-vote": true
          }
        ],
        "migration": {
          "end": "2019-08-24T14:15:22Z",
          "start": "2019-08-24T14:15:22Z",
          "status": "string"
        },
        "name": "string",
        "owner-tag": "string",
        "provider-type": "string",
        "secret-backends": [
          {
            "error": {
              "code": "string",
              "info": {},
              "message": "string"
            },
            "id": "string",
            "message": "string",
            "num-secrets": 0,
            "result": {
              "backend-type": "string",
              "config": {},
              "name": "string",
              "token-rotate-interval": 0
            },
            "status": "string"
          }
        ],
        "sla": {
          "level": "string",
          "owner": "string"
        },
        "status": {
          "data": {},
          "info": "string",
          "since": "2019-08-24T14:15:22Z",
          "status": "string"
        },
        "supported-features": [
          {
            "description": "string",
            "name": "string",
            "version": "string"
          }
        ],
        "type": "string",
        "users": [
          {
            "access": "string",
            "display-name": "string",
            "last-connection": "2019-08-24T14:15:22Z",
            "model-tag": "string",
            "user": "string"
          }
        ],
        "uuid": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[ModelInfoResult](#schemamodelinforesult)]|true|none|none|

<h2 id="tocS_ModelMigrationStatus">ModelMigrationStatus</h2>
<!-- backwards compatibility -->
<a id="schemamodelmigrationstatus"></a>
<a id="schema_ModelMigrationStatus"></a>
<a id="tocSmodelmigrationstatus"></a>
<a id="tocsmodelmigrationstatus"></a>

```json
{
  "end": "2019-08-24T14:15:22Z",
  "start": "2019-08-24T14:15:22Z",
  "status": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|end|string(date-time)|false|none|none|
|start|string(date-time)|true|none|none|
|status|string|true|none|none|

<h2 id="tocS_ModelSummariesRequest">ModelSummariesRequest</h2>
<!-- backwards compatibility -->
<a id="schemamodelsummariesrequest"></a>
<a id="schema_ModelSummariesRequest"></a>
<a id="tocSmodelsummariesrequest"></a>
<a id="tocsmodelsummariesrequest"></a>

```json
{
  "all": true,
  "user-tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|all|boolean|false|none|none|
|user-tag|string|true|none|none|

<h2 id="tocS_ModelSummary">ModelSummary</h2>
<!-- backwards compatibility -->
<a id="schemamodelsummary"></a>
<a id="schema_ModelSummary"></a>
<a id="tocSmodelsummary"></a>
<a id="tocsmodelsummary"></a>

```json
{
  "agent-version": {
    "Build": 0,
    "Major": 0,
    "Minor": 0,
    "Patch": 0,
    "Tag": "string"
  },
  "cloud-credential-tag": "string",
  "cloud-region": "string",
  "cloud-tag": "string",
  "controller-uuid": "string",
  "counts": [
    {
      "count": 0,
      "entity": "string"
    }
  ],
  "default-series": "string",
  "is-controller": true,
  "last-connection": "2019-08-24T14:15:22Z",
  "life": "string",
  "migration": {
    "end": "2019-08-24T14:15:22Z",
    "start": "2019-08-24T14:15:22Z",
    "status": "string"
  },
  "name": "string",
  "owner-tag": "string",
  "provider-type": "string",
  "sla": {
    "level": "string",
    "owner": "string"
  },
  "status": {
    "data": {},
    "info": "string",
    "since": "2019-08-24T14:15:22Z",
    "status": "string"
  },
  "type": "string",
  "user-access": "string",
  "uuid": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|agent-version|[Number](#schemanumber)|true|none|none|
|cloud-credential-tag|string|false|none|none|
|cloud-region|string|false|none|none|
|cloud-tag|string|true|none|none|
|controller-uuid|string|true|none|none|
|counts|[[ModelEntityCount](#schemamodelentitycount)]|true|none|none|
|default-series|string|false|none|none|
|is-controller|boolean|true|none|none|
|last-connection|string(date-time)|true|none|none|
|life|string|true|none|none|
|migration|[ModelMigrationStatus](#schemamodelmigrationstatus)|false|none|none|
|name|string|true|none|none|
|owner-tag|string|true|none|none|
|provider-type|string|false|none|none|
|sla|[ModelSLAInfo](#schemamodelslainfo)|true|none|none|
|status|[EntityStatus](#schemaentitystatus)|false|none|none|
|type|string|true|none|none|
|user-access|string|true|none|none|
|uuid|string|true|none|none|

<h2 id="tocS_ModelSummaryResult">ModelSummaryResult</h2>
<!-- backwards compatibility -->
<a id="schemamodelsummaryresult"></a>
<a id="schema_ModelSummaryResult"></a>
<a id="tocSmodelsummaryresult"></a>
<a id="tocsmodelsummaryresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": {
    "agent-version": {
      "Build": 0,
      "Major": 0,
      "Minor": 0,
      "Patch": 0,
      "Tag": "string"
    },
    "cloud-credential-tag": "string",
    "cloud-region": "string",
    "cloud-tag": "string",
    "controller-uuid": "string",
    "counts": [
      {
        "count": 0,
        "entity": "string"
      }
    ],
    "default-series": "string",
    "is-controller": true,
    "last-connection": "2019-08-24T14:15:22Z",
    "life": "string",
    "migration": {
      "end": "2019-08-24T14:15:22Z",
      "start": "2019-08-24T14:15:22Z",
      "status": "string"
    },
    "name": "string",
    "owner-tag": "string",
    "provider-type": "string",
    "sla": {
      "level": "string",
      "owner": "string"
    },
    "status": {
      "data": {},
      "info": "string",
      "since": "2019-08-24T14:15:22Z",
      "status": "string"
    },
    "type": "string",
    "user-access": "string",
    "uuid": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|result|[ModelSummary](#schemamodelsummary)|false|none|none|

<h2 id="tocS_ModelSummaryResults">ModelSummaryResults</h2>
<!-- backwards compatibility -->
<a id="schemamodelsummaryresults"></a>
<a id="schema_ModelSummaryResults"></a>
<a id="tocSmodelsummaryresults"></a>
<a id="tocsmodelsummaryresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "agent-version": {
          "Build": 0,
          "Major": 0,
          "Minor": 0,
          "Patch": 0,
          "Tag": "string"
        },
        "cloud-credential-tag": "string",
        "cloud-region": "string",
        "cloud-tag": "string",
        "controller-uuid": "string",
        "counts": [
          {
            "count": 0,
            "entity": "string"
          }
        ],
        "default-series": "string",
        "is-controller": true,
        "last-connection": "2019-08-24T14:15:22Z",
        "life": "string",
        "migration": {
          "end": "2019-08-24T14:15:22Z",
          "start": "2019-08-24T14:15:22Z",
          "status": "string"
        },
        "name": "string",
        "owner-tag": "string",
        "provider-type": "string",
        "sla": {
          "level": "string",
          "owner": "string"
        },
        "status": {
          "data": {},
          "info": "string",
          "since": "2019-08-24T14:15:22Z",
          "status": "string"
        },
        "type": "string",
        "user-access": "string",
        "uuid": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[ModelSummaryResult](#schemamodelsummaryresult)]|true|none|none|

<h2 id="tocS_ModelUnsetKeys">ModelUnsetKeys</h2>
<!-- backwards compatibility -->
<a id="schemamodelunsetkeys"></a>
<a id="schema_ModelUnsetKeys"></a>
<a id="tocSmodelunsetkeys"></a>
<a id="tocsmodelunsetkeys"></a>

```json
{
  "cloud-region": "string",
  "cloud-tag": "string",
  "keys": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|cloud-region|string|false|none|none|
|cloud-tag|string|false|none|none|
|keys|[string]|true|none|none|

<h2 id="tocS_ModelUserInfo">ModelUserInfo</h2>
<!-- backwards compatibility -->
<a id="schemamodeluserinfo"></a>
<a id="schema_ModelUserInfo"></a>
<a id="tocSmodeluserinfo"></a>
<a id="tocsmodeluserinfo"></a>

```json
{
  "access": "string",
  "display-name": "string",
  "last-connection": "2019-08-24T14:15:22Z",
  "model-tag": "string",
  "user": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|access|string|true|none|none|
|display-name|string|true|none|none|
|last-connection|string(date-time)|true|none|none|
|model-tag|string|true|none|none|
|user|string|true|none|none|

<h2 id="tocS_ModifyModelAccess">ModifyModelAccess</h2>
<!-- backwards compatibility -->
<a id="schemamodifymodelaccess"></a>
<a id="schema_ModifyModelAccess"></a>
<a id="tocSmodifymodelaccess"></a>
<a id="tocsmodifymodelaccess"></a>

```json
{
  "access": "string",
  "action": "string",
  "model-tag": "string",
  "user-tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|access|string|true|none|none|
|action|string|true|none|none|
|model-tag|string|true|none|none|
|user-tag|string|true|none|none|

<h2 id="tocS_ModifyModelAccessRequest">ModifyModelAccessRequest</h2>
<!-- backwards compatibility -->
<a id="schemamodifymodelaccessrequest"></a>
<a id="schema_ModifyModelAccessRequest"></a>
<a id="tocSmodifymodelaccessrequest"></a>
<a id="tocsmodifymodelaccessrequest"></a>

```json
{
  "changes": [
    {
      "access": "string",
      "action": "string",
      "model-tag": "string",
      "user-tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|changes|[[ModifyModelAccess](#schemamodifymodelaccess)]|true|none|none|

<h2 id="tocS_RegionDefaults">RegionDefaults</h2>
<!-- backwards compatibility -->
<a id="schemaregiondefaults"></a>
<a id="schema_RegionDefaults"></a>
<a id="tocSregiondefaults"></a>
<a id="tocsregiondefaults"></a>

```json
{
  "region-name": "string",
  "value": {}
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|region-name|string|true|none|none|
|value|object|true|none|none|

<h2 id="tocS_SecretBackend">SecretBackend</h2>
<!-- backwards compatibility -->
<a id="schemasecretbackend"></a>
<a id="schema_SecretBackend"></a>
<a id="tocSsecretbackend"></a>
<a id="tocssecretbackend"></a>

```json
{
  "backend-type": "string",
  "config": {},
  "name": "string",
  "token-rotate-interval": 0
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|backend-type|string|true|none|none|
|config|object|true|none|none|
|» .*|object|false|none|none|
|name|string|true|none|none|
|token-rotate-interval|integer|false|none|none|

<h2 id="tocS_SecretBackendResult">SecretBackendResult</h2>
<!-- backwards compatibility -->
<a id="schemasecretbackendresult"></a>
<a id="schema_SecretBackendResult"></a>
<a id="tocSsecretbackendresult"></a>
<a id="tocssecretbackendresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "id": "string",
  "message": "string",
  "num-secrets": 0,
  "result": {
    "backend-type": "string",
    "config": {},
    "name": "string",
    "token-rotate-interval": 0
  },
  "status": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|id|string|true|none|none|
|message|string|false|none|none|
|num-secrets|integer|true|none|none|
|result|[SecretBackend](#schemasecretbackend)|true|none|none|
|status|string|true|none|none|

<h2 id="tocS_SetModelDefaults">SetModelDefaults</h2>
<!-- backwards compatibility -->
<a id="schemasetmodeldefaults"></a>
<a id="schema_SetModelDefaults"></a>
<a id="tocSsetmodeldefaults"></a>
<a id="tocssetmodeldefaults"></a>

```json
{
  "config": [
    {
      "cloud-region": "string",
      "cloud-tag": "string",
      "config": {}
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|config|[[ModelDefaultValues](#schemamodeldefaultvalues)]|true|none|none|

<h2 id="tocS_StringResults">StringResults</h2>
<!-- backwards compatibility -->
<a id="schemastringresults"></a>
<a id="schema_StringResults"></a>
<a id="tocSstringresults"></a>
<a id="tocsstringresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[StringResult](#schemastringresult)]|true|none|none|

<h2 id="tocS_SupportedFeature">SupportedFeature</h2>
<!-- backwards compatibility -->
<a id="schemasupportedfeature"></a>
<a id="schema_SupportedFeature"></a>
<a id="tocSsupportedfeature"></a>
<a id="tocssupportedfeature"></a>

```json
{
  "description": "string",
  "name": "string",
  "version": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|description|string|true|none|none|
|name|string|true|none|none|
|version|string|false|none|none|

<h2 id="tocS_UnsetModelDefaults">UnsetModelDefaults</h2>
<!-- backwards compatibility -->
<a id="schemaunsetmodeldefaults"></a>
<a id="schema_UnsetModelDefaults"></a>
<a id="tocSunsetmodeldefaults"></a>
<a id="tocsunsetmodeldefaults"></a>

```json
{
  "keys": [
    {
      "cloud-region": "string",
      "cloud-tag": "string",
      "keys": [
        "string"
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|keys|[[ModelUnsetKeys](#schemamodelunsetkeys)]|true|none|none|

<h2 id="tocS_ModelParam">ModelParam</h2>
<!-- backwards compatibility -->
<a id="schemamodelparam"></a>
<a id="schema_ModelParam"></a>
<a id="tocSmodelparam"></a>
<a id="tocsmodelparam"></a>

```json
{
  "model-tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|model-tag|string|true|none|none|

<h2 id="tocS_UpgradeModelParams">UpgradeModelParams</h2>
<!-- backwards compatibility -->
<a id="schemaupgrademodelparams"></a>
<a id="schema_UpgradeModelParams"></a>
<a id="tocSupgrademodelparams"></a>
<a id="tocsupgrademodelparams"></a>

```json
{
  "agent-stream": "string",
  "dry-run": true,
  "ignore-agent-versions": true,
  "model-tag": "string",
  "target-version": {
    "Build": 0,
    "Major": 0,
    "Minor": 0,
    "Patch": 0,
    "Tag": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|agent-stream|string|false|none|none|
|dry-run|boolean|false|none|none|
|ignore-agent-versions|boolean|false|none|none|
|model-tag|string|true|none|none|
|target-version|[Number](#schemanumber)|true|none|none|

<h2 id="tocS_UpgradeModelResult">UpgradeModelResult</h2>
<!-- backwards compatibility -->
<a id="schemaupgrademodelresult"></a>
<a id="schema_UpgradeModelResult"></a>
<a id="tocSupgrademodelresult"></a>
<a id="tocsupgrademodelresult"></a>

```json
{
  "chosen-version": {
    "Build": 0,
    "Major": 0,
    "Minor": 0,
    "Patch": 0,
    "Tag": "string"
  },
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|chosen-version|[Number](#schemanumber)|true|none|none|
|error|[Error](#schemaerror)|false|none|none|

<h2 id="tocS_Payload">Payload</h2>
<!-- backwards compatibility -->
<a id="schemapayload"></a>
<a id="schema_Payload"></a>
<a id="tocSpayload"></a>
<a id="tocspayload"></a>

```json
{
  "class": "string",
  "id": "string",
  "labels": [
    "string"
  ],
  "machine": "string",
  "status": "string",
  "type": "string",
  "unit": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|class|string|true|none|none|
|id|string|true|none|none|
|labels|[string]|true|none|none|
|machine|string|true|none|none|
|status|string|true|none|none|
|type|string|true|none|none|
|unit|string|true|none|none|

<h2 id="tocS_PayloadListArgs">PayloadListArgs</h2>
<!-- backwards compatibility -->
<a id="schemapayloadlistargs"></a>
<a id="schema_PayloadListArgs"></a>
<a id="tocSpayloadlistargs"></a>
<a id="tocspayloadlistargs"></a>

```json
{
  "patterns": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|patterns|[string]|true|none|none|

<h2 id="tocS_PayloadListResults">PayloadListResults</h2>
<!-- backwards compatibility -->
<a id="schemapayloadlistresults"></a>
<a id="schema_PayloadListResults"></a>
<a id="tocSpayloadlistresults"></a>
<a id="tocspayloadlistresults"></a>

```json
{
  "results": [
    {
      "class": "string",
      "id": "string",
      "labels": [
        "string"
      ],
      "machine": "string",
      "status": "string",
      "type": "string",
      "unit": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[Payload](#schemapayload)]|true|none|none|

<h2 id="tocS_AddPendingResourcesArgsV2">AddPendingResourcesArgsV2</h2>
<!-- backwards compatibility -->
<a id="schemaaddpendingresourcesargsv2"></a>
<a id="schema_AddPendingResourcesArgsV2"></a>
<a id="tocSaddpendingresourcesargsv2"></a>
<a id="tocsaddpendingresourcesargsv2"></a>

```json
{
  "Entity": {
    "tag": "string"
  },
  "charm-origin": {
    "architecture": "string",
    "base": {
      "channel": "string",
      "name": "string"
    },
    "branch": "string",
    "hash": "string",
    "id": "string",
    "instance-key": "string",
    "revision": 0,
    "risk": "string",
    "source": "string",
    "track": "string",
    "type": "string"
  },
  "macaroon": {},
  "resources": [
    {
      "description": "string",
      "fingerprint": [
        0
      ],
      "name": "string",
      "origin": "string",
      "path": "string",
      "revision": 0,
      "size": 0,
      "type": "string"
    }
  ],
  "tag": "string",
  "url": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|Entity|[Entity](#schemaentity)|true|none|none|
|charm-origin|[CharmOrigin](#schemacharmorigin)|true|none|none|
|macaroon|[Macaroon](#schemamacaroon)|true|none|none|
|resources|[[CharmResource](#schemacharmresource)]|true|none|none|
|tag|string|true|none|none|
|url|string|true|none|none|

<h2 id="tocS_AddPendingResourcesResult">AddPendingResourcesResult</h2>
<!-- backwards compatibility -->
<a id="schemaaddpendingresourcesresult"></a>
<a id="schema_AddPendingResourcesResult"></a>
<a id="tocSaddpendingresourcesresult"></a>
<a id="tocsaddpendingresourcesresult"></a>

```json
{
  "ErrorResult": {
    "error": {
      "code": "string",
      "info": {},
      "message": "string"
    }
  },
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "pending-ids": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|ErrorResult|[ErrorResult](#schemaerrorresult)|true|none|none|
|error|[Error](#schemaerror)|false|none|none|
|pending-ids|[string]|true|none|none|

<h2 id="tocS_ListResourcesArgs">ListResourcesArgs</h2>
<!-- backwards compatibility -->
<a id="schemalistresourcesargs"></a>
<a id="schema_ListResourcesArgs"></a>
<a id="tocSlistresourcesargs"></a>
<a id="tocslistresourcesargs"></a>

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|entities|[[Entity](#schemaentity)]|true|none|none|

<h2 id="tocS_Resource">Resource</h2>
<!-- backwards compatibility -->
<a id="schemaresource"></a>
<a id="schema_Resource"></a>
<a id="tocSresource"></a>
<a id="tocsresource"></a>

```json
{
  "CharmResource": {
    "description": "string",
    "fingerprint": [
      0
    ],
    "name": "string",
    "origin": "string",
    "path": "string",
    "revision": 0,
    "size": 0,
    "type": "string"
  },
  "application": "string",
  "description": "string",
  "fingerprint": [
    0
  ],
  "id": "string",
  "name": "string",
  "origin": "string",
  "path": "string",
  "pending-id": "string",
  "revision": 0,
  "size": 0,
  "timestamp": "2019-08-24T14:15:22Z",
  "type": "string",
  "username": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|CharmResource|[CharmResource](#schemacharmresource)|true|none|none|
|application|string|true|none|none|
|description|string|false|none|none|
|fingerprint|[integer]|true|none|none|
|id|string|true|none|none|
|name|string|true|none|none|
|origin|string|true|none|none|
|path|string|true|none|none|
|pending-id|string|true|none|none|
|revision|integer|true|none|none|
|size|integer|true|none|none|
|timestamp|string(date-time)|true|none|none|
|type|string|true|none|none|
|username|string|true|none|none|

<h2 id="tocS_ResourcesResult">ResourcesResult</h2>
<!-- backwards compatibility -->
<a id="schemaresourcesresult"></a>
<a id="schema_ResourcesResult"></a>
<a id="tocSresourcesresult"></a>
<a id="tocsresourcesresult"></a>

```json
{
  "ErrorResult": {
    "error": {
      "code": "string",
      "info": {},
      "message": "string"
    }
  },
  "charm-store-resources": [
    {
      "description": "string",
      "fingerprint": [
        0
      ],
      "name": "string",
      "origin": "string",
      "path": "string",
      "revision": 0,
      "size": 0,
      "type": "string"
    }
  ],
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "resources": [
    {
      "CharmResource": {
        "description": "string",
        "fingerprint": [
          0
        ],
        "name": "string",
        "origin": "string",
        "path": "string",
        "revision": 0,
        "size": 0,
        "type": "string"
      },
      "application": "string",
      "description": "string",
      "fingerprint": [
        0
      ],
      "id": "string",
      "name": "string",
      "origin": "string",
      "path": "string",
      "pending-id": "string",
      "revision": 0,
      "size": 0,
      "timestamp": "2019-08-24T14:15:22Z",
      "type": "string",
      "username": "string"
    }
  ],
  "unit-resources": [
    {
      "Entity": {
        "tag": "string"
      },
      "download-progress": {},
      "resources": [
        {
          "CharmResource": {
            "description": "string",
            "fingerprint": [
              0
            ],
            "name": "string",
            "origin": "string",
            "path": "string",
            "revision": 0,
            "size": 0,
            "type": "string"
          },
          "application": "string",
          "description": "string",
          "fingerprint": [
            0
          ],
          "id": "string",
          "name": "string",
          "origin": "string",
          "path": "string",
          "pending-id": "string",
          "revision": 0,
          "size": 0,
          "timestamp": "2019-08-24T14:15:22Z",
          "type": "string",
          "username": "string"
        }
      ],
      "tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|ErrorResult|[ErrorResult](#schemaerrorresult)|true|none|none|
|charm-store-resources|[[CharmResource](#schemacharmresource)]|true|none|none|
|error|[Error](#schemaerror)|false|none|none|
|resources|[[Resource](#schemaresource)]|true|none|none|
|unit-resources|[[UnitResources](#schemaunitresources)]|true|none|none|

<h2 id="tocS_ResourcesResults">ResourcesResults</h2>
<!-- backwards compatibility -->
<a id="schemaresourcesresults"></a>
<a id="schema_ResourcesResults"></a>
<a id="tocSresourcesresults"></a>
<a id="tocsresourcesresults"></a>

```json
{
  "results": [
    {
      "ErrorResult": {
        "error": {
          "code": "string",
          "info": {},
          "message": "string"
        }
      },
      "charm-store-resources": [
        {
          "description": "string",
          "fingerprint": [
            0
          ],
          "name": "string",
          "origin": "string",
          "path": "string",
          "revision": 0,
          "size": 0,
          "type": "string"
        }
      ],
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "resources": [
        {
          "CharmResource": {
            "description": "string",
            "fingerprint": [
              0
            ],
            "name": "string",
            "origin": "string",
            "path": "string",
            "revision": 0,
            "size": 0,
            "type": "string"
          },
          "application": "string",
          "description": "string",
          "fingerprint": [
            0
          ],
          "id": "string",
          "name": "string",
          "origin": "string",
          "path": "string",
          "pending-id": "string",
          "revision": 0,
          "size": 0,
          "timestamp": "2019-08-24T14:15:22Z",
          "type": "string",
          "username": "string"
        }
      ],
      "unit-resources": [
        {
          "Entity": {
            "tag": "string"
          },
          "download-progress": {},
          "resources": [
            {
              "CharmResource": {
                "description": "string",
                "fingerprint": [
                  0
                ],
                "name": "string",
                "origin": "string",
                "path": "string",
                "revision": 0,
                "size": 0,
                "type": "string"
              },
              "application": "string",
              "description": "string",
              "fingerprint": [
                0
              ],
              "id": "string",
              "name": "string",
              "origin": "string",
              "path": "string",
              "pending-id": "string",
              "revision": 0,
              "size": 0,
              "timestamp": "2019-08-24T14:15:22Z",
              "type": "string",
              "username": "string"
            }
          ],
          "tag": "string"
        }
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[ResourcesResult](#schemaresourcesresult)]|true|none|none|

<h2 id="tocS_UnitResources">UnitResources</h2>
<!-- backwards compatibility -->
<a id="schemaunitresources"></a>
<a id="schema_UnitResources"></a>
<a id="tocSunitresources"></a>
<a id="tocsunitresources"></a>

```json
{
  "Entity": {
    "tag": "string"
  },
  "download-progress": {},
  "resources": [
    {
      "CharmResource": {
        "description": "string",
        "fingerprint": [
          0
        ],
        "name": "string",
        "origin": "string",
        "path": "string",
        "revision": 0,
        "size": 0,
        "type": "string"
      },
      "application": "string",
      "description": "string",
      "fingerprint": [
        0
      ],
      "id": "string",
      "name": "string",
      "origin": "string",
      "path": "string",
      "pending-id": "string",
      "revision": 0,
      "size": 0,
      "timestamp": "2019-08-24T14:15:22Z",
      "type": "string",
      "username": "string"
    }
  ],
  "tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|Entity|[Entity](#schemaentity)|true|none|none|
|download-progress|object|true|none|none|
|» .*|integer|false|none|none|
|resources|[[Resource](#schemaresource)]|true|none|none|
|tag|string|true|none|none|

<h2 id="tocS_SSHAddressResult">SSHAddressResult</h2>
<!-- backwards compatibility -->
<a id="schemasshaddressresult"></a>
<a id="schema_SSHAddressResult"></a>
<a id="tocSsshaddressresult"></a>
<a id="tocssshaddressresult"></a>

```json
{
  "address": "string",
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|address|string|false|none|none|
|error|[Error](#schemaerror)|false|none|none|

<h2 id="tocS_SSHAddressResults">SSHAddressResults</h2>
<!-- backwards compatibility -->
<a id="schemasshaddressresults"></a>
<a id="schema_SSHAddressResults"></a>
<a id="tocSsshaddressresults"></a>
<a id="tocssshaddressresults"></a>

```json
{
  "results": [
    {
      "address": "string",
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[SSHAddressResult](#schemasshaddressresult)]|true|none|none|

<h2 id="tocS_SSHAddressesResult">SSHAddressesResult</h2>
<!-- backwards compatibility -->
<a id="schemasshaddressesresult"></a>
<a id="schema_SSHAddressesResult"></a>
<a id="tocSsshaddressesresult"></a>
<a id="tocssshaddressesresult"></a>

```json
{
  "addresses": [
    "string"
  ],
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|addresses|[string]|true|none|none|
|error|[Error](#schemaerror)|false|none|none|

<h2 id="tocS_SSHAddressesResults">SSHAddressesResults</h2>
<!-- backwards compatibility -->
<a id="schemasshaddressesresults"></a>
<a id="schema_SSHAddressesResults"></a>
<a id="tocSsshaddressesresults"></a>
<a id="tocssshaddressesresults"></a>

```json
{
  "results": [
    {
      "addresses": [
        "string"
      ],
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[SSHAddressesResult](#schemasshaddressesresult)]|true|none|none|

<h2 id="tocS_SSHProxyResult">SSHProxyResult</h2>
<!-- backwards compatibility -->
<a id="schemasshproxyresult"></a>
<a id="schema_SSHProxyResult"></a>
<a id="tocSsshproxyresult"></a>
<a id="tocssshproxyresult"></a>

```json
{
  "use-proxy": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|use-proxy|boolean|true|none|none|

<h2 id="tocS_SSHPublicKeysResult">SSHPublicKeysResult</h2>
<!-- backwards compatibility -->
<a id="schemasshpublickeysresult"></a>
<a id="schema_SSHPublicKeysResult"></a>
<a id="tocSsshpublickeysresult"></a>
<a id="tocssshpublickeysresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "public-keys": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|public-keys|[string]|false|none|none|

<h2 id="tocS_SSHPublicKeysResults">SSHPublicKeysResults</h2>
<!-- backwards compatibility -->
<a id="schemasshpublickeysresults"></a>
<a id="schema_SSHPublicKeysResults"></a>
<a id="tocSsshpublickeysresults"></a>
<a id="tocssshpublickeysresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "public-keys": [
        "string"
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[SSHPublicKeysResult](#schemasshpublickeysresult)]|true|none|none|

<h2 id="tocS_AddSecretBackendArg">AddSecretBackendArg</h2>
<!-- backwards compatibility -->
<a id="schemaaddsecretbackendarg"></a>
<a id="schema_AddSecretBackendArg"></a>
<a id="tocSaddsecretbackendarg"></a>
<a id="tocsaddsecretbackendarg"></a>

```json
{
  "SecretBackend": {
    "backend-type": "string",
    "config": {},
    "name": "string",
    "token-rotate-interval": 0
  },
  "backend-type": "string",
  "config": {},
  "id": "string",
  "name": "string",
  "token-rotate-interval": 0
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|SecretBackend|[SecretBackend](#schemasecretbackend)|true|none|none|
|backend-type|string|true|none|none|
|config|object|true|none|none|
|» .*|object|false|none|none|
|id|string|false|none|none|
|name|string|true|none|none|
|token-rotate-interval|integer|false|none|none|

<h2 id="tocS_AddSecretBackendArgs">AddSecretBackendArgs</h2>
<!-- backwards compatibility -->
<a id="schemaaddsecretbackendargs"></a>
<a id="schema_AddSecretBackendArgs"></a>
<a id="tocSaddsecretbackendargs"></a>
<a id="tocsaddsecretbackendargs"></a>

```json
{
  "args": [
    {
      "SecretBackend": {
        "backend-type": "string",
        "config": {},
        "name": "string",
        "token-rotate-interval": 0
      },
      "backend-type": "string",
      "config": {},
      "id": "string",
      "name": "string",
      "token-rotate-interval": 0
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|args|[[AddSecretBackendArg](#schemaaddsecretbackendarg)]|true|none|none|

<h2 id="tocS_ListSecretBackendsArgs">ListSecretBackendsArgs</h2>
<!-- backwards compatibility -->
<a id="schemalistsecretbackendsargs"></a>
<a id="schema_ListSecretBackendsArgs"></a>
<a id="tocSlistsecretbackendsargs"></a>
<a id="tocslistsecretbackendsargs"></a>

```json
{
  "names": [
    "string"
  ],
  "reveal": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|names|[string]|true|none|none|
|reveal|boolean|true|none|none|

<h2 id="tocS_ListSecretBackendsResults">ListSecretBackendsResults</h2>
<!-- backwards compatibility -->
<a id="schemalistsecretbackendsresults"></a>
<a id="schema_ListSecretBackendsResults"></a>
<a id="tocSlistsecretbackendsresults"></a>
<a id="tocslistsecretbackendsresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "id": "string",
      "message": "string",
      "num-secrets": 0,
      "result": {
        "backend-type": "string",
        "config": {},
        "name": "string",
        "token-rotate-interval": 0
      },
      "status": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[SecretBackendResult](#schemasecretbackendresult)]|true|none|none|

<h2 id="tocS_RemoveSecretBackendArg">RemoveSecretBackendArg</h2>
<!-- backwards compatibility -->
<a id="schemaremovesecretbackendarg"></a>
<a id="schema_RemoveSecretBackendArg"></a>
<a id="tocSremovesecretbackendarg"></a>
<a id="tocsremovesecretbackendarg"></a>

```json
{
  "force": true,
  "name": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|force|boolean|false|none|none|
|name|string|true|none|none|

<h2 id="tocS_RemoveSecretBackendArgs">RemoveSecretBackendArgs</h2>
<!-- backwards compatibility -->
<a id="schemaremovesecretbackendargs"></a>
<a id="schema_RemoveSecretBackendArgs"></a>
<a id="tocSremovesecretbackendargs"></a>
<a id="tocsremovesecretbackendargs"></a>

```json
{
  "args": [
    {
      "force": true,
      "name": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|args|[[RemoveSecretBackendArg](#schemaremovesecretbackendarg)]|true|none|none|

<h2 id="tocS_UpdateSecretBackendArg">UpdateSecretBackendArg</h2>
<!-- backwards compatibility -->
<a id="schemaupdatesecretbackendarg"></a>
<a id="schema_UpdateSecretBackendArg"></a>
<a id="tocSupdatesecretbackendarg"></a>
<a id="tocsupdatesecretbackendarg"></a>

```json
{
  "config": {},
  "force": true,
  "name": "string",
  "name-change": "string",
  "reset": [
    "string"
  ],
  "token-rotate-interval": 0
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|config|object|true|none|none|
|» .*|object|false|none|none|
|force|boolean|false|none|none|
|name|string|true|none|none|
|name-change|string|false|none|none|
|reset|[string]|true|none|none|
|token-rotate-interval|integer|true|none|none|

<h2 id="tocS_UpdateSecretBackendArgs">UpdateSecretBackendArgs</h2>
<!-- backwards compatibility -->
<a id="schemaupdatesecretbackendargs"></a>
<a id="schema_UpdateSecretBackendArgs"></a>
<a id="tocSupdatesecretbackendargs"></a>
<a id="tocsupdatesecretbackendargs"></a>

```json
{
  "args": [
    {
      "config": {},
      "force": true,
      "name": "string",
      "name-change": "string",
      "reset": [
        "string"
      ],
      "token-rotate-interval": 0
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|args|[[UpdateSecretBackendArg](#schemaupdatesecretbackendarg)]|true|none|none|

<h2 id="tocS_ListSecretResult">ListSecretResult</h2>
<!-- backwards compatibility -->
<a id="schemalistsecretresult"></a>
<a id="schema_ListSecretResult"></a>
<a id="tocSlistsecretresult"></a>
<a id="tocslistsecretresult"></a>

```json
{
  "create-time": "2019-08-24T14:15:22Z",
  "description": "string",
  "label": "string",
  "latest-expire-time": "2019-08-24T14:15:22Z",
  "latest-revision": 0,
  "next-rotate-time": "2019-08-24T14:15:22Z",
  "owner-tag": "string",
  "revisions": [
    {
      "backend-name": "string",
      "create-time": "2019-08-24T14:15:22Z",
      "expire-time": "2019-08-24T14:15:22Z",
      "revision": 0,
      "update-time": "2019-08-24T14:15:22Z",
      "value-ref": {
        "backend-id": "string",
        "revision-id": "string"
      }
    }
  ],
  "rotate-policy": "string",
  "update-time": "2019-08-24T14:15:22Z",
  "uri": "string",
  "value": {
    "data": {},
    "error": {
      "code": "string",
      "info": {},
      "message": "string"
    }
  },
  "version": 0
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|create-time|string(date-time)|true|none|none|
|description|string|false|none|none|
|label|string|false|none|none|
|latest-expire-time|string(date-time)|false|none|none|
|latest-revision|integer|true|none|none|
|next-rotate-time|string(date-time)|false|none|none|
|owner-tag|string|true|none|none|
|revisions|[[SecretRevision](#schemasecretrevision)]|true|none|none|
|rotate-policy|string|false|none|none|
|update-time|string(date-time)|true|none|none|
|uri|string|true|none|none|
|value|[SecretValueResult](#schemasecretvalueresult)|false|none|none|
|version|integer|true|none|none|

<h2 id="tocS_ListSecretResults">ListSecretResults</h2>
<!-- backwards compatibility -->
<a id="schemalistsecretresults"></a>
<a id="schema_ListSecretResults"></a>
<a id="tocSlistsecretresults"></a>
<a id="tocslistsecretresults"></a>

```json
{
  "results": [
    {
      "create-time": "2019-08-24T14:15:22Z",
      "description": "string",
      "label": "string",
      "latest-expire-time": "2019-08-24T14:15:22Z",
      "latest-revision": 0,
      "next-rotate-time": "2019-08-24T14:15:22Z",
      "owner-tag": "string",
      "revisions": [
        {
          "backend-name": "string",
          "create-time": "2019-08-24T14:15:22Z",
          "expire-time": "2019-08-24T14:15:22Z",
          "revision": 0,
          "update-time": "2019-08-24T14:15:22Z",
          "value-ref": {
            "backend-id": "string",
            "revision-id": "string"
          }
        }
      ],
      "rotate-policy": "string",
      "update-time": "2019-08-24T14:15:22Z",
      "uri": "string",
      "value": {
        "data": {},
        "error": {
          "code": "string",
          "info": {},
          "message": "string"
        }
      },
      "version": 0
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[ListSecretResult](#schemalistsecretresult)]|true|none|none|

<h2 id="tocS_ListSecretsArgs">ListSecretsArgs</h2>
<!-- backwards compatibility -->
<a id="schemalistsecretsargs"></a>
<a id="schema_ListSecretsArgs"></a>
<a id="tocSlistsecretsargs"></a>
<a id="tocslistsecretsargs"></a>

```json
{
  "filter": {
    "owner-tag": "string",
    "revision": 0,
    "uri": "string"
  },
  "show-secrets": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|filter|[SecretsFilter](#schemasecretsfilter)|true|none|none|
|show-secrets|boolean|true|none|none|

<h2 id="tocS_SecretRevision">SecretRevision</h2>
<!-- backwards compatibility -->
<a id="schemasecretrevision"></a>
<a id="schema_SecretRevision"></a>
<a id="tocSsecretrevision"></a>
<a id="tocssecretrevision"></a>

```json
{
  "backend-name": "string",
  "create-time": "2019-08-24T14:15:22Z",
  "expire-time": "2019-08-24T14:15:22Z",
  "revision": 0,
  "update-time": "2019-08-24T14:15:22Z",
  "value-ref": {
    "backend-id": "string",
    "revision-id": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|backend-name|string|false|none|none|
|create-time|string(date-time)|false|none|none|
|expire-time|string(date-time)|false|none|none|
|revision|integer|true|none|none|
|update-time|string(date-time)|false|none|none|
|value-ref|[SecretValueRef](#schemasecretvalueref)|false|none|none|

<h2 id="tocS_SecretValueRef">SecretValueRef</h2>
<!-- backwards compatibility -->
<a id="schemasecretvalueref"></a>
<a id="schema_SecretValueRef"></a>
<a id="tocSsecretvalueref"></a>
<a id="tocssecretvalueref"></a>

```json
{
  "backend-id": "string",
  "revision-id": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|backend-id|string|true|none|none|
|revision-id|string|true|none|none|

<h2 id="tocS_SecretValueResult">SecretValueResult</h2>
<!-- backwards compatibility -->
<a id="schemasecretvalueresult"></a>
<a id="schema_SecretValueResult"></a>
<a id="tocSsecretvalueresult"></a>
<a id="tocssecretvalueresult"></a>

```json
{
  "data": {},
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|data|object|false|none|none|
|» .*|string|false|none|none|
|error|[Error](#schemaerror)|false|none|none|

<h2 id="tocS_SecretsFilter">SecretsFilter</h2>
<!-- backwards compatibility -->
<a id="schemasecretsfilter"></a>
<a id="schema_SecretsFilter"></a>
<a id="tocSsecretsfilter"></a>
<a id="tocssecretsfilter"></a>

```json
{
  "owner-tag": "string",
  "revision": 0,
  "uri": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|owner-tag|string|false|none|none|
|revision|integer|false|none|none|
|uri|string|false|none|none|

<h2 id="tocS_CreateSpaceParams">CreateSpaceParams</h2>
<!-- backwards compatibility -->
<a id="schemacreatespaceparams"></a>
<a id="schema_CreateSpaceParams"></a>
<a id="tocScreatespaceparams"></a>
<a id="tocscreatespaceparams"></a>

```json
{
  "cidrs": [
    "string"
  ],
  "provider-id": "string",
  "public": true,
  "space-tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|cidrs|[string]|true|none|none|
|provider-id|string|false|none|none|
|public|boolean|true|none|none|
|space-tag|string|true|none|none|

<h2 id="tocS_CreateSpacesParams">CreateSpacesParams</h2>
<!-- backwards compatibility -->
<a id="schemacreatespacesparams"></a>
<a id="schema_CreateSpacesParams"></a>
<a id="tocScreatespacesparams"></a>
<a id="tocscreatespacesparams"></a>

```json
{
  "spaces": [
    {
      "cidrs": [
        "string"
      ],
      "provider-id": "string",
      "public": true,
      "space-tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|spaces|[[CreateSpaceParams](#schemacreatespaceparams)]|true|none|none|

<h2 id="tocS_ListSpacesResults">ListSpacesResults</h2>
<!-- backwards compatibility -->
<a id="schemalistspacesresults"></a>
<a id="schema_ListSpacesResults"></a>
<a id="tocSlistspacesresults"></a>
<a id="tocslistspacesresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "id": "string",
      "name": "string",
      "subnets": [
        {
          "cidr": "string",
          "life": "string",
          "provider-id": "string",
          "provider-network-id": "string",
          "provider-space-id": "string",
          "space-tag": "string",
          "status": "string",
          "vlan-tag": 0,
          "zones": [
            "string"
          ]
        }
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[Space](#schemaspace)]|true|none|none|

<h2 id="tocS_MoveSubnetsParam">MoveSubnetsParam</h2>
<!-- backwards compatibility -->
<a id="schemamovesubnetsparam"></a>
<a id="schema_MoveSubnetsParam"></a>
<a id="tocSmovesubnetsparam"></a>
<a id="tocsmovesubnetsparam"></a>

```json
{
  "force": true,
  "space-tag": "string",
  "subnets": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|force|boolean|true|none|none|
|space-tag|string|true|none|none|
|subnets|[string]|true|none|none|

<h2 id="tocS_MoveSubnetsParams">MoveSubnetsParams</h2>
<!-- backwards compatibility -->
<a id="schemamovesubnetsparams"></a>
<a id="schema_MoveSubnetsParams"></a>
<a id="tocSmovesubnetsparams"></a>
<a id="tocsmovesubnetsparams"></a>

```json
{
  "args": [
    {
      "force": true,
      "space-tag": "string",
      "subnets": [
        "string"
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|args|[[MoveSubnetsParam](#schemamovesubnetsparam)]|true|none|none|

<h2 id="tocS_MoveSubnetsResult">MoveSubnetsResult</h2>
<!-- backwards compatibility -->
<a id="schemamovesubnetsresult"></a>
<a id="schema_MoveSubnetsResult"></a>
<a id="tocSmovesubnetsresult"></a>
<a id="tocsmovesubnetsresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "moved-subnets": [
    {
      "cidr": "string",
      "old-space": "string",
      "subnet": "string"
    }
  ],
  "new-space": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|moved-subnets|[[MovedSubnet](#schemamovedsubnet)]|false|none|none|
|new-space|string|true|none|none|

<h2 id="tocS_MoveSubnetsResults">MoveSubnetsResults</h2>
<!-- backwards compatibility -->
<a id="schemamovesubnetsresults"></a>
<a id="schema_MoveSubnetsResults"></a>
<a id="tocSmovesubnetsresults"></a>
<a id="tocsmovesubnetsresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "moved-subnets": [
        {
          "cidr": "string",
          "old-space": "string",
          "subnet": "string"
        }
      ],
      "new-space": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[MoveSubnetsResult](#schemamovesubnetsresult)]|true|none|none|

<h2 id="tocS_MovedSubnet">MovedSubnet</h2>
<!-- backwards compatibility -->
<a id="schemamovedsubnet"></a>
<a id="schema_MovedSubnet"></a>
<a id="tocSmovedsubnet"></a>
<a id="tocsmovedsubnet"></a>

```json
{
  "cidr": "string",
  "old-space": "string",
  "subnet": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|cidr|string|true|none|none|
|old-space|string|true|none|none|
|subnet|string|true|none|none|

<h2 id="tocS_RemoveSpaceParam">RemoveSpaceParam</h2>
<!-- backwards compatibility -->
<a id="schemaremovespaceparam"></a>
<a id="schema_RemoveSpaceParam"></a>
<a id="tocSremovespaceparam"></a>
<a id="tocsremovespaceparam"></a>

```json
{
  "dry-run": true,
  "force": true,
  "space": {
    "tag": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|dry-run|boolean|false|none|none|
|force|boolean|false|none|none|
|space|[Entity](#schemaentity)|true|none|none|

<h2 id="tocS_RemoveSpaceParams">RemoveSpaceParams</h2>
<!-- backwards compatibility -->
<a id="schemaremovespaceparams"></a>
<a id="schema_RemoveSpaceParams"></a>
<a id="tocSremovespaceparams"></a>
<a id="tocsremovespaceparams"></a>

```json
{
  "space-param": [
    {
      "dry-run": true,
      "force": true,
      "space": {
        "tag": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|space-param|[[RemoveSpaceParam](#schemaremovespaceparam)]|true|none|none|

<h2 id="tocS_RemoveSpaceResult">RemoveSpaceResult</h2>
<!-- backwards compatibility -->
<a id="schemaremovespaceresult"></a>
<a id="schema_RemoveSpaceResult"></a>
<a id="tocSremovespaceresult"></a>
<a id="tocsremovespaceresult"></a>

```json
{
  "bindings": [
    {
      "tag": "string"
    }
  ],
  "constraints": [
    {
      "tag": "string"
    }
  ],
  "controller-settings": [
    "string"
  ],
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|bindings|[[Entity](#schemaentity)]|false|none|none|
|constraints|[[Entity](#schemaentity)]|false|none|none|
|controller-settings|[string]|false|none|none|
|error|[Error](#schemaerror)|false|none|none|

<h2 id="tocS_RemoveSpaceResults">RemoveSpaceResults</h2>
<!-- backwards compatibility -->
<a id="schemaremovespaceresults"></a>
<a id="schema_RemoveSpaceResults"></a>
<a id="tocSremovespaceresults"></a>
<a id="tocsremovespaceresults"></a>

```json
{
  "results": [
    {
      "bindings": [
        {
          "tag": "string"
        }
      ],
      "constraints": [
        {
          "tag": "string"
        }
      ],
      "controller-settings": [
        "string"
      ],
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[RemoveSpaceResult](#schemaremovespaceresult)]|true|none|none|

<h2 id="tocS_RenameSpaceParams">RenameSpaceParams</h2>
<!-- backwards compatibility -->
<a id="schemarenamespaceparams"></a>
<a id="schema_RenameSpaceParams"></a>
<a id="tocSrenamespaceparams"></a>
<a id="tocsrenamespaceparams"></a>

```json
{
  "from-space-tag": "string",
  "to-space-tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|from-space-tag|string|true|none|none|
|to-space-tag|string|true|none|none|

<h2 id="tocS_RenameSpacesParams">RenameSpacesParams</h2>
<!-- backwards compatibility -->
<a id="schemarenamespacesparams"></a>
<a id="schema_RenameSpacesParams"></a>
<a id="tocSrenamespacesparams"></a>
<a id="tocsrenamespacesparams"></a>

```json
{
  "changes": [
    {
      "from-space-tag": "string",
      "to-space-tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|changes|[[RenameSpaceParams](#schemarenamespaceparams)]|true|none|none|

<h2 id="tocS_ShowSpaceResult">ShowSpaceResult</h2>
<!-- backwards compatibility -->
<a id="schemashowspaceresult"></a>
<a id="schema_ShowSpaceResult"></a>
<a id="tocSshowspaceresult"></a>
<a id="tocsshowspaceresult"></a>

```json
{
  "applications": [
    "string"
  ],
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "machine-count": 0,
  "space": {
    "error": {
      "code": "string",
      "info": {},
      "message": "string"
    },
    "id": "string",
    "name": "string",
    "subnets": [
      {
        "cidr": "string",
        "life": "string",
        "provider-id": "string",
        "provider-network-id": "string",
        "provider-space-id": "string",
        "space-tag": "string",
        "status": "string",
        "vlan-tag": 0,
        "zones": [
          "string"
        ]
      }
    ]
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|applications|[string]|true|none|none|
|error|[Error](#schemaerror)|false|none|none|
|machine-count|integer|true|none|none|
|space|[Space](#schemaspace)|true|none|none|

<h2 id="tocS_ShowSpaceResults">ShowSpaceResults</h2>
<!-- backwards compatibility -->
<a id="schemashowspaceresults"></a>
<a id="schema_ShowSpaceResults"></a>
<a id="tocSshowspaceresults"></a>
<a id="tocsshowspaceresults"></a>

```json
{
  "results": [
    {
      "applications": [
        "string"
      ],
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "machine-count": 0,
      "space": {
        "error": {
          "code": "string",
          "info": {},
          "message": "string"
        },
        "id": "string",
        "name": "string",
        "subnets": [
          {
            "cidr": "string",
            "life": "string",
            "provider-id": "string",
            "provider-network-id": "string",
            "provider-space-id": "string",
            "space-tag": "string",
            "status": "string",
            "vlan-tag": 0,
            "zones": [
              "string"
            ]
          }
        ]
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[ShowSpaceResult](#schemashowspaceresult)]|true|none|none|

<h2 id="tocS_Space">Space</h2>
<!-- backwards compatibility -->
<a id="schemaspace"></a>
<a id="schema_Space"></a>
<a id="tocSspace"></a>
<a id="tocsspace"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "id": "string",
  "name": "string",
  "subnets": [
    {
      "cidr": "string",
      "life": "string",
      "provider-id": "string",
      "provider-network-id": "string",
      "provider-space-id": "string",
      "space-tag": "string",
      "status": "string",
      "vlan-tag": 0,
      "zones": [
        "string"
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|id|string|true|none|none|
|name|string|true|none|none|
|subnets|[[Subnet](#schemasubnet)]|true|none|none|

<h2 id="tocS_AddStorageDetails">AddStorageDetails</h2>
<!-- backwards compatibility -->
<a id="schemaaddstoragedetails"></a>
<a id="schema_AddStorageDetails"></a>
<a id="tocSaddstoragedetails"></a>
<a id="tocsaddstoragedetails"></a>

```json
{
  "storage-tags": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|storage-tags|[string]|true|none|none|

<h2 id="tocS_AddStorageResult">AddStorageResult</h2>
<!-- backwards compatibility -->
<a id="schemaaddstorageresult"></a>
<a id="schema_AddStorageResult"></a>
<a id="tocSaddstorageresult"></a>
<a id="tocsaddstorageresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": {
    "storage-tags": [
      "string"
    ]
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|result|[AddStorageDetails](#schemaaddstoragedetails)|false|none|none|

<h2 id="tocS_AddStorageResults">AddStorageResults</h2>
<!-- backwards compatibility -->
<a id="schemaaddstorageresults"></a>
<a id="schema_AddStorageResults"></a>
<a id="tocSaddstorageresults"></a>
<a id="tocsaddstorageresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "storage-tags": [
          "string"
        ]
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[AddStorageResult](#schemaaddstorageresult)]|true|none|none|

<h2 id="tocS_BulkImportStorageParams">BulkImportStorageParams</h2>
<!-- backwards compatibility -->
<a id="schemabulkimportstorageparams"></a>
<a id="schema_BulkImportStorageParams"></a>
<a id="tocSbulkimportstorageparams"></a>
<a id="tocsbulkimportstorageparams"></a>

```json
{
  "storage": [
    {
      "kind": 0,
      "pool": "string",
      "provider-id": "string",
      "storage-name": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|storage|[[ImportStorageParams](#schemaimportstorageparams)]|true|none|none|

<h2 id="tocS_FilesystemAttachmentDetails">FilesystemAttachmentDetails</h2>
<!-- backwards compatibility -->
<a id="schemafilesystemattachmentdetails"></a>
<a id="schema_FilesystemAttachmentDetails"></a>
<a id="tocSfilesystemattachmentdetails"></a>
<a id="tocsfilesystemattachmentdetails"></a>

```json
{
  "FilesystemAttachmentInfo": {
    "mount-point": "string",
    "read-only": true
  },
  "life": "string",
  "mount-point": "string",
  "read-only": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|FilesystemAttachmentInfo|[FilesystemAttachmentInfo](#schemafilesystemattachmentinfo)|true|none|none|
|life|string|false|none|none|
|mount-point|string|false|none|none|
|read-only|boolean|false|none|none|

<h2 id="tocS_FilesystemAttachmentInfo">FilesystemAttachmentInfo</h2>
<!-- backwards compatibility -->
<a id="schemafilesystemattachmentinfo"></a>
<a id="schema_FilesystemAttachmentInfo"></a>
<a id="tocSfilesystemattachmentinfo"></a>
<a id="tocsfilesystemattachmentinfo"></a>

```json
{
  "mount-point": "string",
  "read-only": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|mount-point|string|false|none|none|
|read-only|boolean|false|none|none|

<h2 id="tocS_FilesystemDetails">FilesystemDetails</h2>
<!-- backwards compatibility -->
<a id="schemafilesystemdetails"></a>
<a id="schema_FilesystemDetails"></a>
<a id="tocSfilesystemdetails"></a>
<a id="tocsfilesystemdetails"></a>

```json
{
  "filesystem-tag": "string",
  "info": {
    "filesystem-id": "string",
    "pool": "string",
    "size": 0
  },
  "life": "string",
  "machine-attachments": {},
  "status": {
    "data": {},
    "info": "string",
    "since": "2019-08-24T14:15:22Z",
    "status": "string"
  },
  "storage": {
    "attachments": {},
    "kind": 0,
    "life": "string",
    "owner-tag": "string",
    "persistent": true,
    "status": {
      "data": {},
      "info": "string",
      "since": "2019-08-24T14:15:22Z",
      "status": "string"
    },
    "storage-tag": "string"
  },
  "unit-attachments": {},
  "volume-tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|filesystem-tag|string|true|none|none|
|info|[FilesystemInfo](#schemafilesysteminfo)|true|none|none|
|life|string|false|none|none|
|machine-attachments|object|false|none|none|
|» .*|[FilesystemAttachmentDetails](#schemafilesystemattachmentdetails)|false|none|none|
|status|[EntityStatus](#schemaentitystatus)|true|none|none|
|storage|[StorageDetails](#schemastoragedetails)|false|none|none|
|unit-attachments|object|false|none|none|
|» .*|[FilesystemAttachmentDetails](#schemafilesystemattachmentdetails)|false|none|none|
|volume-tag|string|false|none|none|

<h2 id="tocS_FilesystemDetailsListResult">FilesystemDetailsListResult</h2>
<!-- backwards compatibility -->
<a id="schemafilesystemdetailslistresult"></a>
<a id="schema_FilesystemDetailsListResult"></a>
<a id="tocSfilesystemdetailslistresult"></a>
<a id="tocsfilesystemdetailslistresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": [
    {
      "filesystem-tag": "string",
      "info": {
        "filesystem-id": "string",
        "pool": "string",
        "size": 0
      },
      "life": "string",
      "machine-attachments": {},
      "status": {
        "data": {},
        "info": "string",
        "since": "2019-08-24T14:15:22Z",
        "status": "string"
      },
      "storage": {
        "attachments": {},
        "kind": 0,
        "life": "string",
        "owner-tag": "string",
        "persistent": true,
        "status": {
          "data": {},
          "info": "string",
          "since": "2019-08-24T14:15:22Z",
          "status": "string"
        },
        "storage-tag": "string"
      },
      "unit-attachments": {},
      "volume-tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|result|[[FilesystemDetails](#schemafilesystemdetails)]|false|none|none|

<h2 id="tocS_FilesystemDetailsListResults">FilesystemDetailsListResults</h2>
<!-- backwards compatibility -->
<a id="schemafilesystemdetailslistresults"></a>
<a id="schema_FilesystemDetailsListResults"></a>
<a id="tocSfilesystemdetailslistresults"></a>
<a id="tocsfilesystemdetailslistresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": [
        {
          "filesystem-tag": "string",
          "info": {
            "filesystem-id": "string",
            "pool": "string",
            "size": 0
          },
          "life": "string",
          "machine-attachments": {},
          "status": {
            "data": {},
            "info": "string",
            "since": "2019-08-24T14:15:22Z",
            "status": "string"
          },
          "storage": {
            "attachments": {},
            "kind": 0,
            "life": "string",
            "owner-tag": "string",
            "persistent": true,
            "status": {
              "data": {},
              "info": "string",
              "since": "2019-08-24T14:15:22Z",
              "status": "string"
            },
            "storage-tag": "string"
          },
          "unit-attachments": {},
          "volume-tag": "string"
        }
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[FilesystemDetailsListResult](#schemafilesystemdetailslistresult)]|false|none|none|

<h2 id="tocS_FilesystemFilter">FilesystemFilter</h2>
<!-- backwards compatibility -->
<a id="schemafilesystemfilter"></a>
<a id="schema_FilesystemFilter"></a>
<a id="tocSfilesystemfilter"></a>
<a id="tocsfilesystemfilter"></a>

```json
{
  "machines": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|machines|[string]|false|none|none|

<h2 id="tocS_FilesystemFilters">FilesystemFilters</h2>
<!-- backwards compatibility -->
<a id="schemafilesystemfilters"></a>
<a id="schema_FilesystemFilters"></a>
<a id="tocSfilesystemfilters"></a>
<a id="tocsfilesystemfilters"></a>

```json
{
  "filters": [
    {
      "machines": [
        "string"
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|filters|[[FilesystemFilter](#schemafilesystemfilter)]|false|none|none|

<h2 id="tocS_FilesystemInfo">FilesystemInfo</h2>
<!-- backwards compatibility -->
<a id="schemafilesysteminfo"></a>
<a id="schema_FilesystemInfo"></a>
<a id="tocSfilesysteminfo"></a>
<a id="tocsfilesysteminfo"></a>

```json
{
  "filesystem-id": "string",
  "pool": "string",
  "size": 0
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|filesystem-id|string|true|none|none|
|pool|string|true|none|none|
|size|integer|true|none|none|

<h2 id="tocS_ImportStorageDetails">ImportStorageDetails</h2>
<!-- backwards compatibility -->
<a id="schemaimportstoragedetails"></a>
<a id="schema_ImportStorageDetails"></a>
<a id="tocSimportstoragedetails"></a>
<a id="tocsimportstoragedetails"></a>

```json
{
  "storage-tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|storage-tag|string|true|none|none|

<h2 id="tocS_ImportStorageParams">ImportStorageParams</h2>
<!-- backwards compatibility -->
<a id="schemaimportstorageparams"></a>
<a id="schema_ImportStorageParams"></a>
<a id="tocSimportstorageparams"></a>
<a id="tocsimportstorageparams"></a>

```json
{
  "kind": 0,
  "pool": "string",
  "provider-id": "string",
  "storage-name": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|kind|integer|true|none|none|
|pool|string|true|none|none|
|provider-id|string|true|none|none|
|storage-name|string|true|none|none|

<h2 id="tocS_ImportStorageResult">ImportStorageResult</h2>
<!-- backwards compatibility -->
<a id="schemaimportstorageresult"></a>
<a id="schema_ImportStorageResult"></a>
<a id="tocSimportstorageresult"></a>
<a id="tocsimportstorageresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": {
    "storage-tag": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|result|[ImportStorageDetails](#schemaimportstoragedetails)|false|none|none|

<h2 id="tocS_ImportStorageResults">ImportStorageResults</h2>
<!-- backwards compatibility -->
<a id="schemaimportstorageresults"></a>
<a id="schema_ImportStorageResults"></a>
<a id="tocSimportstorageresults"></a>
<a id="tocsimportstorageresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "storage-tag": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[ImportStorageResult](#schemaimportstorageresult)]|true|none|none|

<h2 id="tocS_RemoveStorage">RemoveStorage</h2>
<!-- backwards compatibility -->
<a id="schemaremovestorage"></a>
<a id="schema_RemoveStorage"></a>
<a id="tocSremovestorage"></a>
<a id="tocsremovestorage"></a>

```json
{
  "storage": [
    {
      "destroy-attachments": true,
      "destroy-storage": true,
      "force": true,
      "max-wait": 0,
      "tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|storage|[[RemoveStorageInstance](#schemaremovestorageinstance)]|true|none|none|

<h2 id="tocS_RemoveStorageInstance">RemoveStorageInstance</h2>
<!-- backwards compatibility -->
<a id="schemaremovestorageinstance"></a>
<a id="schema_RemoveStorageInstance"></a>
<a id="tocSremovestorageinstance"></a>
<a id="tocsremovestorageinstance"></a>

```json
{
  "destroy-attachments": true,
  "destroy-storage": true,
  "force": true,
  "max-wait": 0,
  "tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|destroy-attachments|boolean|false|none|none|
|destroy-storage|boolean|false|none|none|
|force|boolean|false|none|none|
|max-wait|integer|false|none|none|
|tag|string|true|none|none|

<h2 id="tocS_StorageAddParams">StorageAddParams</h2>
<!-- backwards compatibility -->
<a id="schemastorageaddparams"></a>
<a id="schema_StorageAddParams"></a>
<a id="tocSstorageaddparams"></a>
<a id="tocsstorageaddparams"></a>

```json
{
  "name": "string",
  "storage": {
    "count": 0,
    "pool": "string",
    "size": 0
  },
  "unit": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|name|string|true|none|none|
|storage|[StorageConstraints](#schemastorageconstraints)|true|none|none|
|unit|string|true|none|none|

<h2 id="tocS_StorageAttachmentDetails">StorageAttachmentDetails</h2>
<!-- backwards compatibility -->
<a id="schemastorageattachmentdetails"></a>
<a id="schema_StorageAttachmentDetails"></a>
<a id="tocSstorageattachmentdetails"></a>
<a id="tocsstorageattachmentdetails"></a>

```json
{
  "life": "string",
  "location": "string",
  "machine-tag": "string",
  "storage-tag": "string",
  "unit-tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|life|string|false|none|none|
|location|string|false|none|none|
|machine-tag|string|true|none|none|
|storage-tag|string|true|none|none|
|unit-tag|string|true|none|none|

<h2 id="tocS_StorageAttachmentId">StorageAttachmentId</h2>
<!-- backwards compatibility -->
<a id="schemastorageattachmentid"></a>
<a id="schema_StorageAttachmentId"></a>
<a id="tocSstorageattachmentid"></a>
<a id="tocsstorageattachmentid"></a>

```json
{
  "storage-tag": "string",
  "unit-tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|storage-tag|string|true|none|none|
|unit-tag|string|true|none|none|

<h2 id="tocS_StorageAttachmentIds">StorageAttachmentIds</h2>
<!-- backwards compatibility -->
<a id="schemastorageattachmentids"></a>
<a id="schema_StorageAttachmentIds"></a>
<a id="tocSstorageattachmentids"></a>
<a id="tocsstorageattachmentids"></a>

```json
{
  "ids": [
    {
      "storage-tag": "string",
      "unit-tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|ids|[[StorageAttachmentId](#schemastorageattachmentid)]|true|none|none|

<h2 id="tocS_StorageDetachmentParams">StorageDetachmentParams</h2>
<!-- backwards compatibility -->
<a id="schemastoragedetachmentparams"></a>
<a id="schema_StorageDetachmentParams"></a>
<a id="tocSstoragedetachmentparams"></a>
<a id="tocsstoragedetachmentparams"></a>

```json
{
  "force": true,
  "ids": {
    "ids": [
      {
        "storage-tag": "string",
        "unit-tag": "string"
      }
    ]
  },
  "max-wait": 0
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|force|boolean|false|none|none|
|ids|[StorageAttachmentIds](#schemastorageattachmentids)|true|none|none|
|max-wait|integer|false|none|none|

<h2 id="tocS_StorageDetails">StorageDetails</h2>
<!-- backwards compatibility -->
<a id="schemastoragedetails"></a>
<a id="schema_StorageDetails"></a>
<a id="tocSstoragedetails"></a>
<a id="tocsstoragedetails"></a>

```json
{
  "attachments": {},
  "kind": 0,
  "life": "string",
  "owner-tag": "string",
  "persistent": true,
  "status": {
    "data": {},
    "info": "string",
    "since": "2019-08-24T14:15:22Z",
    "status": "string"
  },
  "storage-tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|attachments|object|false|none|none|
|» .*|[StorageAttachmentDetails](#schemastorageattachmentdetails)|false|none|none|
|kind|integer|true|none|none|
|life|string|false|none|none|
|owner-tag|string|true|none|none|
|persistent|boolean|true|none|none|
|status|[EntityStatus](#schemaentitystatus)|true|none|none|
|storage-tag|string|true|none|none|

<h2 id="tocS_StorageDetailsListResult">StorageDetailsListResult</h2>
<!-- backwards compatibility -->
<a id="schemastoragedetailslistresult"></a>
<a id="schema_StorageDetailsListResult"></a>
<a id="tocSstoragedetailslistresult"></a>
<a id="tocsstoragedetailslistresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": [
    {
      "attachments": {},
      "kind": 0,
      "life": "string",
      "owner-tag": "string",
      "persistent": true,
      "status": {
        "data": {},
        "info": "string",
        "since": "2019-08-24T14:15:22Z",
        "status": "string"
      },
      "storage-tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|result|[[StorageDetails](#schemastoragedetails)]|false|none|none|

<h2 id="tocS_StorageDetailsListResults">StorageDetailsListResults</h2>
<!-- backwards compatibility -->
<a id="schemastoragedetailslistresults"></a>
<a id="schema_StorageDetailsListResults"></a>
<a id="tocSstoragedetailslistresults"></a>
<a id="tocsstoragedetailslistresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": [
        {
          "attachments": {},
          "kind": 0,
          "life": "string",
          "owner-tag": "string",
          "persistent": true,
          "status": {
            "data": {},
            "info": "string",
            "since": "2019-08-24T14:15:22Z",
            "status": "string"
          },
          "storage-tag": "string"
        }
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[StorageDetailsListResult](#schemastoragedetailslistresult)]|false|none|none|

<h2 id="tocS_StorageDetailsResult">StorageDetailsResult</h2>
<!-- backwards compatibility -->
<a id="schemastoragedetailsresult"></a>
<a id="schema_StorageDetailsResult"></a>
<a id="tocSstoragedetailsresult"></a>
<a id="tocsstoragedetailsresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": {
    "attachments": {},
    "kind": 0,
    "life": "string",
    "owner-tag": "string",
    "persistent": true,
    "status": {
      "data": {},
      "info": "string",
      "since": "2019-08-24T14:15:22Z",
      "status": "string"
    },
    "storage-tag": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|result|[StorageDetails](#schemastoragedetails)|false|none|none|

<h2 id="tocS_StorageDetailsResults">StorageDetailsResults</h2>
<!-- backwards compatibility -->
<a id="schemastoragedetailsresults"></a>
<a id="schema_StorageDetailsResults"></a>
<a id="tocSstoragedetailsresults"></a>
<a id="tocsstoragedetailsresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "attachments": {},
        "kind": 0,
        "life": "string",
        "owner-tag": "string",
        "persistent": true,
        "status": {
          "data": {},
          "info": "string",
          "since": "2019-08-24T14:15:22Z",
          "status": "string"
        },
        "storage-tag": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[StorageDetailsResult](#schemastoragedetailsresult)]|false|none|none|

<h2 id="tocS_StorageFilter">StorageFilter</h2>
<!-- backwards compatibility -->
<a id="schemastoragefilter"></a>
<a id="schema_StorageFilter"></a>
<a id="tocSstoragefilter"></a>
<a id="tocsstoragefilter"></a>

```json
{}

```

### Properties

*None*

<h2 id="tocS_StorageFilters">StorageFilters</h2>
<!-- backwards compatibility -->
<a id="schemastoragefilters"></a>
<a id="schema_StorageFilters"></a>
<a id="tocSstoragefilters"></a>
<a id="tocsstoragefilters"></a>

```json
{
  "filters": [
    {}
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|filters|[[StorageFilter](#schemastoragefilter)]|false|none|none|

<h2 id="tocS_StoragePool">StoragePool</h2>
<!-- backwards compatibility -->
<a id="schemastoragepool"></a>
<a id="schema_StoragePool"></a>
<a id="tocSstoragepool"></a>
<a id="tocsstoragepool"></a>

```json
{
  "attrs": {},
  "name": "string",
  "provider": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|attrs|object|true|none|none|
|» .*|object|false|none|none|
|name|string|true|none|none|
|provider|string|true|none|none|

<h2 id="tocS_StoragePoolArgs">StoragePoolArgs</h2>
<!-- backwards compatibility -->
<a id="schemastoragepoolargs"></a>
<a id="schema_StoragePoolArgs"></a>
<a id="tocSstoragepoolargs"></a>
<a id="tocsstoragepoolargs"></a>

```json
{
  "pools": [
    {
      "attrs": {},
      "name": "string",
      "provider": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|pools|[[StoragePool](#schemastoragepool)]|true|none|none|

<h2 id="tocS_StoragePoolDeleteArg">StoragePoolDeleteArg</h2>
<!-- backwards compatibility -->
<a id="schemastoragepooldeletearg"></a>
<a id="schema_StoragePoolDeleteArg"></a>
<a id="tocSstoragepooldeletearg"></a>
<a id="tocsstoragepooldeletearg"></a>

```json
{
  "name": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|name|string|true|none|none|

<h2 id="tocS_StoragePoolDeleteArgs">StoragePoolDeleteArgs</h2>
<!-- backwards compatibility -->
<a id="schemastoragepooldeleteargs"></a>
<a id="schema_StoragePoolDeleteArgs"></a>
<a id="tocSstoragepooldeleteargs"></a>
<a id="tocsstoragepooldeleteargs"></a>

```json
{
  "pools": [
    {
      "name": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|pools|[[StoragePoolDeleteArg](#schemastoragepooldeletearg)]|true|none|none|

<h2 id="tocS_StoragePoolFilter">StoragePoolFilter</h2>
<!-- backwards compatibility -->
<a id="schemastoragepoolfilter"></a>
<a id="schema_StoragePoolFilter"></a>
<a id="tocSstoragepoolfilter"></a>
<a id="tocsstoragepoolfilter"></a>

```json
{
  "names": [
    "string"
  ],
  "providers": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|names|[string]|false|none|none|
|providers|[string]|false|none|none|

<h2 id="tocS_StoragePoolFilters">StoragePoolFilters</h2>
<!-- backwards compatibility -->
<a id="schemastoragepoolfilters"></a>
<a id="schema_StoragePoolFilters"></a>
<a id="tocSstoragepoolfilters"></a>
<a id="tocsstoragepoolfilters"></a>

```json
{
  "filters": [
    {
      "names": [
        "string"
      ],
      "providers": [
        "string"
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|filters|[[StoragePoolFilter](#schemastoragepoolfilter)]|false|none|none|

<h2 id="tocS_StoragePoolsResult">StoragePoolsResult</h2>
<!-- backwards compatibility -->
<a id="schemastoragepoolsresult"></a>
<a id="schema_StoragePoolsResult"></a>
<a id="tocSstoragepoolsresult"></a>
<a id="tocsstoragepoolsresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "storage-pools": [
    {
      "attrs": {},
      "name": "string",
      "provider": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|storage-pools|[[StoragePool](#schemastoragepool)]|false|none|none|

<h2 id="tocS_StoragePoolsResults">StoragePoolsResults</h2>
<!-- backwards compatibility -->
<a id="schemastoragepoolsresults"></a>
<a id="schema_StoragePoolsResults"></a>
<a id="tocSstoragepoolsresults"></a>
<a id="tocsstoragepoolsresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "storage-pools": [
        {
          "attrs": {},
          "name": "string",
          "provider": "string"
        }
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[StoragePoolsResult](#schemastoragepoolsresult)]|false|none|none|

<h2 id="tocS_StoragesAddParams">StoragesAddParams</h2>
<!-- backwards compatibility -->
<a id="schemastoragesaddparams"></a>
<a id="schema_StoragesAddParams"></a>
<a id="tocSstoragesaddparams"></a>
<a id="tocsstoragesaddparams"></a>

```json
{
  "storages": [
    {
      "name": "string",
      "storage": {
        "count": 0,
        "pool": "string",
        "size": 0
      },
      "unit": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|storages|[[StorageAddParams](#schemastorageaddparams)]|true|none|none|

<h2 id="tocS_VolumeAttachmentDetails">VolumeAttachmentDetails</h2>
<!-- backwards compatibility -->
<a id="schemavolumeattachmentdetails"></a>
<a id="schema_VolumeAttachmentDetails"></a>
<a id="tocSvolumeattachmentdetails"></a>
<a id="tocsvolumeattachmentdetails"></a>

```json
{
  "VolumeAttachmentInfo": {
    "bus-address": "string",
    "device-link": "string",
    "device-name": "string",
    "plan-info": {
      "device-attributes": {},
      "device-type": "string"
    },
    "read-only": true
  },
  "bus-address": "string",
  "device-link": "string",
  "device-name": "string",
  "life": "string",
  "plan-info": {
    "device-attributes": {},
    "device-type": "string"
  },
  "read-only": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|VolumeAttachmentInfo|[VolumeAttachmentInfo](#schemavolumeattachmentinfo)|true|none|none|
|bus-address|string|false|none|none|
|device-link|string|false|none|none|
|device-name|string|false|none|none|
|life|string|false|none|none|
|plan-info|[VolumeAttachmentPlanInfo](#schemavolumeattachmentplaninfo)|false|none|none|
|read-only|boolean|false|none|none|

<h2 id="tocS_VolumeAttachmentInfo">VolumeAttachmentInfo</h2>
<!-- backwards compatibility -->
<a id="schemavolumeattachmentinfo"></a>
<a id="schema_VolumeAttachmentInfo"></a>
<a id="tocSvolumeattachmentinfo"></a>
<a id="tocsvolumeattachmentinfo"></a>

```json
{
  "bus-address": "string",
  "device-link": "string",
  "device-name": "string",
  "plan-info": {
    "device-attributes": {},
    "device-type": "string"
  },
  "read-only": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|bus-address|string|false|none|none|
|device-link|string|false|none|none|
|device-name|string|false|none|none|
|plan-info|[VolumeAttachmentPlanInfo](#schemavolumeattachmentplaninfo)|false|none|none|
|read-only|boolean|false|none|none|

<h2 id="tocS_VolumeAttachmentPlanInfo">VolumeAttachmentPlanInfo</h2>
<!-- backwards compatibility -->
<a id="schemavolumeattachmentplaninfo"></a>
<a id="schema_VolumeAttachmentPlanInfo"></a>
<a id="tocSvolumeattachmentplaninfo"></a>
<a id="tocsvolumeattachmentplaninfo"></a>

```json
{
  "device-attributes": {},
  "device-type": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|device-attributes|object|false|none|none|
|» .*|string|false|none|none|
|device-type|string|false|none|none|

<h2 id="tocS_VolumeDetails">VolumeDetails</h2>
<!-- backwards compatibility -->
<a id="schemavolumedetails"></a>
<a id="schema_VolumeDetails"></a>
<a id="tocSvolumedetails"></a>
<a id="tocsvolumedetails"></a>

```json
{
  "info": {
    "hardware-id": "string",
    "persistent": true,
    "pool": "string",
    "size": 0,
    "volume-id": "string",
    "wwn": "string"
  },
  "life": "string",
  "machine-attachments": {},
  "status": {
    "data": {},
    "info": "string",
    "since": "2019-08-24T14:15:22Z",
    "status": "string"
  },
  "storage": {
    "attachments": {},
    "kind": 0,
    "life": "string",
    "owner-tag": "string",
    "persistent": true,
    "status": {
      "data": {},
      "info": "string",
      "since": "2019-08-24T14:15:22Z",
      "status": "string"
    },
    "storage-tag": "string"
  },
  "unit-attachments": {},
  "volume-tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|info|[VolumeInfo](#schemavolumeinfo)|true|none|none|
|life|string|false|none|none|
|machine-attachments|object|false|none|none|
|» .*|[VolumeAttachmentDetails](#schemavolumeattachmentdetails)|false|none|none|
|status|[EntityStatus](#schemaentitystatus)|true|none|none|
|storage|[StorageDetails](#schemastoragedetails)|false|none|none|
|unit-attachments|object|false|none|none|
|» .*|[VolumeAttachmentDetails](#schemavolumeattachmentdetails)|false|none|none|
|volume-tag|string|true|none|none|

<h2 id="tocS_VolumeDetailsListResult">VolumeDetailsListResult</h2>
<!-- backwards compatibility -->
<a id="schemavolumedetailslistresult"></a>
<a id="schema_VolumeDetailsListResult"></a>
<a id="tocSvolumedetailslistresult"></a>
<a id="tocsvolumedetailslistresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": [
    {
      "info": {
        "hardware-id": "string",
        "persistent": true,
        "pool": "string",
        "size": 0,
        "volume-id": "string",
        "wwn": "string"
      },
      "life": "string",
      "machine-attachments": {},
      "status": {
        "data": {},
        "info": "string",
        "since": "2019-08-24T14:15:22Z",
        "status": "string"
      },
      "storage": {
        "attachments": {},
        "kind": 0,
        "life": "string",
        "owner-tag": "string",
        "persistent": true,
        "status": {
          "data": {},
          "info": "string",
          "since": "2019-08-24T14:15:22Z",
          "status": "string"
        },
        "storage-tag": "string"
      },
      "unit-attachments": {},
      "volume-tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|result|[[VolumeDetails](#schemavolumedetails)]|false|none|none|

<h2 id="tocS_VolumeDetailsListResults">VolumeDetailsListResults</h2>
<!-- backwards compatibility -->
<a id="schemavolumedetailslistresults"></a>
<a id="schema_VolumeDetailsListResults"></a>
<a id="tocSvolumedetailslistresults"></a>
<a id="tocsvolumedetailslistresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": [
        {
          "info": {
            "hardware-id": "string",
            "persistent": true,
            "pool": "string",
            "size": 0,
            "volume-id": "string",
            "wwn": "string"
          },
          "life": "string",
          "machine-attachments": {},
          "status": {
            "data": {},
            "info": "string",
            "since": "2019-08-24T14:15:22Z",
            "status": "string"
          },
          "storage": {
            "attachments": {},
            "kind": 0,
            "life": "string",
            "owner-tag": "string",
            "persistent": true,
            "status": {
              "data": {},
              "info": "string",
              "since": "2019-08-24T14:15:22Z",
              "status": "string"
            },
            "storage-tag": "string"
          },
          "unit-attachments": {},
          "volume-tag": "string"
        }
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[VolumeDetailsListResult](#schemavolumedetailslistresult)]|false|none|none|

<h2 id="tocS_VolumeFilter">VolumeFilter</h2>
<!-- backwards compatibility -->
<a id="schemavolumefilter"></a>
<a id="schema_VolumeFilter"></a>
<a id="tocSvolumefilter"></a>
<a id="tocsvolumefilter"></a>

```json
{
  "machines": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|machines|[string]|false|none|none|

<h2 id="tocS_VolumeFilters">VolumeFilters</h2>
<!-- backwards compatibility -->
<a id="schemavolumefilters"></a>
<a id="schema_VolumeFilters"></a>
<a id="tocSvolumefilters"></a>
<a id="tocsvolumefilters"></a>

```json
{
  "filters": [
    {
      "machines": [
        "string"
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|filters|[[VolumeFilter](#schemavolumefilter)]|false|none|none|

<h2 id="tocS_VolumeInfo">VolumeInfo</h2>
<!-- backwards compatibility -->
<a id="schemavolumeinfo"></a>
<a id="schema_VolumeInfo"></a>
<a id="tocSvolumeinfo"></a>
<a id="tocsvolumeinfo"></a>

```json
{
  "hardware-id": "string",
  "persistent": true,
  "pool": "string",
  "size": 0,
  "volume-id": "string",
  "wwn": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|hardware-id|string|false|none|none|
|persistent|boolean|true|none|none|
|pool|string|false|none|none|
|size|integer|true|none|none|
|volume-id|string|true|none|none|
|wwn|string|false|none|none|

<h2 id="tocS_CIDRParams">CIDRParams</h2>
<!-- backwards compatibility -->
<a id="schemacidrparams"></a>
<a id="schema_CIDRParams"></a>
<a id="tocScidrparams"></a>
<a id="tocscidrparams"></a>

```json
{
  "cidrs": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|cidrs|[string]|true|none|none|

<h2 id="tocS_ListSubnetsResults">ListSubnetsResults</h2>
<!-- backwards compatibility -->
<a id="schemalistsubnetsresults"></a>
<a id="schema_ListSubnetsResults"></a>
<a id="tocSlistsubnetsresults"></a>
<a id="tocslistsubnetsresults"></a>

```json
{
  "results": [
    {
      "cidr": "string",
      "life": "string",
      "provider-id": "string",
      "provider-network-id": "string",
      "provider-space-id": "string",
      "space-tag": "string",
      "status": "string",
      "vlan-tag": 0,
      "zones": [
        "string"
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[Subnet](#schemasubnet)]|true|none|none|

<h2 id="tocS_SubnetV2">SubnetV2</h2>
<!-- backwards compatibility -->
<a id="schemasubnetv2"></a>
<a id="schema_SubnetV2"></a>
<a id="tocSsubnetv2"></a>
<a id="tocssubnetv2"></a>

```json
{
  "Subnet": {
    "cidr": "string",
    "life": "string",
    "provider-id": "string",
    "provider-network-id": "string",
    "provider-space-id": "string",
    "space-tag": "string",
    "status": "string",
    "vlan-tag": 0,
    "zones": [
      "string"
    ]
  },
  "cidr": "string",
  "id": "string",
  "life": "string",
  "provider-id": "string",
  "provider-network-id": "string",
  "provider-space-id": "string",
  "space-tag": "string",
  "status": "string",
  "vlan-tag": 0,
  "zones": [
    "string"
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|Subnet|[Subnet](#schemasubnet)|true|none|none|
|cidr|string|true|none|none|
|id|string|false|none|none|
|life|string|true|none|none|
|provider-id|string|false|none|none|
|provider-network-id|string|false|none|none|
|provider-space-id|string|false|none|none|
|space-tag|string|true|none|none|
|status|string|false|none|none|
|vlan-tag|integer|true|none|none|
|zones|[string]|true|none|none|

<h2 id="tocS_SubnetsFilters">SubnetsFilters</h2>
<!-- backwards compatibility -->
<a id="schemasubnetsfilters"></a>
<a id="schema_SubnetsFilters"></a>
<a id="tocSsubnetsfilters"></a>
<a id="tocssubnetsfilters"></a>

```json
{
  "space-tag": "string",
  "zone": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|space-tag|string|false|none|none|
|zone|string|false|none|none|

<h2 id="tocS_SubnetsResult">SubnetsResult</h2>
<!-- backwards compatibility -->
<a id="schemasubnetsresult"></a>
<a id="schema_SubnetsResult"></a>
<a id="tocSsubnetsresult"></a>
<a id="tocssubnetsresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "subnets": [
    {
      "Subnet": {
        "cidr": "string",
        "life": "string",
        "provider-id": "string",
        "provider-network-id": "string",
        "provider-space-id": "string",
        "space-tag": "string",
        "status": "string",
        "vlan-tag": 0,
        "zones": [
          "string"
        ]
      },
      "cidr": "string",
      "id": "string",
      "life": "string",
      "provider-id": "string",
      "provider-network-id": "string",
      "provider-space-id": "string",
      "space-tag": "string",
      "status": "string",
      "vlan-tag": 0,
      "zones": [
        "string"
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|subnets|[[SubnetV2](#schemasubnetv2)]|false|none|none|

<h2 id="tocS_SubnetsResults">SubnetsResults</h2>
<!-- backwards compatibility -->
<a id="schemasubnetsresults"></a>
<a id="schema_SubnetsResults"></a>
<a id="tocSsubnetsresults"></a>
<a id="tocssubnetsresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "subnets": [
        {
          "Subnet": {
            "cidr": "string",
            "life": "string",
            "provider-id": "string",
            "provider-network-id": "string",
            "provider-space-id": "string",
            "space-tag": "string",
            "status": "string",
            "vlan-tag": 0,
            "zones": [
              "string"
            ]
          },
          "cidr": "string",
          "id": "string",
          "life": "string",
          "provider-id": "string",
          "provider-network-id": "string",
          "provider-space-id": "string",
          "space-tag": "string",
          "status": "string",
          "vlan-tag": 0,
          "zones": [
            "string"
          ]
        }
      ]
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[SubnetsResult](#schemasubnetsresult)]|true|none|none|

<h2 id="tocS_ZoneResult">ZoneResult</h2>
<!-- backwards compatibility -->
<a id="schemazoneresult"></a>
<a id="schema_ZoneResult"></a>
<a id="tocSzoneresult"></a>
<a id="tocszoneresult"></a>

```json
{
  "available": true,
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "name": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|available|boolean|true|none|none|
|error|[Error](#schemaerror)|false|none|none|
|name|string|true|none|none|

<h2 id="tocS_ZoneResults">ZoneResults</h2>
<!-- backwards compatibility -->
<a id="schemazoneresults"></a>
<a id="schema_ZoneResults"></a>
<a id="tocSzoneresults"></a>
<a id="tocszoneresults"></a>

```json
{
  "results": [
    {
      "available": true,
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "name": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[ZoneResult](#schemazoneresult)]|true|none|none|

<h2 id="tocS_AddUser">AddUser</h2>
<!-- backwards compatibility -->
<a id="schemaadduser"></a>
<a id="schema_AddUser"></a>
<a id="tocSadduser"></a>
<a id="tocsadduser"></a>

```json
{
  "display-name": "string",
  "password": "string",
  "username": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|display-name|string|true|none|none|
|password|string|false|none|none|
|username|string|true|none|none|

<h2 id="tocS_AddUserResult">AddUserResult</h2>
<!-- backwards compatibility -->
<a id="schemaadduserresult"></a>
<a id="schema_AddUserResult"></a>
<a id="tocSadduserresult"></a>
<a id="tocsadduserresult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "secret-key": [
    0
  ],
  "tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|secret-key|[integer]|false|none|none|
|tag|string|false|none|none|

<h2 id="tocS_AddUserResults">AddUserResults</h2>
<!-- backwards compatibility -->
<a id="schemaadduserresults"></a>
<a id="schema_AddUserResults"></a>
<a id="tocSadduserresults"></a>
<a id="tocsadduserresults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "secret-key": [
        0
      ],
      "tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[AddUserResult](#schemaadduserresult)]|true|none|none|

<h2 id="tocS_AddUsers">AddUsers</h2>
<!-- backwards compatibility -->
<a id="schemaaddusers"></a>
<a id="schema_AddUsers"></a>
<a id="tocSaddusers"></a>
<a id="tocsaddusers"></a>

```json
{
  "users": [
    {
      "display-name": "string",
      "password": "string",
      "username": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|users|[[AddUser](#schemaadduser)]|true|none|none|

<h2 id="tocS_EntityPassword">EntityPassword</h2>
<!-- backwards compatibility -->
<a id="schemaentitypassword"></a>
<a id="schema_EntityPassword"></a>
<a id="tocSentitypassword"></a>
<a id="tocsentitypassword"></a>

```json
{
  "password": "string",
  "tag": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|password|string|true|none|none|
|tag|string|true|none|none|

<h2 id="tocS_EntityPasswords">EntityPasswords</h2>
<!-- backwards compatibility -->
<a id="schemaentitypasswords"></a>
<a id="schema_EntityPasswords"></a>
<a id="tocSentitypasswords"></a>
<a id="tocsentitypasswords"></a>

```json
{
  "changes": [
    {
      "password": "string",
      "tag": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|changes|[[EntityPassword](#schemaentitypassword)]|true|none|none|

<h2 id="tocS_ModelUserInfoResult">ModelUserInfoResult</h2>
<!-- backwards compatibility -->
<a id="schemamodeluserinforesult"></a>
<a id="schema_ModelUserInfoResult"></a>
<a id="tocSmodeluserinforesult"></a>
<a id="tocsmodeluserinforesult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": {
    "access": "string",
    "display-name": "string",
    "last-connection": "2019-08-24T14:15:22Z",
    "model-tag": "string",
    "user": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|result|[ModelUserInfo](#schemamodeluserinfo)|false|none|none|

<h2 id="tocS_ModelUserInfoResults">ModelUserInfoResults</h2>
<!-- backwards compatibility -->
<a id="schemamodeluserinforesults"></a>
<a id="schema_ModelUserInfoResults"></a>
<a id="tocSmodeluserinforesults"></a>
<a id="tocsmodeluserinforesults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "access": "string",
        "display-name": "string",
        "last-connection": "2019-08-24T14:15:22Z",
        "model-tag": "string",
        "user": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[ModelUserInfoResult](#schemamodeluserinforesult)]|true|none|none|

<h2 id="tocS_UserInfo">UserInfo</h2>
<!-- backwards compatibility -->
<a id="schemauserinfo"></a>
<a id="schema_UserInfo"></a>
<a id="tocSuserinfo"></a>
<a id="tocsuserinfo"></a>

```json
{
  "access": "string",
  "created-by": "string",
  "date-created": "2019-08-24T14:15:22Z",
  "disabled": true,
  "display-name": "string",
  "last-connection": "2019-08-24T14:15:22Z",
  "username": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|access|string|true|none|none|
|created-by|string|true|none|none|
|date-created|string(date-time)|true|none|none|
|disabled|boolean|true|none|none|
|display-name|string|true|none|none|
|last-connection|string(date-time)|false|none|none|
|username|string|true|none|none|

<h2 id="tocS_UserInfoRequest">UserInfoRequest</h2>
<!-- backwards compatibility -->
<a id="schemauserinforequest"></a>
<a id="schema_UserInfoRequest"></a>
<a id="tocSuserinforequest"></a>
<a id="tocsuserinforequest"></a>

```json
{
  "entities": [
    {
      "tag": "string"
    }
  ],
  "include-disabled": true
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|entities|[[Entity](#schemaentity)]|true|none|none|
|include-disabled|boolean|true|none|none|

<h2 id="tocS_UserInfoResult">UserInfoResult</h2>
<!-- backwards compatibility -->
<a id="schemauserinforesult"></a>
<a id="schema_UserInfoResult"></a>
<a id="tocSuserinforesult"></a>
<a id="tocsuserinforesult"></a>

```json
{
  "error": {
    "code": "string",
    "info": {},
    "message": "string"
  },
  "result": {
    "access": "string",
    "created-by": "string",
    "date-created": "2019-08-24T14:15:22Z",
    "disabled": true,
    "display-name": "string",
    "last-connection": "2019-08-24T14:15:22Z",
    "username": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[Error](#schemaerror)|false|none|none|
|result|[UserInfo](#schemauserinfo)|false|none|none|

<h2 id="tocS_UserInfoResults">UserInfoResults</h2>
<!-- backwards compatibility -->
<a id="schemauserinforesults"></a>
<a id="schema_UserInfoResults"></a>
<a id="tocSuserinforesults"></a>
<a id="tocsuserinforesults"></a>

```json
{
  "results": [
    {
      "error": {
        "code": "string",
        "info": {},
        "message": "string"
      },
      "result": {
        "access": "string",
        "created-by": "string",
        "date-created": "2019-08-24T14:15:22Z",
        "disabled": true,
        "display-name": "string",
        "last-connection": "2019-08-24T14:15:22Z",
        "username": "string"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[[UserInfoResult](#schemauserinforesult)]|true|none|none|

